//
// Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License version 2 only, as
// published by the Free Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// You should have received a copy of the GNU General Public License version
// 2 along with this work; if not, write to the Free Software Foundation,
// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
//
// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
// or visit www.oracle.com if you need additional information or have any
// questions.
//
//

// Machine Generated File.  Do Not Edit!

#include "precompiled.hpp"
#include "adfiles/adGlobals_x86_64.hpp"
#include "adfiles/ad_x86_64.hpp"
#include "memory/allocation.inline.hpp"
#include "asm/assembler.hpp"
#include "code/vmreg.hpp"
#include "gc_interface/collectedHeap.inline.hpp"
#include "oops/compiledICHolderOop.hpp"
#include "oops/markOop.hpp"
#include "oops/methodOop.hpp"
#include "oops/oop.inline.hpp"
#include "oops/oop.inline2.hpp"
#include "opto/cfgnode.hpp"
#include "opto/locknode.hpp"
#include "opto/opcodes.hpp"
#include "opto/regalloc.hpp"
#include "opto/regmask.hpp"
#include "opto/runtime.hpp"
#include "runtime/biasedLocking.hpp"
#include "runtime/sharedRuntime.hpp"
#include "runtime/stubRoutines.hpp"
#include "utilities/growableArray.hpp"
#include "assembler_x86.inline.hpp"
#include "nativeInst_x86.hpp"
#include "vmreg_x86.inline.hpp"

//SourceForm

#line 548 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

#define   RELOC_IMM64    Assembler::imm_operand
#define   RELOC_DISP32   Assembler::disp32_operand

#define __ _masm.

static int preserve_SP_size() {
  return LP64_ONLY(1 +) 2;  // [rex,] op, rm(reg/reg)
}

// !!!!! Special hack to get all types of calls to specify the byte offset
//       from the start of the call to the point where the return address
//       will point.
int MachCallStaticJavaNode::ret_addr_offset()
{
  int offset = 5; // 5 bytes from start of call to where return address points
  if (_method_handle_invoke)
    offset += preserve_SP_size();
  return offset;
}

int MachCallDynamicJavaNode::ret_addr_offset()
{
  return 15; // 15 bytes from start of call to where return address points
}

// In os_cpu .ad file
// int MachCallRuntimeNode::ret_addr_offset()

// Indicate if the safepoint node needs the polling page as an input,
// it does if the polling page is more than disp32 away.
bool SafePointNode::needs_polling_address_input()
{
  return Assembler::is_polling_page_far();
}

//
// Compute padding required for nodes which need alignment
//

// The address of the call instruction needs to be 4-byte aligned to
// ensure that it does not span a cache line so that it can be patched.
int CallStaticJavaDirectNode::compute_padding(int current_offset) const
{
  current_offset += 1; // skip call opcode byte
  return round_to(current_offset, alignment_required()) - current_offset;
}

// The address of the call instruction needs to be 4-byte aligned to
// ensure that it does not span a cache line so that it can be patched.
int CallStaticJavaHandleNode::compute_padding(int current_offset) const
{
  current_offset += preserve_SP_size();   // skip mov rbp, rsp
  current_offset += 1; // skip call opcode byte
  return round_to(current_offset, alignment_required()) - current_offset;
}

// The address of the call instruction needs to be 4-byte aligned to
// ensure that it does not span a cache line so that it can be patched.
int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
{
  current_offset += 11; // skip movq instruction + call opcode byte
  return round_to(current_offset, alignment_required()) - current_offset;
}

#ifndef PRODUCT
void MachBreakpointNode::format(PhaseRegAlloc*, outputStream* st) const
{
  st->print("INT3");
}
#endif

// EMIT_RM()
void emit_rm(CodeBuffer &cbuf, int f1, int f2, int f3) {
  unsigned char c = (unsigned char) ((f1 << 6) | (f2 << 3) | f3);
  cbuf.insts()->emit_int8(c);
}

// EMIT_CC()
void emit_cc(CodeBuffer &cbuf, int f1, int f2) {
  unsigned char c = (unsigned char) (f1 | f2);
  cbuf.insts()->emit_int8(c);
}

// EMIT_OPCODE()
void emit_opcode(CodeBuffer &cbuf, int code) {
  cbuf.insts()->emit_int8((unsigned char) code);
}

// EMIT_OPCODE() w/ relocation information
void emit_opcode(CodeBuffer &cbuf,
                 int code, relocInfo::relocType reloc, int offset, int format)
{
  cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
  emit_opcode(cbuf, code);
}

// EMIT_D8()
void emit_d8(CodeBuffer &cbuf, int d8) {
  cbuf.insts()->emit_int8((unsigned char) d8);
}

// EMIT_D16()
void emit_d16(CodeBuffer &cbuf, int d16) {
  cbuf.insts()->emit_int16(d16);
}

// EMIT_D32()
void emit_d32(CodeBuffer &cbuf, int d32) {
  cbuf.insts()->emit_int32(d32);
}

// EMIT_D64()
void emit_d64(CodeBuffer &cbuf, int64_t d64) {
  cbuf.insts()->emit_int64(d64);
}

// emit 32 bit value and construct relocation entry from relocInfo::relocType
void emit_d32_reloc(CodeBuffer& cbuf,
                    int d32,
                    relocInfo::relocType reloc,
                    int format)
{
  assert(reloc != relocInfo::external_word_type, "use 2-arg emit_d32_reloc");
  cbuf.relocate(cbuf.insts_mark(), reloc, format);
  cbuf.insts()->emit_int32(d32);
}

// emit 32 bit value and construct relocation entry from RelocationHolder
void emit_d32_reloc(CodeBuffer& cbuf, int d32, RelocationHolder const& rspec, int format) {
#ifdef ASSERT
  if (rspec.reloc()->type() == relocInfo::oop_type &&
      d32 != 0 && d32 != (intptr_t) Universe::non_oop_word()) {
    assert(oop((intptr_t)d32)->is_oop() && (ScavengeRootsInCode || !oop((intptr_t)d32)->is_scavengable()), "cannot embed scavengable oops in code");
  }
#endif
  cbuf.relocate(cbuf.insts_mark(), rspec, format);
  cbuf.insts()->emit_int32(d32);
}

void emit_d32_reloc(CodeBuffer& cbuf, address addr) {
  address next_ip = cbuf.insts_end() + 4;
  emit_d32_reloc(cbuf, (int) (addr - next_ip),
                 external_word_Relocation::spec(addr),
                 RELOC_DISP32);
}


// emit 64 bit value and construct relocation entry from relocInfo::relocType
void emit_d64_reloc(CodeBuffer& cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
  cbuf.relocate(cbuf.insts_mark(), reloc, format);
  cbuf.insts()->emit_int64(d64);
}

// emit 64 bit value and construct relocation entry from RelocationHolder
void emit_d64_reloc(CodeBuffer& cbuf, int64_t d64, RelocationHolder const& rspec, int format) {
#ifdef ASSERT
  if (rspec.reloc()->type() == relocInfo::oop_type &&
      d64 != 0 && d64 != (int64_t) Universe::non_oop_word()) {
    assert(oop(d64)->is_oop() && (ScavengeRootsInCode || !oop(d64)->is_scavengable()),
           "cannot embed scavengable oops in code");
  }
#endif
  cbuf.relocate(cbuf.insts_mark(), rspec, format);
  cbuf.insts()->emit_int64(d64);
}

// Access stack slot for load or store
void store_to_stackslot(CodeBuffer &cbuf, int opcode, int rm_field, int disp)
{
  emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  if (-0x80 <= disp && disp < 0x80) {
    emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
    emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
    emit_d8(cbuf, disp);     // Displacement  // R/M byte
  } else {
    emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
    emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
    emit_d32(cbuf, disp);     // Displacement // R/M byte
  }
}

   // rRegI ereg, memory mem) %{    // emit_reg_mem
void encode_RegMem(CodeBuffer &cbuf,
                   int reg,
                   int base, int index, int scale, int disp, bool disp_is_oop)
{
  assert(!disp_is_oop, "cannot have disp");
  int regenc = reg & 7;
  int baseenc = base & 7;
  int indexenc = index & 7;

  // There is no index & no scale, use form without SIB byte
  if (index == 0x4 && scale == 0 && base != RSP_enc && base != R12_enc) {
    // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
    if (disp == 0 && base != RBP_enc && base != R13_enc) {
      emit_rm(cbuf, 0x0, regenc, baseenc); // *
    } else if (-0x80 <= disp && disp < 0x80 && !disp_is_oop) {
      // If 8-bit displacement, mode 0x1
      emit_rm(cbuf, 0x1, regenc, baseenc); // *
      emit_d8(cbuf, disp);
    } else {
      // If 32-bit displacement
      if (base == -1) { // Special flag for absolute address
        emit_rm(cbuf, 0x0, regenc, 0x5); // *
        if (disp_is_oop) {
          emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
        } else {
          emit_d32(cbuf, disp);
        }
      } else {
        // Normal base + offset
        emit_rm(cbuf, 0x2, regenc, baseenc); // *
        if (disp_is_oop) {
          emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
        } else {
          emit_d32(cbuf, disp);
        }
      }
    }
  } else {
    // Else, encode with the SIB byte
    // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
    if (disp == 0 && base != RBP_enc && base != R13_enc) {
      // If no displacement
      emit_rm(cbuf, 0x0, regenc, 0x4); // *
      emit_rm(cbuf, scale, indexenc, baseenc);
    } else {
      if (-0x80 <= disp && disp < 0x80 && !disp_is_oop) {
        // If 8-bit displacement, mode 0x1
        emit_rm(cbuf, 0x1, regenc, 0x4); // *
        emit_rm(cbuf, scale, indexenc, baseenc);
        emit_d8(cbuf, disp);
      } else {
        // If 32-bit displacement
        if (base == 0x04 ) {
          emit_rm(cbuf, 0x2, regenc, 0x4);
          emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
        } else {
          emit_rm(cbuf, 0x2, regenc, 0x4);
          emit_rm(cbuf, scale, indexenc, baseenc); // *
        }
        if (disp_is_oop) {
          emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
        } else {
          emit_d32(cbuf, disp);
        }
      }
    }
  }
}

void encode_copy(CodeBuffer &cbuf, int dstenc, int srcenc)
{
  if (dstenc != srcenc) {
    if (dstenc < 8) {
      if (srcenc >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
        srcenc -= 8;
      }
    } else {
      if (srcenc < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
        srcenc -= 8;
      }
      dstenc -= 8;
    }

    emit_opcode(cbuf, 0x8B);
    emit_rm(cbuf, 0x3, dstenc, srcenc);
  }
}

void encode_CopyXD( CodeBuffer &cbuf, int dst_encoding, int src_encoding ) {
  if( dst_encoding == src_encoding ) {
    // reg-reg copy, use an empty encoding
  } else {
    MacroAssembler _masm(&cbuf);

    __ movdqa(as_XMMRegister(dst_encoding), as_XMMRegister(src_encoding));
  }
}

// This could be in MacroAssembler but it's fairly C2 specific
void emit_cmpfp_fixup(MacroAssembler& _masm) {
  Label exit;
  __ jccb(Assembler::noParity, exit);
  __ pushf();
  __ andq(Address(rsp, 0), 0xffffff2b);
  __ popf();
  __ bind(exit);
  __ nop(); // (target for branch to avoid branch to branch)
}


//=============================================================================
const bool Matcher::constant_table_absolute_addressing = true;
const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::Empty;

void MachConstantBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  // Empty encoding
}

uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  return 0;
}

#ifndef PRODUCT
void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  st->print("# MachConstantBaseNode (empty encoding)");
}
#endif


//=============================================================================
#ifndef PRODUCT
void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const
{
  Compile* C = ra_->C;

  int framesize = C->frame_slots() << LogBytesPerInt;
  assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
  // Remove wordSize for return adr already pushed
  // and another for the RBP we are going to save
  framesize -= 2*wordSize;
  bool need_nop = true;

  // Calls to C2R adapters often do not accept exceptional returns.
  // We require that their callers must bang for them.  But be
  // careful, because some VM calls (such as call site linkage) can
  // use several kilobytes of stack.  But the stack safety zone should
  // account for that.  See bugs 4446381, 4468289, 4497237.
  if (C->need_stack_bang(framesize)) {
    st->print_cr("# stack bang"); st->print("\t");
    need_nop = false;
  }
  st->print_cr("pushq   rbp"); st->print("\t");

  if (VerifyStackAtCalls) {
    // Majik cookie to verify stack depth
    st->print_cr("pushq   0xffffffffbadb100d"
                  "\t# Majik cookie for stack depth check");
    st->print("\t");
    framesize -= wordSize; // Remove 2 for cookie
    need_nop = false;
  }

  if (framesize) {
    st->print("subq    rsp, #%d\t# Create frame", framesize);
    if (framesize < 0x80 && need_nop) {
      st->print("\n\tnop\t# nop for patch_verified_entry");
    }
  }
}
#endif

void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const
{
  Compile* C = ra_->C;

  // WARNING: Initial instruction MUST be 5 bytes or longer so that
  // NativeJump::patch_verified_entry will be able to patch out the entry
  // code safely. The fldcw is ok at 6 bytes, the push to verify stack
  // depth is ok at 5 bytes, the frame allocation can be either 3 or
  // 6 bytes. So if we don't do the fldcw or the push then we must
  // use the 6 byte frame allocation even if we have no frame. :-(
  // If method sets FPU control word do it now

  int framesize = C->frame_slots() << LogBytesPerInt;
  assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
  // Remove wordSize for return adr already pushed
  // and another for the RBP we are going to save
  framesize -= 2*wordSize;
  bool need_nop = true;

  // Calls to C2R adapters often do not accept exceptional returns.
  // We require that their callers must bang for them.  But be
  // careful, because some VM calls (such as call site linkage) can
  // use several kilobytes of stack.  But the stack safety zone should
  // account for that.  See bugs 4446381, 4468289, 4497237.
  if (C->need_stack_bang(framesize)) {
    MacroAssembler masm(&cbuf);
    masm.generate_stack_overflow_check(framesize);
    need_nop = false;
  }

  // We always push rbp so that on return to interpreter rbp will be
  // restored correctly and we can correct the stack.
  emit_opcode(cbuf, 0x50 | RBP_enc);

  if (VerifyStackAtCalls) {
    // Majik cookie to verify stack depth
    emit_opcode(cbuf, 0x68); // pushq (sign-extended) 0xbadb100d
    emit_d32(cbuf, 0xbadb100d);
    framesize -= wordSize; // Remove 2 for cookie
    need_nop = false;
  }

  if (framesize) {
    emit_opcode(cbuf, Assembler::REX_W);
    if (framesize < 0x80) {
      emit_opcode(cbuf, 0x83);   // sub  SP,#framesize
      emit_rm(cbuf, 0x3, 0x05, RSP_enc);
      emit_d8(cbuf, framesize);
      if (need_nop) {
        emit_opcode(cbuf, 0x90); // nop
      }
    } else {
      emit_opcode(cbuf, 0x81);   // sub  SP,#framesize
      emit_rm(cbuf, 0x3, 0x05, RSP_enc);
      emit_d32(cbuf, framesize);
    }
  }

  C->set_frame_complete(cbuf.insts_size());

#ifdef ASSERT
  if (VerifyStackAtCalls) {
    Label L;
    MacroAssembler masm(&cbuf);
    masm.push(rax);
    masm.mov(rax, rsp);
    masm.andptr(rax, StackAlignmentInBytes-1);
    masm.cmpptr(rax, StackAlignmentInBytes-wordSize);
    masm.pop(rax);
    masm.jcc(Assembler::equal, L);
    masm.stop("Stack is not properly aligned!");
    masm.bind(L);
  }
#endif
}

uint MachPrologNode::size(PhaseRegAlloc* ra_) const
{
  return MachNode::size(ra_); // too many variables; just compute it
                              // the hard way
}

int MachPrologNode::reloc() const
{
  return 0; // a large enough number
}

//=============================================================================
#ifndef PRODUCT
void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
{
  Compile* C = ra_->C;
  int framesize = C->frame_slots() << LogBytesPerInt;
  assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
  // Remove word for return adr already pushed
  // and RBP
  framesize -= 2*wordSize;

  if (framesize) {
    st->print_cr("addq    rsp, %d\t# Destroy frame", framesize);
    st->print("\t");
  }

  st->print_cr("popq   rbp");
  if (do_polling() && C->is_method_compilation()) {
    st->print("\t");
    if (Assembler::is_polling_page_far()) {
      st->print_cr("movq   rscratch1, #polling_page_address\n\t"
                   "testl  rax, [rscratch1]\t"
                   "# Safepoint: poll for GC");
    } else {
      st->print_cr("testl  rax, [rip + #offset_to_poll_page]\t"
                   "# Safepoint: poll for GC");
    }
  }
}
#endif

void MachEpilogNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const
{
  Compile* C = ra_->C;
  int framesize = C->frame_slots() << LogBytesPerInt;
  assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
  // Remove word for return adr already pushed
  // and RBP
  framesize -= 2*wordSize;

  // Note that VerifyStackAtCalls' Majik cookie does not change the frame size popped here

  if (framesize) {
    emit_opcode(cbuf, Assembler::REX_W);
    if (framesize < 0x80) {
      emit_opcode(cbuf, 0x83); // addq rsp, #framesize
      emit_rm(cbuf, 0x3, 0x00, RSP_enc);
      emit_d8(cbuf, framesize);
    } else {
      emit_opcode(cbuf, 0x81); // addq rsp, #framesize
      emit_rm(cbuf, 0x3, 0x00, RSP_enc);
      emit_d32(cbuf, framesize);
    }
  }

  // popq rbp
  emit_opcode(cbuf, 0x58 | RBP_enc);

  if (do_polling() && C->is_method_compilation()) {
    MacroAssembler _masm(&cbuf);
    AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
    if (Assembler::is_polling_page_far()) {
      __ lea(rscratch1, polling_page);
      __ relocate(relocInfo::poll_return_type);
      __ testl(rax, Address(rscratch1, 0));
    } else {
      __ testl(rax, polling_page);
    }
  }
}

uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
{
  return MachNode::size(ra_); // too many variables; just compute it
                              // the hard way
}

int MachEpilogNode::reloc() const
{
  return 2; // a large enough number
}

const Pipeline* MachEpilogNode::pipeline() const
{
  return MachNode::pipeline_class();
}

int MachEpilogNode::safepoint_offset() const
{
  return 0;
}

//=============================================================================

enum RC {
  rc_bad,
  rc_int,
  rc_float,
  rc_stack
};

static enum RC rc_class(OptoReg::Name reg)
{
  if( !OptoReg::is_valid(reg)  ) return rc_bad;

  if (OptoReg::is_stack(reg)) return rc_stack;

  VMReg r = OptoReg::as_VMReg(reg);

  if (r->is_Register()) return rc_int;

  assert(r->is_XMMRegister(), "must be");
  return rc_float;
}

uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
                                       PhaseRegAlloc* ra_,
                                       bool do_size,
                                       outputStream* st) const
{

  // Get registers to move
  OptoReg::Name src_second = ra_->get_reg_second(in(1));
  OptoReg::Name src_first = ra_->get_reg_first(in(1));
  OptoReg::Name dst_second = ra_->get_reg_second(this);
  OptoReg::Name dst_first = ra_->get_reg_first(this);

  enum RC src_second_rc = rc_class(src_second);
  enum RC src_first_rc = rc_class(src_first);
  enum RC dst_second_rc = rc_class(dst_second);
  enum RC dst_first_rc = rc_class(dst_first);

  assert(OptoReg::is_valid(src_first) && OptoReg::is_valid(dst_first),
         "must move at least 1 register" );

  if (src_first == dst_first && src_second == dst_second) {
    // Self copy, no move
    return 0;
  } else if (src_first_rc == rc_stack) {
    // mem ->
    if (dst_first_rc == rc_stack) {
      // mem -> mem
      assert(src_second != dst_first, "overlap");
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        int src_offset = ra_->reg2offset(src_first);
        int dst_offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          emit_opcode(*cbuf, 0xFF);
          encode_RegMem(*cbuf, RSI_enc, RSP_enc, 0x4, 0, src_offset, false);

          emit_opcode(*cbuf, 0x8F);
          encode_RegMem(*cbuf, RAX_enc, RSP_enc, 0x4, 0, dst_offset, false);

#ifndef PRODUCT
        } else if (!do_size) {
          st->print("pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t"
                     "popq    [rsp + #%d]",
                     src_offset,
                     dst_offset);
#endif
        }
        return
          3 + ((src_offset == 0) ? 0 : (src_offset < 0x80 ? 1 : 4)) +
          3 + ((dst_offset == 0) ? 0 : (dst_offset < 0x80 ? 1 : 4));
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        // No pushl/popl, so:
        int src_offset = ra_->reg2offset(src_first);
        int dst_offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          emit_opcode(*cbuf, Assembler::REX_W);
          emit_opcode(*cbuf, 0x89);
          emit_opcode(*cbuf, 0x44);
          emit_opcode(*cbuf, 0x24);
          emit_opcode(*cbuf, 0xF8);

          emit_opcode(*cbuf, 0x8B);
          encode_RegMem(*cbuf,
                        RAX_enc,
                        RSP_enc, 0x4, 0, src_offset,
                        false);

          emit_opcode(*cbuf, 0x89);
          encode_RegMem(*cbuf,
                        RAX_enc,
                        RSP_enc, 0x4, 0, dst_offset,
                        false);

          emit_opcode(*cbuf, Assembler::REX_W);
          emit_opcode(*cbuf, 0x8B);
          emit_opcode(*cbuf, 0x44);
          emit_opcode(*cbuf, 0x24);
          emit_opcode(*cbuf, 0xF8);

#ifndef PRODUCT
        } else if (!do_size) {
          st->print("movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t"
                     "movl    rax, [rsp + #%d]\n\t"
                     "movl    [rsp + #%d], rax\n\t"
                     "movq    rax, [rsp - #8]",
                     src_offset,
                     dst_offset);
#endif
        }
        return
          5 + // movq
          3 + ((src_offset == 0) ? 0 : (src_offset < 0x80 ? 1 : 4)) + // movl
          3 + ((dst_offset == 0) ? 0 : (dst_offset < 0x80 ? 1 : 4)) + // movl
          5; // movq
      }
    } else if (dst_first_rc == rc_int) {
      // mem -> gpr
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        int offset = ra_->reg2offset(src_first);
        if (cbuf) {
          if (Matcher::_regEncode[dst_first] < 8) {
            emit_opcode(*cbuf, Assembler::REX_W);
          } else {
            emit_opcode(*cbuf, Assembler::REX_WR);
          }
          emit_opcode(*cbuf, 0x8B);
          encode_RegMem(*cbuf,
                        Matcher::_regEncode[dst_first],
                        RSP_enc, 0x4, 0, offset,
                        false);
#ifndef PRODUCT
        } else if (!do_size) {
          st->print("movq    %s, [rsp + #%d]\t# spill",
                     Matcher::regName[dst_first],
                     offset);
#endif
        }
        return
          ((offset == 0) ? 0 : (offset < 0x80 ? 1 : 4)) + 4; // REX
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        int offset = ra_->reg2offset(src_first);
        if (cbuf) {
          if (Matcher::_regEncode[dst_first] >= 8) {
            emit_opcode(*cbuf, Assembler::REX_R);
          }
          emit_opcode(*cbuf, 0x8B);
          encode_RegMem(*cbuf,
                        Matcher::_regEncode[dst_first],
                        RSP_enc, 0x4, 0, offset,
                        false);
#ifndef PRODUCT
        } else if (!do_size) {
          st->print("movl    %s, [rsp + #%d]\t# spill",
                     Matcher::regName[dst_first],
                     offset);
#endif
        }
        return
          ((offset == 0) ? 0 : (offset < 0x80 ? 1 : 4)) +
          ((Matcher::_regEncode[dst_first] < 8)
           ? 3
           : 4); // REX
      }
    } else if (dst_first_rc == rc_float) {
      // mem-> xmm
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        int offset = ra_->reg2offset(src_first);
        if (cbuf) {
          emit_opcode(*cbuf, UseXmmLoadAndClearUpper ? 0xF2 : 0x66);
          if (Matcher::_regEncode[dst_first] >= 8) {
            emit_opcode(*cbuf, Assembler::REX_R);
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, UseXmmLoadAndClearUpper ? 0x10 : 0x12);
          encode_RegMem(*cbuf,
                        Matcher::_regEncode[dst_first],
                        RSP_enc, 0x4, 0, offset,
                        false);
#ifndef PRODUCT
        } else if (!do_size) {
          st->print("%s  %s, [rsp + #%d]\t# spill",
                     UseXmmLoadAndClearUpper ? "movsd " : "movlpd",
                     Matcher::regName[dst_first],
                     offset);
#endif
        }
        return
          ((offset == 0) ? 0 : (offset < 0x80 ? 1 : 4)) +
          ((Matcher::_regEncode[dst_first] < 8)
           ? 5
           : 6); // REX
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        int offset = ra_->reg2offset(src_first);
        if (cbuf) {
          emit_opcode(*cbuf, 0xF3);
          if (Matcher::_regEncode[dst_first] >= 8) {
            emit_opcode(*cbuf, Assembler::REX_R);
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x10);
          encode_RegMem(*cbuf,
                        Matcher::_regEncode[dst_first],
                        RSP_enc, 0x4, 0, offset,
                        false);
#ifndef PRODUCT
        } else if (!do_size) {
          st->print("movss   %s, [rsp + #%d]\t# spill",
                     Matcher::regName[dst_first],
                     offset);
#endif
        }
        return
          ((offset == 0) ? 0 : (offset < 0x80 ? 1 : 4)) +
          ((Matcher::_regEncode[dst_first] < 8)
           ? 5
           : 6); // REX
      }
    }
  } else if (src_first_rc == rc_int) {
    // gpr ->
    if (dst_first_rc == rc_stack) {
      // gpr -> mem
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        int offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          if (Matcher::_regEncode[src_first] < 8) {
            emit_opcode(*cbuf, Assembler::REX_W);
          } else {
            emit_opcode(*cbuf, Assembler::REX_WR);
          }
          emit_opcode(*cbuf, 0x89);
          encode_RegMem(*cbuf,
                        Matcher::_regEncode[src_first],
                        RSP_enc, 0x4, 0, offset,
                        false);
#ifndef PRODUCT
        } else if (!do_size) {
          st->print("movq    [rsp + #%d], %s\t# spill",
                     offset,
                     Matcher::regName[src_first]);
#endif
        }
        return ((offset == 0) ? 0 : (offset < 0x80 ? 1 : 4)) + 4; // REX
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        int offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          if (Matcher::_regEncode[src_first] >= 8) {
            emit_opcode(*cbuf, Assembler::REX_R);
          }
          emit_opcode(*cbuf, 0x89);
          encode_RegMem(*cbuf,
                        Matcher::_regEncode[src_first],
                        RSP_enc, 0x4, 0, offset,
                        false);
#ifndef PRODUCT
        } else if (!do_size) {
          st->print("movl    [rsp + #%d], %s\t# spill",
                     offset,
                     Matcher::regName[src_first]);
#endif
        }
        return
          ((offset == 0) ? 0 : (offset < 0x80 ? 1 : 4)) +
          ((Matcher::_regEncode[src_first] < 8)
           ? 3
           : 4); // REX
      }
    } else if (dst_first_rc == rc_int) {
      // gpr -> gpr
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        if (cbuf) {
          if (Matcher::_regEncode[dst_first] < 8) {
            if (Matcher::_regEncode[src_first] < 8) {
              emit_opcode(*cbuf, Assembler::REX_W);
            } else {
              emit_opcode(*cbuf, Assembler::REX_WB);
            }
          } else {
            if (Matcher::_regEncode[src_first] < 8) {
              emit_opcode(*cbuf, Assembler::REX_WR);
            } else {
              emit_opcode(*cbuf, Assembler::REX_WRB);
            }
          }
          emit_opcode(*cbuf, 0x8B);
          emit_rm(*cbuf, 0x3,
                  Matcher::_regEncode[dst_first] & 7,
                  Matcher::_regEncode[src_first] & 7);
#ifndef PRODUCT
        } else if (!do_size) {
          st->print("movq    %s, %s\t# spill",
                     Matcher::regName[dst_first],
                     Matcher::regName[src_first]);
#endif
        }
        return 3; // REX
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        if (cbuf) {
          if (Matcher::_regEncode[dst_first] < 8) {
            if (Matcher::_regEncode[src_first] >= 8) {
              emit_opcode(*cbuf, Assembler::REX_B);
            }
          } else {
            if (Matcher::_regEncode[src_first] < 8) {
              emit_opcode(*cbuf, Assembler::REX_R);
            } else {
              emit_opcode(*cbuf, Assembler::REX_RB);
            }
          }
          emit_opcode(*cbuf, 0x8B);
          emit_rm(*cbuf, 0x3,
                  Matcher::_regEncode[dst_first] & 7,
                  Matcher::_regEncode[src_first] & 7);
#ifndef PRODUCT
        } else if (!do_size) {
          st->print("movl    %s, %s\t# spill",
                     Matcher::regName[dst_first],
                     Matcher::regName[src_first]);
#endif
        }
        return
          (Matcher::_regEncode[src_first] < 8 && Matcher::_regEncode[dst_first] < 8)
          ? 2
          : 3; // REX
      }
    } else if (dst_first_rc == rc_float) {
      // gpr -> xmm
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        if (cbuf) {
          emit_opcode(*cbuf, 0x66);
          if (Matcher::_regEncode[dst_first] < 8) {
            if (Matcher::_regEncode[src_first] < 8) {
              emit_opcode(*cbuf, Assembler::REX_W);
            } else {
              emit_opcode(*cbuf, Assembler::REX_WB);
            }
          } else {
            if (Matcher::_regEncode[src_first] < 8) {
              emit_opcode(*cbuf, Assembler::REX_WR);
            } else {
              emit_opcode(*cbuf, Assembler::REX_WRB);
            }
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x6E);
          emit_rm(*cbuf, 0x3,
                  Matcher::_regEncode[dst_first] & 7,
                  Matcher::_regEncode[src_first] & 7);
#ifndef PRODUCT
        } else if (!do_size) {
          st->print("movdq   %s, %s\t# spill",
                     Matcher::regName[dst_first],
                     Matcher::regName[src_first]);
#endif
        }
        return 5; // REX
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        if (cbuf) {
          emit_opcode(*cbuf, 0x66);
          if (Matcher::_regEncode[dst_first] < 8) {
            if (Matcher::_regEncode[src_first] >= 8) {
              emit_opcode(*cbuf, Assembler::REX_B);
            }
          } else {
            if (Matcher::_regEncode[src_first] < 8) {
              emit_opcode(*cbuf, Assembler::REX_R);
            } else {
              emit_opcode(*cbuf, Assembler::REX_RB);
            }
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x6E);
          emit_rm(*cbuf, 0x3,
                  Matcher::_regEncode[dst_first] & 7,
                  Matcher::_regEncode[src_first] & 7);
#ifndef PRODUCT
        } else if (!do_size) {
          st->print("movdl   %s, %s\t# spill",
                     Matcher::regName[dst_first],
                     Matcher::regName[src_first]);
#endif
        }
        return
          (Matcher::_regEncode[src_first] < 8 && Matcher::_regEncode[dst_first] < 8)
          ? 4
          : 5; // REX
      }
    }
  } else if (src_first_rc == rc_float) {
    // xmm ->
    if (dst_first_rc == rc_stack) {
      // xmm -> mem
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        int offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          emit_opcode(*cbuf, 0xF2);
          if (Matcher::_regEncode[src_first] >= 8) {
              emit_opcode(*cbuf, Assembler::REX_R);
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x11);
          encode_RegMem(*cbuf,
                        Matcher::_regEncode[src_first],
                        RSP_enc, 0x4, 0, offset,
                        false);
#ifndef PRODUCT
        } else if (!do_size) {
          st->print("movsd   [rsp + #%d], %s\t# spill",
                     offset,
                     Matcher::regName[src_first]);
#endif
        }
        return
          ((offset == 0) ? 0 : (offset < 0x80 ? 1 : 4)) +
          ((Matcher::_regEncode[src_first] < 8)
           ? 5
           : 6); // REX
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        int offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          emit_opcode(*cbuf, 0xF3);
          if (Matcher::_regEncode[src_first] >= 8) {
              emit_opcode(*cbuf, Assembler::REX_R);
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x11);
          encode_RegMem(*cbuf,
                        Matcher::_regEncode[src_first],
                        RSP_enc, 0x4, 0, offset,
                        false);
#ifndef PRODUCT
        } else if (!do_size) {
          st->print("movss   [rsp + #%d], %s\t# spill",
                     offset,
                     Matcher::regName[src_first]);
#endif
        }
        return
          ((offset == 0) ? 0 : (offset < 0x80 ? 1 : 4)) +
          ((Matcher::_regEncode[src_first] < 8)
           ? 5
           : 6); // REX
      }
    } else if (dst_first_rc == rc_int) {
      // xmm -> gpr
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        if (cbuf) {
          emit_opcode(*cbuf, 0x66);
          if (Matcher::_regEncode[dst_first] < 8) {
            if (Matcher::_regEncode[src_first] < 8) {
              emit_opcode(*cbuf, Assembler::REX_W);
            } else {
              emit_opcode(*cbuf, Assembler::REX_WR); // attention!
            }
          } else {
            if (Matcher::_regEncode[src_first] < 8) {
              emit_opcode(*cbuf, Assembler::REX_WB); // attention!
            } else {
              emit_opcode(*cbuf, Assembler::REX_WRB);
            }
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x7E);
          emit_rm(*cbuf, 0x3,
                  Matcher::_regEncode[src_first] & 7,
                  Matcher::_regEncode[dst_first] & 7);
#ifndef PRODUCT
        } else if (!do_size) {
          st->print("movdq   %s, %s\t# spill",
                     Matcher::regName[dst_first],
                     Matcher::regName[src_first]);
#endif
        }
        return 5; // REX
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        if (cbuf) {
          emit_opcode(*cbuf, 0x66);
          if (Matcher::_regEncode[dst_first] < 8) {
            if (Matcher::_regEncode[src_first] >= 8) {
              emit_opcode(*cbuf, Assembler::REX_R); // attention!
            }
          } else {
            if (Matcher::_regEncode[src_first] < 8) {
              emit_opcode(*cbuf, Assembler::REX_B); // attention!
            } else {
              emit_opcode(*cbuf, Assembler::REX_RB);
            }
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x7E);
          emit_rm(*cbuf, 0x3,
                  Matcher::_regEncode[src_first] & 7,
                  Matcher::_regEncode[dst_first] & 7);
#ifndef PRODUCT
        } else if (!do_size) {
          st->print("movdl   %s, %s\t# spill",
                     Matcher::regName[dst_first],
                     Matcher::regName[src_first]);
#endif
        }
        return
          (Matcher::_regEncode[src_first] < 8 && Matcher::_regEncode[dst_first] < 8)
          ? 4
          : 5; // REX
      }
    } else if (dst_first_rc == rc_float) {
      // xmm -> xmm
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        if (cbuf) {
          emit_opcode(*cbuf, UseXmmRegToRegMoveAll ? 0x66 : 0xF2);
          if (Matcher::_regEncode[dst_first] < 8) {
            if (Matcher::_regEncode[src_first] >= 8) {
              emit_opcode(*cbuf, Assembler::REX_B);
            }
          } else {
            if (Matcher::_regEncode[src_first] < 8) {
              emit_opcode(*cbuf, Assembler::REX_R);
            } else {
              emit_opcode(*cbuf, Assembler::REX_RB);
            }
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, UseXmmRegToRegMoveAll ? 0x28 : 0x10);
          emit_rm(*cbuf, 0x3,
                  Matcher::_regEncode[dst_first] & 7,
                  Matcher::_regEncode[src_first] & 7);
#ifndef PRODUCT
        } else if (!do_size) {
          st->print("%s  %s, %s\t# spill",
                     UseXmmRegToRegMoveAll ? "movapd" : "movsd ",
                     Matcher::regName[dst_first],
                     Matcher::regName[src_first]);
#endif
        }
        return
          (Matcher::_regEncode[src_first] < 8 && Matcher::_regEncode[dst_first] < 8)
          ? 4
          : 5; // REX
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        if (cbuf) {
          if (!UseXmmRegToRegMoveAll)
            emit_opcode(*cbuf, 0xF3);
          if (Matcher::_regEncode[dst_first] < 8) {
            if (Matcher::_regEncode[src_first] >= 8) {
              emit_opcode(*cbuf, Assembler::REX_B);
            }
          } else {
            if (Matcher::_regEncode[src_first] < 8) {
              emit_opcode(*cbuf, Assembler::REX_R);
            } else {
              emit_opcode(*cbuf, Assembler::REX_RB);
            }
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, UseXmmRegToRegMoveAll ? 0x28 : 0x10);
          emit_rm(*cbuf, 0x3,
                  Matcher::_regEncode[dst_first] & 7,
                  Matcher::_regEncode[src_first] & 7);
#ifndef PRODUCT
        } else if (!do_size) {
          st->print("%s  %s, %s\t# spill",
                     UseXmmRegToRegMoveAll ? "movaps" : "movss ",
                     Matcher::regName[dst_first],
                     Matcher::regName[src_first]);
#endif
        }
        return
          (Matcher::_regEncode[src_first] < 8 && Matcher::_regEncode[dst_first] < 8)
          ? (UseXmmRegToRegMoveAll ? 3 : 4)
          : (UseXmmRegToRegMoveAll ? 4 : 5); // REX
      }
    }
  }

  assert(0," foo ");
  Unimplemented();

  return 0;
}

#ifndef PRODUCT
void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const
{
  implementation(NULL, ra_, false, st);
}
#endif

void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const
{
  implementation(&cbuf, ra_, false, NULL);
}

uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const
{
  return implementation(NULL, ra_, true, NULL);
}

//=============================================================================
#ifndef PRODUCT
void MachNopNode::format(PhaseRegAlloc*, outputStream* st) const
{
  st->print("nop \t# %d bytes pad for loops and calls", _count);
}
#endif

void MachNopNode::emit(CodeBuffer &cbuf, PhaseRegAlloc*) const
{
  MacroAssembler _masm(&cbuf);
  __ nop(_count);
}

uint MachNopNode::size(PhaseRegAlloc*) const
{
  return _count;
}


//=============================================================================
#ifndef PRODUCT
void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
{
  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());
  int reg = ra_->get_reg_first(this);
  st->print("leaq    %s, [rsp + #%d]\t# box lock",
            Matcher::regName[reg], offset);
}
#endif

void BoxLockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const
{
  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());
  int reg = ra_->get_encode(this);
  if (offset >= 0x80) {
    emit_opcode(cbuf, reg < 8 ? Assembler::REX_W : Assembler::REX_WR);
    emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
    emit_rm(cbuf, 0x2, reg & 7, 0x04);
    emit_rm(cbuf, 0x0, 0x04, RSP_enc);
    emit_d32(cbuf, offset);
  } else {
    emit_opcode(cbuf, reg < 8 ? Assembler::REX_W : Assembler::REX_WR);
    emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
    emit_rm(cbuf, 0x1, reg & 7, 0x04);
    emit_rm(cbuf, 0x0, 0x04, RSP_enc);
    emit_d8(cbuf, offset);
  }
}

uint BoxLockNode::size(PhaseRegAlloc *ra_) const
{
  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());
  return (offset < 0x80) ? 5 : 8; // REX
}

//=============================================================================

// emit call stub, compiled java to interpreter
void emit_java_to_interp(CodeBuffer& cbuf)
{
  // Stub is fixed up when the corresponding call is converted from
  // calling compiled code to calling interpreted code.
  // movq rbx, 0
  // jmp -5 # to self

  address mark = cbuf.insts_mark();  // get mark within main instrs section

  // Note that the code buffer's insts_mark is always relative to insts.
  // That's why we must use the macroassembler to generate a stub.
  MacroAssembler _masm(&cbuf);

  address base =
  __ start_a_stub(Compile::MAX_stubs_size);
  if (base == NULL)  return;  // CodeBuffer::expand failed
  // static stub relocation stores the instruction address of the call
  __ relocate(static_stub_Relocation::spec(mark), RELOC_IMM64);
  // static stub relocation also tags the methodOop in the code-stream.
  __ movoop(rbx, (jobject) NULL);  // method is zapped till fixup time
  // This is recognized as unresolved by relocs/nativeinst/ic code
  __ jump(RuntimeAddress(__ pc()));

  // Update current stubs pointer and restore insts_end.
  __ end_a_stub();
}

// size of call stub, compiled java to interpretor
uint size_java_to_interp()
{
  return 15;  // movq (1+1+8); jmp (1+4)
}

// relocation entries for call stub, compiled java to interpretor
uint reloc_java_to_interp()
{
  return 4; // 3 in emit_java_to_interp + 1 in Java_Static_Call
}

//=============================================================================
#ifndef PRODUCT
void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
{
  if (UseCompressedOops) {
    st->print_cr("movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass");
    if (Universe::narrow_oop_shift() != 0) {
      st->print_cr("\tdecode_heap_oop_not_null rscratch1, rscratch1");
    }
    st->print_cr("\tcmpq    rax, rscratch1\t # Inline cache check");
  } else {
    st->print_cr("\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t"
                 "# Inline cache check");
  }
  st->print_cr("\tjne     SharedRuntime::_ic_miss_stub");
  st->print_cr("\tnop\t# nops to align entry point");
}
#endif

void MachUEPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const
{
  MacroAssembler masm(&cbuf);
  uint insts_size = cbuf.insts_size();
  if (UseCompressedOops) {
    masm.load_klass(rscratch1, j_rarg0);
    masm.cmpptr(rax, rscratch1);
  } else {
    masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
  }

  masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));

  /* WARNING these NOPs are critical so that verified entry point is properly
     4 bytes aligned for patching by NativeJump::patch_verified_entry() */
  int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) & 0x3);
  if (OptoBreakpoint) {
    // Leave space for int3
    nops_cnt -= 1;
  }
  nops_cnt &= 0x3; // Do not add nops if code is aligned.
  if (nops_cnt > 0)
    masm.nop(nops_cnt);
}

uint MachUEPNode::size(PhaseRegAlloc* ra_) const
{
  return MachNode::size(ra_); // too many variables; just compute it
                              // the hard way
}


//=============================================================================
uint size_exception_handler()
{
  // NativeCall instruction size is the same as NativeJump.
  // Note that this value is also credited (in output.cpp) to
  // the size of the code section.
  return NativeJump::instruction_size;
}

// Emit exception handler code.
int emit_exception_handler(CodeBuffer& cbuf)
{

  // Note that the code buffer's insts_mark is always relative to insts.
  // That's why we must use the macroassembler to generate a handler.
  MacroAssembler _masm(&cbuf);
  address base =
  __ start_a_stub(size_exception_handler());
  if (base == NULL)  return 0;  // CodeBuffer::expand failed
  int offset = __ offset();
  __ jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));
  assert(__ offset() - offset <= (int) size_exception_handler(), "overflow");
  __ end_a_stub();
  return offset;
}

uint size_deopt_handler()
{
  // three 5 byte instructions
  return 15;
}

// Emit deopt handler code.
int emit_deopt_handler(CodeBuffer& cbuf)
{

  // Note that the code buffer's insts_mark is always relative to insts.
  // That's why we must use the macroassembler to generate a handler.
  MacroAssembler _masm(&cbuf);
  address base =
  __ start_a_stub(size_deopt_handler());
  if (base == NULL)  return 0;  // CodeBuffer::expand failed
  int offset = __ offset();
  address the_pc = (address) __ pc();
  Label next;
  // push a "the_pc" on the stack without destroying any registers
  // as they all may be live.

  // push address of "next"
  __ call(next, relocInfo::none); // reloc none is fine since it is a disp32
  __ bind(next);
  // adjust it so it matches "the_pc"
  __ subptr(Address(rsp, 0), __ offset() - offset);
  __ jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));
  assert(__ offset() - offset <= (int) size_deopt_handler(), "overflow");
  __ end_a_stub();
  return offset;
}


const bool Matcher::match_rule_supported(int opcode) {
  if (!has_match_rule(opcode))
    return false;

  return true;  // Per default match rules are supported.
}

int Matcher::regnum_to_fpu_offset(int regnum)
{
  return regnum - 32; // The FP registers are in the second chunk
}

// This is UltraSparc specific, true just means we have fast l2f conversion
const bool Matcher::convL2FSupported(void) {
  return true;
}

// Vector width in bytes
const uint Matcher::vector_width_in_bytes(void) {
  return 8;
}

// Vector ideal reg
const uint Matcher::vector_ideal_reg(void) {
  return Op_RegD;
}

// Is this branch offset short enough that a short branch can be used?
//
// NOTE: If the platform does not provide any short branch variants, then
//       this method should return false for offset 0.
bool Matcher::is_short_branch_offset(int rule, int offset) {
  // the short version of jmpConUCF2 contains multiple branches,
  // making the reach slightly less
  if (rule == jmpConUCF2_rule)
    return (-126 <= offset && offset <= 125);
  return (-128 <= offset && offset <= 127);
}

const bool Matcher::isSimpleConstant64(jlong value) {
  // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
  //return value == (int) value;  // Cf. storeImmL and immL32.

  // Probably always true, even if a temp register is required.
  return true;
}

// The ecx parameter to rep stosq for the ClearArray node is in words.
const bool Matcher::init_array_count_is_in_bytes = false;

// Threshold size for cleararray.
const int Matcher::init_array_short_size = 8 * BytesPerLong;

// Should the Matcher clone shifts on addressing modes, expecting them
// to be subsumed into complex addressing expressions or compute them
// into registers?  True for Intel but false for most RISCs
const bool Matcher::clone_shift_expressions = true;

// Do we need to mask the count passed to shift instructions or does
// the cpu only look at the lower 5/6 bits anyway?
const bool Matcher::need_masked_shift_count = false;

bool Matcher::narrow_oop_use_complex_address() {
  assert(UseCompressedOops, "only for compressed oops code");
  return (LogMinObjAlignmentInBytes <= 3);
}

// Is it better to copy float constants, or load them directly from
// memory?  Intel can load a float constant from a direct address,
// requiring no extra registers.  Most RISCs will have to materialize
// an address into a register first, so they would do better to copy
// the constant from stack.
const bool Matcher::rematerialize_float_constants = true; // XXX

// If CPU can load and store mis-aligned doubles directly then no
// fixup is needed.  Else we split the double into 2 integer pieces
// and move it piece-by-piece.  Only happens when passing doubles into
// C code as the Java calling convention forces doubles to be aligned.
const bool Matcher::misaligned_doubles_ok = true;

// No-op on amd64
void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}

// Advertise here if the CPU requires explicit rounding operations to
// implement the UseStrictFP mode.
const bool Matcher::strict_fp_requires_explicit_rounding = true;

// Are floats conerted to double when stored to stack during deoptimization?
// On x64 it is stored without convertion so we can use normal access.
bool Matcher::float_in_double() { return false; }

// Do ints take an entire long register or just half?
const bool Matcher::int_in_long = true;

// Return whether or not this register is ever used as an argument.
// This function is used on startup to build the trampoline stubs in
// generateOptoStub.  Registers not mentioned will be killed by the VM
// call in the trampoline, and arguments in those registers not be
// available to the callee.
bool Matcher::can_be_java_arg(int reg)
{
  return
    reg ==  RDI_num || reg ==  RDI_H_num ||
    reg ==  RSI_num || reg ==  RSI_H_num ||
    reg ==  RDX_num || reg ==  RDX_H_num ||
    reg ==  RCX_num || reg ==  RCX_H_num ||
    reg ==   R8_num || reg ==   R8_H_num ||
    reg ==   R9_num || reg ==   R9_H_num ||
    reg ==  R12_num || reg ==  R12_H_num ||
    reg == XMM0_num || reg == XMM0_H_num ||
    reg == XMM1_num || reg == XMM1_H_num ||
    reg == XMM2_num || reg == XMM2_H_num ||
    reg == XMM3_num || reg == XMM3_H_num ||
    reg == XMM4_num || reg == XMM4_H_num ||
    reg == XMM5_num || reg == XMM5_H_num ||
    reg == XMM6_num || reg == XMM6_H_num ||
    reg == XMM7_num || reg == XMM7_H_num;
}

bool Matcher::is_spillable_arg(int reg)
{
  return can_be_java_arg(reg);
}

bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
  // In 64 bit mode a code which use multiply when
  // devisor is constant is faster than hardware
  // DIV instruction (it uses MulHiL).
  return false;
}

// Register for DIVI projection of divmodI
RegMask Matcher::divI_proj_mask() {
  return INT_RAX_REG_mask;
}

// Register for MODI projection of divmodI
RegMask Matcher::modI_proj_mask() {
  return INT_RDX_REG_mask;
}

// Register for DIVL projection of divmodL
RegMask Matcher::divL_proj_mask() {
  return LONG_RAX_REG_mask;
}

// Register for MODL projection of divmodL
RegMask Matcher::modL_proj_mask() {
  return LONG_RDX_REG_mask;
}

const RegMask Matcher::method_handle_invoke_SP_save_mask() {
  return PTR_RBP_REG_mask;
}

static Address build_address(int b, int i, int s, int d) {
  Register index = as_Register(i);
  Address::ScaleFactor scale = (Address::ScaleFactor)s;
  if (index == rsp) {
    index = noreg;
    scale = Address::no_scale;
  }
  Address addr(as_Register(b), index, scale, d);
  return addr;
}


#line 1614 "../generated/adfiles/ad_x86_64.cpp"


//SourceForm

#line 152 "/home/top/workspace/openjdk7/hotspot/src/os_cpu/linux_x86/vm/linux_x86_64.ad"


int MachCallRuntimeNode::ret_addr_offset() {
  return 13; // movq r10,#addr; callq (r10)
}

// emit an interrupt that is caught by the debugger
void emit_break(CodeBuffer& cbuf) {
  // Debugger doesn't really catch this but best we can do so far QQQ
  MacroAssembler* masm = new MacroAssembler(&cbuf);
  masm->call(RuntimeAddress(CAST_FROM_FN_PTR(address, os::breakpoint)));
}

void MachBreakpointNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  emit_break(cbuf);
}

uint MachBreakpointNode::size(PhaseRegAlloc* ra_) const {
  return 5;
}


#line 1642 "../generated/adfiles/ad_x86_64.cpp"


#ifndef PRODUCT
void Compile::adlc_verification() {

  // Following assertions generated from definition section
}
#endif

// Map from machine-independent register number to register_save_policy
const        char register_save_policy[] = {
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'N',
  'N',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'N',
  'N',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C' // no trailing comma
};

// Map from machine-independent register number to c_reg_save_policy
const        char c_reg_save_policy[] = {
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'E',
  'E',
  'C',
  'C',
  'E',
  'E',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'E',
  'E',
  'E',
  'E',
  'E',
  'E',
  'E',
  'E',
  'N',
  'N',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C',
  'C' // no trailing comma
};

// Map from machine-independent register number to register_save_type
const        int register_save_type[] = {
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegI,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  Op_RegF,
  0 // no trailing comma
};


const        int   reduceOp[] = {
  0, // 0
  0, // 1
  0, // 2
  0, // 3
  0, // 4
  0, // 5
  0, // 6
  0, // 7
  immI_rule, // 8
  immI0_rule, // 9
  immI1_rule, // 10
  immI_M1_rule, // 11
  immI2_rule, // 12
  immI8_rule, // 13
  immI16_rule, // 14
  immI_32_rule, // 15
  immI_64_rule, // 16
  immP_rule, // 17
  immP0_rule, // 18
  immP_poll_rule, // 19
  immN_rule, // 20
  immN0_rule, // 21
  immP31_rule, // 22
  immL_rule, // 23
  immL8_rule, // 24
  immUL32_rule, // 25
  immL32_rule, // 26
  immL0_rule, // 27
  immL1_rule, // 28
  immL_M1_rule, // 29
  immL10_rule, // 30
  immL_127_rule, // 31
  immL_32bits_rule, // 32
  immF0_rule, // 33
  immF_rule, // 34
  immD0_rule, // 35
  immD_rule, // 36
  immI_16_rule, // 37
  immI_24_rule, // 38
  immI_255_rule, // 39
  immI_65535_rule, // 40
  immL_255_rule, // 41
  immL_65535_rule, // 42
  rRegI_rule, // 43
  rax_RegI_rule, // 44
  rbx_RegI_rule, // 45
  rcx_RegI_rule, // 46
  rdx_RegI_rule, // 47
  rdi_RegI_rule, // 48
  no_rcx_RegI_rule, // 49
  no_rax_rdx_RegI_rule, // 50
  any_RegP_rule, // 51
  rRegP_rule, // 52
  rRegN_rule, // 53
  no_rax_RegP_rule, // 54
  no_rbp_RegP_rule, // 55
  no_rax_rbx_RegP_rule, // 56
  rax_RegP_rule, // 57
  rax_RegN_rule, // 58
  rbx_RegP_rule, // 59
  rsi_RegP_rule, // 60
  rdi_RegP_rule, // 61
  rbp_RegP_rule, // 62
  r15_RegP_rule, // 63
  rRegL_rule, // 64
  no_rax_rdx_RegL_rule, // 65
  no_rax_RegL_rule, // 66
  no_rcx_RegL_rule, // 67
  rax_RegL_rule, // 68
  rcx_RegL_rule, // 69
  rdx_RegL_rule, // 70
  rFlagsReg_rule, // 71
  rFlagsRegU_rule, // 72
  rFlagsRegUCF_rule, // 73
  regF_rule, // 74
  regD_rule, // 75
  indirect_rule, // 76
  indOffset8_rule, // 77
  indOffset32_rule, // 78
  indIndexOffset_rule, // 79
  indIndex_rule, // 80
  indIndexScale_rule, // 81
  indIndexScaleOffset_rule, // 82
  indPosIndexScaleOffset_rule, // 83
  indCompressedOopOffset_rule, // 84
  indirectNarrow_rule, // 85
  indOffset8Narrow_rule, // 86
  indOffset32Narrow_rule, // 87
  indIndexOffsetNarrow_rule, // 88
  indIndexNarrow_rule, // 89
  indIndexScaleNarrow_rule, // 90
  indIndexScaleOffsetNarrow_rule, // 91
  indPosIndexScaleOffsetNarrow_rule, // 92
  stackSlotP_rule, // 93
  stackSlotI_rule, // 94
  stackSlotF_rule, // 95
  stackSlotD_rule, // 96
  stackSlotL_rule, // 97
  cmpOp_rule, // 98
  cmpOpU_rule, // 99
  cmpOpUCF_rule, // 100
  cmpOpUCF2_rule, // 101
  // last operand
  memory_rule, // 102
  // last operand class
  _AddP_any_RegP_rRegL_rule, // 103
  _LShiftL_rRegL_immI2_rule, // 104
  _AddP_any_RegP__LShiftL_rRegL_immI2_rule, // 105
  _ConvI2L_rRegI__rule, // 106
  _LShiftL__ConvI2L_rRegI__immI2_rule, // 107
  _AddP_any_RegP__LShiftL__ConvI2L_rRegI__immI2_rule, // 108
  _DecodeN_rRegN__rule, // 109
  _AddP__DecodeN_rRegN__rRegL_rule, // 110
  _AddP__DecodeN_rRegN___LShiftL_rRegL_immI2_rule, // 111
  _AddP__DecodeN_rRegN___LShiftL__ConvI2L_rRegI__immI2_rule, // 112
  _LoadB_memory__rule, // 113
  _LoadUB_memory__rule, // 114
  _AndI__LoadUB_memory__immI8_rule, // 115
  _LoadS_memory__rule, // 116
  _LShiftI__LoadS_memory__immI_24_rule, // 117
  _LoadUS_memory__rule, // 118
  _LShiftI__LoadUS_memory__immI_24_rule, // 119
  _AndI__LoadUS_memory__immI_255_rule, // 120
  _AndI__LoadUS_memory__immI16_rule, // 121
  _LoadI_memory__rule, // 122
  _LShiftI__LoadI_memory__immI_24_rule, // 123
  _LShiftI__LoadI_memory__immI_16_rule, // 124
  _AndI__LoadI_memory__immI_255_rule, // 125
  _AndI__LoadI_memory__immI_65535_rule, // 126
  _AndI__LoadI_memory__immI_rule, // 127
  _LoadL_memory__rule, // 128
  _AddL__LShiftL_rRegL_immI2_immL32_rule, // 129
  _Binary_cmpOp_rFlagsReg_rule, // 130
  _Binary_rRegI_rRegI_rule, // 131
  _Binary_cmpOpU_rFlagsRegU_rule, // 132
  _Binary_cmpOpUCF_rFlagsRegUCF_rule, // 133
  _Binary_rRegI__LoadI_memory__rule, // 134
  _Binary_rRegN_rRegN_rule, // 135
  _Binary_rRegP_rRegP_rule, // 136
  _Binary_rRegL_rRegL_rule, // 137
  _Binary_rRegL__LoadL_memory__rule, // 138
  _Binary_regF_regF_rule, // 139
  _Binary_regD_regD_rule, // 140
  _AddI__LoadI_memory__rRegI_rule, // 141
  _AddI_rRegI__LoadI_memory__rule, // 142
  _AddI__LoadI_memory__immI_rule, // 143
  _AddI__LoadI_memory__immI1_rule, // 144
  _AddI__LoadI_memory__immI_M1_rule, // 145
  _AddL__LoadL_memory__rRegL_rule, // 146
  _AddL_rRegL__LoadL_memory__rule, // 147
  _AddL__LoadL_memory__immL32_rule, // 148
  _AddL__LoadL_memory__immL1_rule, // 149
  _AddL__LoadL_memory__immL_M1_rule, // 150
  _Binary_rax_RegP_rRegP_rule, // 151
  _Binary_rax_RegI_rRegI_rule, // 152
  _Binary_rax_RegL_rRegL_rule, // 153
  _Binary_rax_RegN_rRegN_rule, // 154
  _SubI__LoadI_memory__rRegI_rule, // 155
  _SubI__LoadI_memory__immI_rule, // 156
  _SubL__LoadL_memory__rRegL_rule, // 157
  _SubL__LoadL_memory__immL32_rule, // 158
  _SubI_immI0_rRegI_rule, // 159
  _SubI_immI0__LoadI_memory__rule, // 160
  _SubL_immL0__LoadL_memory__rule, // 161
  _LShiftI__LoadI_memory__immI1_rule, // 162
  _LShiftI__LoadI_memory__immI8_rule, // 163
  _LShiftI__LoadI_memory__rcx_RegI_rule, // 164
  _RShiftI__LoadI_memory__immI1_rule, // 165
  _RShiftI__LoadI_memory__immI8_rule, // 166
  _RShiftI__LoadI_memory__rcx_RegI_rule, // 167
  _URShiftI__LoadI_memory__immI1_rule, // 168
  _URShiftI__LoadI_memory__immI8_rule, // 169
  _URShiftI__LoadI_memory__rcx_RegI_rule, // 170
  _LShiftL__LoadL_memory__immI1_rule, // 171
  _LShiftL__LoadL_memory__immI8_rule, // 172
  _LShiftL__LoadL_memory__rcx_RegI_rule, // 173
  _RShiftL__LoadL_memory__immI1_rule, // 174
  _RShiftL__LoadL_memory__immI8_rule, // 175
  _RShiftL__LoadL_memory__rcx_RegI_rule, // 176
  _URShiftL__LoadL_memory__immI1_rule, // 177
  _URShiftL__LoadL_memory__immI8_rule, // 178
  _URShiftL__LoadL_memory__rcx_RegI_rule, // 179
  _LShiftI_rRegI_immI_24_rule, // 180
  _LShiftI_rRegI_immI_16_rule, // 181
  _LShiftI_rRegI_immI1_rule, // 182
  _URShiftI_rRegI_immI_M1_rule, // 183
  _LShiftI_rRegI_immI8_rule, // 184
  _URShiftI_rRegI_immI8_rule, // 185
  _LShiftI_no_rcx_RegI_rcx_RegI_rule, // 186
  _SubI_immI0_rcx_RegI_rule, // 187
  _URShiftI_no_rcx_RegI__SubI_immI0_rcx_RegI_rule, // 188
  _SubI_immI_32_rcx_RegI_rule, // 189
  _URShiftI_no_rcx_RegI__SubI_immI_32_rcx_RegI_rule, // 190
  _URShiftI_rRegI_immI1_rule, // 191
  _LShiftI_rRegI_immI_M1_rule, // 192
  _URShiftI_no_rcx_RegI_rcx_RegI_rule, // 193
  _LShiftI_no_rcx_RegI__SubI_immI0_rcx_RegI_rule, // 194
  _LShiftI_no_rcx_RegI__SubI_immI_32_rcx_RegI_rule, // 195
  _LShiftL_rRegL_immI1_rule, // 196
  _URShiftL_rRegL_immI_M1_rule, // 197
  _LShiftL_rRegL_immI8_rule, // 198
  _URShiftL_rRegL_immI8_rule, // 199
  _LShiftL_no_rcx_RegL_rcx_RegI_rule, // 200
  _URShiftL_no_rcx_RegL__SubI_immI0_rcx_RegI_rule, // 201
  _SubI_immI_64_rcx_RegI_rule, // 202
  _URShiftL_no_rcx_RegL__SubI_immI_64_rcx_RegI_rule, // 203
  _URShiftL_rRegL_immI1_rule, // 204
  _LShiftL_rRegL_immI_M1_rule, // 205
  _URShiftL_no_rcx_RegL_rcx_RegI_rule, // 206
  _LShiftL_no_rcx_RegL__SubI_immI0_rcx_RegI_rule, // 207
  _LShiftL_no_rcx_RegL__SubI_immI_64_rcx_RegI_rule, // 208
  _AndI_rRegI_immI_255_rule, // 209
  _AndI_rRegI_immI_65535_rule, // 210
  _AndI__LoadI_memory__rRegI_rule, // 211
  _AndI_rRegI__LoadI_memory__rule, // 212
  _OrI__LoadI_memory__rRegI_rule, // 213
  _OrI_rRegI__LoadI_memory__rule, // 214
  _OrI__LoadI_memory__immI_rule, // 215
  _XorI__LoadI_memory__rRegI_rule, // 216
  _XorI_rRegI__LoadI_memory__rule, // 217
  _XorI__LoadI_memory__immI_rule, // 218
  _AndL__LoadL_memory__rRegL_rule, // 219
  _AndL_rRegL__LoadL_memory__rule, // 220
  _AndL__LoadL_memory__immL32_rule, // 221
  _CastP2X_any_RegP__rule, // 222
  _OrL__LoadL_memory__rRegL_rule, // 223
  _OrL_rRegL__LoadL_memory__rule, // 224
  _OrL__LoadL_memory__immL32_rule, // 225
  _XorL__LoadL_memory__rRegL_rule, // 226
  _XorL_rRegL__LoadL_memory__rule, // 227
  _XorL__LoadL_memory__immL32_rule, // 228
  _CmpLTMask_rRegI_rRegI_rule, // 229
  _AndI__CmpLTMask_rRegI_rRegI_rRegI_rule, // 230
  _SubI_rRegI_rRegI_rule, // 231
  _AndI_rRegI__CmpLTMask_rRegI_rRegI_rule, // 232
  _LoadF_memory__rule, // 233
  _LoadD_memory__rule, // 234
  _ConvF2D_regF__rule, // 235
  _SqrtD__ConvF2D_regF___rule, // 236
  _ConvF2D__LoadF_memory___rule, // 237
  _SqrtD__ConvF2D__LoadF_memory____rule, // 238
  _ConvF2D_immF__rule, // 239
  _SqrtD__ConvF2D_immF___rule, // 240
  _ConvI2L__LoadI_memory___rule, // 241
  _Binary_rdi_RegP_rcx_RegI_rule, // 242
  _Binary_rsi_RegP_rdx_RegI_rule, // 243
  _Binary_rdi_RegP_rdx_RegI_rule, // 244
  _Binary_rsi_RegP_immI_rule, // 245
  _Binary_rsi_RegP_rax_RegI_rule, // 246
  _Binary_rdi_RegP_rsi_RegP_rule, // 247
  _AndI_rRegI_immI_rule, // 248
  _LoadP_memory__rule, // 249
  _LoadN_memory__rule, // 250
  _AndL_rRegL_immL32_rule, // 251
  _PartialSubtypeCheck_rsi_RegP_rax_RegP_rule, // 252
  // last internally defined operand
  stackSlotI_rule, // 253
  stackSlotL_rule, // 254
  stackSlotP_rule, // 255
  stackSlotF_rule, // 256
  stackSlotD_rule, // 257
  rRegP_rule, // 258
  rRegP_rule, // 259
  rRegP_rule, // 260
  rRegP_rule, // 261
  rRegP_rule, // 262
  rRegP_rule, // 263
  rRegP_rule, // 264
  rRegP_rule, // 265
  rRegP_rule, // 266
  rRegP_rule, // 267
  rRegP_rule, // 268
  rRegP_rule, // 269
  rRegP_rule, // 270
  rRegI_rule, // 271
  rRegI_rule, // 272
  rRegL_rule, // 273
  rRegL_rule, // 274
  rRegL_rule, // 275
  rRegL_rule, // 276
  rRegP_rule, // 277
  rRegP_rule, // 278
  rRegP_rule, // 279
  rRegP_rule, // 280
  regF_rule, // 281
  rRegN_rule, // 282
  rRegN_rule, // 283
  regF_rule, // 284
  regD_rule, // 285
  regD_rule, // 286
  rRegI_rule, // 287
  rRegL_rule, // 288
  rRegP_rule, // 289
  regF_rule, // 290
  regD_rule, // 291
  rRegI_rule, // 292
  rRegI_rule, // 293
  rRegI_rule, // 294
  rRegI_rule, // 295
  Universe_rule, // 296
  rRegP_rule, // 297
  rRegL_rule, // 298
  rRegP_rule, // 299
  rRegP_rule, // 300
  rRegI_rule, // 301
  rFlagsReg_rule, // 302
  rFlagsReg_rule, // 303
  rFlagsReg_rule, // 304
  rFlagsRegU_rule, // 305
  rFlagsRegUCF_rule, // 306
  rFlagsRegU_rule, // 307
  rFlagsRegUCF_rule, // 308
  rFlagsRegU_rule, // 309
  rFlagsRegUCF_rule, // 310
  rFlagsRegU_rule, // 311
  rFlagsRegUCF_rule, // 312
  rFlagsRegU_rule, // 313
  rFlagsRegUCF_rule, // 314
  rFlagsRegU_rule, // 315
  rFlagsRegUCF_rule, // 316
  regF_rule, // 317
  regD_rule, // 318
  regF_rule, // 319
  regD_rule, // 320
  regF_rule, // 321
  regD_rule, // 322
  rRegI_rule, // 323
  regF_rule, // 324
  rRegL_rule, // 325
  regD_rule, // 326
  regD_rule, // 327
  rRegI_rule, // 328
  rRegL_rule, // 329
  regF_rule, // 330
  regD_rule, // 331
  rFlagsReg_rule, // 332
  rFlagsReg_rule, // 333
  rFlagsReg_rule, // 334
  rFlagsReg_rule, // 335
  rFlagsReg_rule, // 336
  rFlagsReg_rule, // 337
  rFlagsReg_rule, // 338
  rFlagsRegU_rule, // 339
  rFlagsRegU_rule, // 340
  rFlagsRegU_rule, // 341
  rFlagsRegU_rule, // 342
  rFlagsRegU_rule, // 343
  rFlagsRegU_rule, // 344
  rFlagsRegU_rule, // 345
  rFlagsReg_rule, // 346
  rFlagsReg_rule, // 347
  rFlagsReg_rule, // 348
  rFlagsRegU_rule, // 349
  rFlagsRegU_rule, // 350
  rFlagsRegU_rule, // 351
  rFlagsRegU_rule, // 352
  rFlagsReg_rule, // 353
  rFlagsReg_rule, // 354
  rFlagsReg_rule, // 355
  rFlagsReg_rule, // 356
  rFlagsReg_rule, // 357
  rFlagsReg_rule, // 358
  rFlagsReg_rule, // 359
  rFlagsReg_rule, // 360
  rFlagsReg_rule, // 361
  rFlagsReg_rule, // 362
  rFlagsReg_rule, // 363
  rFlagsReg_rule, // 364
  rFlagsReg_rule, // 365
  Universe_rule, // 366
  r15_RegP_rule, // 367
  rRegI_rule, // 368
  rRegL_rule, // 369
  rRegI_rule, // 370
  rRegL_rule, // 371
  rRegL_rule, // 372
  rRegI_rule, // 373
  rRegI_rule, // 374
  rRegL_rule, // 375
  rRegI_rule, // 376
  rRegI_rule, // 377
  rRegL_rule, // 378
  rRegL_rule, // 379
  rRegL_rule, // 380
  rRegI_rule, // 381
  rRegI_rule, // 382
  rRegI_rule, // 383
  rRegI_rule, // 384
  rRegI_rule, // 385
  rRegL_rule, // 386
  rRegL_rule, // 387
  rRegL_rule, // 388
  rRegL_rule, // 389
  rRegL_rule, // 390
  rRegL_rule, // 391
  rRegI_rule, // 392
  rRegP_rule, // 393
  rRegN_rule, // 394
  rRegP_rule, // 395
  rRegN_rule, // 396
  regF_rule, // 397
  regD_rule, // 398
  regD_rule, // 399
  regD_rule, // 400
  regD_rule, // 401
  regD_rule, // 402
  regD_rule, // 403
  regD_rule, // 404
  Universe_rule, // 405
  Universe_rule, // 406
  Universe_rule, // 407
  Universe_rule, // 408
  Universe_rule, // 409
  Universe_rule, // 410
  Universe_rule, // 411
  Universe_rule, // 412
  Universe_rule, // 413
  Universe_rule, // 414
  Universe_rule, // 415
  Universe_rule, // 416
  Universe_rule, // 417
  Universe_rule, // 418
  Universe_rule, // 419
  Universe_rule, // 420
  Universe_rule, // 421
  Universe_rule, // 422
  Universe_rule, // 423
  Universe_rule, // 424
  Universe_rule, // 425
  Universe_rule, // 426
  Universe_rule, // 427
  Universe_rule, // 428
  Universe_rule, // 429
  Universe_rule, // 430
  Universe_rule, // 431
  Universe_rule, // 432
  Universe_rule, // 433
  Universe_rule, // 434
  Universe_rule, // 435
  Universe_rule, // 436
  Universe_rule, // 437
  Universe_rule, // 438
  Universe_rule, // 439
  Universe_rule, // 440
  Universe_rule, // 441
  Universe_rule, // 442
  rRegI_rule, // 443
  rRegL_rule, // 444
  rRegI_rule, // 445
  rRegI_rule, // 446
  rRegI_rule, // 447
  rRegI_rule, // 448
  rRegI_rule, // 449
  rRegI_rule, // 450
  rRegI_rule, // 451
  rRegI_rule, // 452
  Universe_rule, // 453
  Universe_rule, // 454
  Universe_rule, // 455
  Universe_rule, // 456
  Universe_rule, // 457
  rRegN_rule, // 458
  rRegN_rule, // 459
  rRegP_rule, // 460
  rRegP_rule, // 461
  Universe_rule, // 462
  Universe_rule, // 463
  Universe_rule, // 464
  rRegI_rule, // 465
  rRegI_rule, // 466
  rRegI_rule, // 467
  rRegI_rule, // 468
  rRegI_rule, // 469
  rRegI_rule, // 470
  rRegN_rule, // 471
  rRegN_rule, // 472
  rRegN_rule, // 473
  rRegP_rule, // 474
  rRegP_rule, // 475
  rRegP_rule, // 476
  rRegL_rule, // 477
  rRegL_rule, // 478
  rRegL_rule, // 479
  rRegL_rule, // 480
  rRegL_rule, // 481
  rRegL_rule, // 482
  regF_rule, // 483
  regF_rule, // 484
  regF_rule, // 485
  regD_rule, // 486
  regD_rule, // 487
  regD_rule, // 488
  rRegI_rule, // 489
  rRegI_rule, // 490
  rRegI_rule, // 491
  rRegI_rule, // 492
  Universe_rule, // 493
  Universe_rule, // 494
  Universe_rule, // 495
  rRegI_rule, // 496
  Universe_rule, // 497
  rRegI_rule, // 498
  Universe_rule, // 499
  rRegI_rule, // 500
  rRegL_rule, // 501
  rRegL_rule, // 502
  rRegL_rule, // 503
  rRegL_rule, // 504
  Universe_rule, // 505
  Universe_rule, // 506
  Universe_rule, // 507
  rRegI_rule, // 508
  Universe_rule, // 509
  rRegL_rule, // 510
  Universe_rule, // 511
  rRegL_rule, // 512
  rRegP_rule, // 513
  rRegP_rule, // 514
  rRegP_rule, // 515
  rRegP_rule, // 516
  rRegL_rule, // 517
  rRegI_rule, // 518
  rRegI_rule, // 519
  rRegI_rule, // 520
  rRegI_rule, // 521
  rRegI_rule, // 522
  rRegI_rule, // 523
  rRegI_rule, // 524
  Universe_rule, // 525
  Universe_rule, // 526
  rRegL_rule, // 527
  rRegI_rule, // 528
  rRegL_rule, // 529
  Universe_rule, // 530
  Universe_rule, // 531
  rRegP_rule, // 532
  rRegI_rule, // 533
  Universe_rule, // 534
  rRegL_rule, // 535
  Universe_rule, // 536
  rRegI_rule, // 537
  rRegI_rule, // 538
  rRegI_rule, // 539
  rRegI_rule, // 540
  rRegI_rule, // 541
  rRegL_rule, // 542
  rRegL_rule, // 543
  rRegL_rule, // 544
  rRegL_rule, // 545
  rRegL_rule, // 546
  rdx_RegL_rule, // 547
  rax_RegI_rule, // 548
  rax_RegL_rule, // 549
  Universe_rule, // 550
  Universe_rule, // 551
  0, // 552
  0, // 553
  0, // 554
  0, // 555
  rdx_RegL_rule, // 556
  rdx_RegI_rule, // 557
  rdx_RegL_rule, // 558
  rRegI_rule, // 559
  Universe_rule, // 560
  rRegI_rule, // 561
  Universe_rule, // 562
  rRegI_rule, // 563
  Universe_rule, // 564
  rRegI_rule, // 565
  Universe_rule, // 566
  rRegI_rule, // 567
  Universe_rule, // 568
  rRegI_rule, // 569
  Universe_rule, // 570
  rRegI_rule, // 571
  Universe_rule, // 572
  rRegI_rule, // 573
  Universe_rule, // 574
  rRegI_rule, // 575
  Universe_rule, // 576
  rRegL_rule, // 577
  Universe_rule, // 578
  rRegL_rule, // 579
  Universe_rule, // 580
  rRegL_rule, // 581
  Universe_rule, // 582
  rRegL_rule, // 583
  Universe_rule, // 584
  rRegL_rule, // 585
  Universe_rule, // 586
  rRegL_rule, // 587
  Universe_rule, // 588
  rRegL_rule, // 589
  Universe_rule, // 590
  rRegL_rule, // 591
  Universe_rule, // 592
  rRegL_rule, // 593
  Universe_rule, // 594
  rRegI_rule, // 595
  rRegI_rule, // 596
  0, // 597
  0, // 598
  0, // 599
  rRegI_rule, // 600
  rRegI_rule, // 601
  rRegI_rule, // 602
  rRegI_rule, // 603
  no_rcx_RegI_rule, // 604
  no_rcx_RegI_rule, // 605
  no_rcx_RegI_rule, // 606
  no_rcx_RegI_rule, // 607
  0, // 608
  0, // 609
  0, // 610
  rRegI_rule, // 611
  rRegI_rule, // 612
  rRegI_rule, // 613
  rRegI_rule, // 614
  no_rcx_RegI_rule, // 615
  no_rcx_RegI_rule, // 616
  no_rcx_RegI_rule, // 617
  no_rcx_RegI_rule, // 618
  0, // 619
  0, // 620
  0, // 621
  rRegL_rule, // 622
  rRegL_rule, // 623
  rRegL_rule, // 624
  rRegL_rule, // 625
  no_rcx_RegL_rule, // 626
  no_rcx_RegL_rule, // 627
  no_rcx_RegL_rule, // 628
  no_rcx_RegL_rule, // 629
  0, // 630
  0, // 631
  0, // 632
  rRegL_rule, // 633
  rRegL_rule, // 634
  rRegL_rule, // 635
  rRegL_rule, // 636
  no_rcx_RegL_rule, // 637
  no_rcx_RegL_rule, // 638
  no_rcx_RegL_rule, // 639
  no_rcx_RegL_rule, // 640
  rRegI_rule, // 641
  rRegI_rule, // 642
  rRegL_rule, // 643
  rRegI_rule, // 644
  rRegL_rule, // 645
  rRegI_rule, // 646
  rRegI_rule, // 647
  rRegI_rule, // 648
  Universe_rule, // 649
  Universe_rule, // 650
  Universe_rule, // 651
  rRegI_rule, // 652
  rRegI_rule, // 653
  rRegI_rule, // 654
  rRegI_rule, // 655
  Universe_rule, // 656
  Universe_rule, // 657
  Universe_rule, // 658
  rRegI_rule, // 659
  rRegI_rule, // 660
  rRegI_rule, // 661
  rRegI_rule, // 662
  rRegI_rule, // 663
  Universe_rule, // 664
  Universe_rule, // 665
  Universe_rule, // 666
  rRegL_rule, // 667
  rRegL_rule, // 668
  rRegL_rule, // 669
  rRegL_rule, // 670
  rRegL_rule, // 671
  rRegL_rule, // 672
  Universe_rule, // 673
  Universe_rule, // 674
  Universe_rule, // 675
  rRegL_rule, // 676
  rRegL_rule, // 677
  rRegL_rule, // 678
  rRegL_rule, // 679
  rRegL_rule, // 680
  rRegL_rule, // 681
  Universe_rule, // 682
  Universe_rule, // 683
  Universe_rule, // 684
  rRegL_rule, // 685
  rRegL_rule, // 686
  rRegL_rule, // 687
  rRegL_rule, // 688
  rRegL_rule, // 689
  Universe_rule, // 690
  Universe_rule, // 691
  Universe_rule, // 692
  rRegI_rule, // 693
  rRegI_rule, // 694
  rRegI_rule, // 695
  rRegI_rule, // 696
  rRegI_rule, // 697
  rRegI_rule, // 698
  rRegI_rule, // 699
  rRegI_rule, // 700
  rRegI_rule, // 701
  rRegI_rule, // 702
  rRegI_rule, // 703
  rRegI_rule, // 704
  rRegI_rule, // 705
  rRegI_rule, // 706
  regF_rule, // 707
  regF_rule, // 708
  regF_rule, // 709
  regF_rule, // 710
  regD_rule, // 711
  regD_rule, // 712
  regD_rule, // 713
  regD_rule, // 714
  regF_rule, // 715
  regF_rule, // 716
  regF_rule, // 717
  regD_rule, // 718
  regD_rule, // 719
  regD_rule, // 720
  regF_rule, // 721
  regF_rule, // 722
  regF_rule, // 723
  regF_rule, // 724
  regD_rule, // 725
  regD_rule, // 726
  regD_rule, // 727
  regD_rule, // 728
  regF_rule, // 729
  regF_rule, // 730
  regF_rule, // 731
  regD_rule, // 732
  regD_rule, // 733
  regD_rule, // 734
  regF_rule, // 735
  regF_rule, // 736
  regF_rule, // 737
  regD_rule, // 738
  regD_rule, // 739
  regD_rule, // 740
  regD_rule, // 741
  regD_rule, // 742
  regD_rule, // 743
  regD_rule, // 744
  regD_rule, // 745
  regD_rule, // 746
  regD_rule, // 747
  regF_rule, // 748
  regF_rule, // 749
  rRegI_rule, // 750
  rRegL_rule, // 751
  rRegI_rule, // 752
  rRegL_rule, // 753
  regF_rule, // 754
  regF_rule, // 755
  regD_rule, // 756
  regD_rule, // 757
  regF_rule, // 758
  regD_rule, // 759
  regF_rule, // 760
  regF_rule, // 761
  regD_rule, // 762
  regD_rule, // 763
  rRegL_rule, // 764
  rRegL_rule, // 765
  rRegL_rule, // 766
  rRegL_rule, // 767
  rRegI_rule, // 768
  stackSlotI_rule, // 769
  stackSlotF_rule, // 770
  stackSlotL_rule, // 771
  stackSlotD_rule, // 772
  regD_rule, // 773
  regD_rule, // 774
  regD_rule, // 775
  regD_rule, // 776
  regD_rule, // 777
  regD_rule, // 778
  regD_rule, // 779
  regD_rule, // 780
  regD_rule, // 781
  regD_rule, // 782
  regD_rule, // 783
  regD_rule, // 784
  regD_rule, // 785
  regD_rule, // 786
  regD_rule, // 787
  Universe_rule, // 788
  rax_RegI_rule, // 789
  rbx_RegI_rule, // 790
  rbx_RegI_rule, // 791
  rax_RegI_rule, // 792
  rax_RegI_rule, // 793
  rRegI_rule, // 794
  0, // 795
  rRegI_rule, // 796
  0, // 797
  rRegI_rule, // 798
  Universe_rule, // 799
  Universe_rule, // 800
  Universe_rule, // 801
  Universe_rule, // 802
  Universe_rule, // 803
  Universe_rule, // 804
  Universe_rule, // 805
  Universe_rule, // 806
  rdi_RegP_rule, // 807
  Universe_rule, // 808
  Universe_rule, // 809
  Universe_rule, // 810
  Universe_rule, // 811
  Universe_rule, // 812
  Universe_rule, // 813
  Universe_rule, // 814
  Universe_rule, // 815
  Universe_rule, // 816
  Universe_rule, // 817
  Universe_rule, // 818
  Universe_rule, // 819
  Universe_rule, // 820
  Universe_rule, // 821
  Universe_rule, // 822
  Universe_rule, // 823
  Universe_rule, // 824
  Universe_rule, // 825
  rax_RegP_rule, // 826
  Universe_rule, // 827
  Universe_rule, // 828
  // last instruction
  0 // no trailing comma
};

const        int   leftOp[] = {
  0, // 0
  0, // 1
  0, // 2
  0, // 3
  0, // 4
  0, // 5
  0, // 6
  0, // 7
  0, // 8
  0, // 9
  0, // 10
  0, // 11
  0, // 12
  0, // 13
  0, // 14
  0, // 15
  0, // 16
  0, // 17
  0, // 18
  0, // 19
  0, // 20
  0, // 21
  0, // 22
  0, // 23
  0, // 24
  0, // 25
  0, // 26
  0, // 27
  0, // 28
  0, // 29
  0, // 30
  0, // 31
  0, // 32
  0, // 33
  0, // 34
  0, // 35
  0, // 36
  0, // 37
  0, // 38
  0, // 39
  0, // 40
  0, // 41
  0, // 42
  0, // 43
  0, // 44
  0, // 45
  0, // 46
  0, // 47
  0, // 48
  0, // 49
  0, // 50
  0, // 51
  0, // 52
  0, // 53
  0, // 54
  0, // 55
  0, // 56
  0, // 57
  0, // 58
  0, // 59
  0, // 60
  0, // 61
  0, // 62
  0, // 63
  0, // 64
  0, // 65
  0, // 66
  0, // 67
  0, // 68
  0, // 69
  0, // 70
  0, // 71
  0, // 72
  0, // 73
  0, // 74
  0, // 75
  0, // 76
  any_RegP_rule, // 77
  any_RegP_rule, // 78
  _AddP_any_RegP_rRegL_rule, // 79
  any_RegP_rule, // 80
  any_RegP_rule, // 81
  _AddP_any_RegP__LShiftL_rRegL_immI2_rule, // 82
  _AddP_any_RegP__LShiftL__ConvI2L_rRegI__immI2_rule, // 83
  _DecodeN_rRegN__rule, // 84
  rRegN_rule, // 85
  _DecodeN_rRegN__rule, // 86
  _DecodeN_rRegN__rule, // 87
  _AddP__DecodeN_rRegN__rRegL_rule, // 88
  _DecodeN_rRegN__rule, // 89
  _DecodeN_rRegN__rule, // 90
  _AddP__DecodeN_rRegN___LShiftL_rRegL_immI2_rule, // 91
  _AddP__DecodeN_rRegN___LShiftL__ConvI2L_rRegI__immI2_rule, // 92
  0, // 93
  0, // 94
  0, // 95
  0, // 96
  0, // 97
  0, // 98
  0, // 99
  0, // 100
  0, // 101
  // last operand
  0, // 102
  // last operand class
  any_RegP_rule, // 103
  rRegL_rule, // 104
  any_RegP_rule, // 105
  rRegI_rule, // 106
  _ConvI2L_rRegI__rule, // 107
  any_RegP_rule, // 108
  rRegN_rule, // 109
  _DecodeN_rRegN__rule, // 110
  _DecodeN_rRegN__rule, // 111
  _DecodeN_rRegN__rule, // 112
  memory_rule, // 113
  memory_rule, // 114
  _LoadUB_memory__rule, // 115
  memory_rule, // 116
  _LoadS_memory__rule, // 117
  memory_rule, // 118
  _LoadUS_memory__rule, // 119
  _LoadUS_memory__rule, // 120
  _LoadUS_memory__rule, // 121
  memory_rule, // 122
  _LoadI_memory__rule, // 123
  _LoadI_memory__rule, // 124
  _LoadI_memory__rule, // 125
  _LoadI_memory__rule, // 126
  _LoadI_memory__rule, // 127
  memory_rule, // 128
  _LShiftL_rRegL_immI2_rule, // 129
  cmpOp_rule, // 130
  rRegI_rule, // 131
  cmpOpU_rule, // 132
  cmpOpUCF_rule, // 133
  rRegI_rule, // 134
  rRegN_rule, // 135
  rRegP_rule, // 136
  rRegL_rule, // 137
  rRegL_rule, // 138
  regF_rule, // 139
  regD_rule, // 140
  _LoadI_memory__rule, // 141
  rRegI_rule, // 142
  _LoadI_memory__rule, // 143
  _LoadI_memory__rule, // 144
  _LoadI_memory__rule, // 145
  _LoadL_memory__rule, // 146
  rRegL_rule, // 147
  _LoadL_memory__rule, // 148
  _LoadL_memory__rule, // 149
  _LoadL_memory__rule, // 150
  rax_RegP_rule, // 151
  rax_RegI_rule, // 152
  rax_RegL_rule, // 153
  rax_RegN_rule, // 154
  _LoadI_memory__rule, // 155
  _LoadI_memory__rule, // 156
  _LoadL_memory__rule, // 157
  _LoadL_memory__rule, // 158
  immI0_rule, // 159
  immI0_rule, // 160
  immL0_rule, // 161
  _LoadI_memory__rule, // 162
  _LoadI_memory__rule, // 163
  _LoadI_memory__rule, // 164
  _LoadI_memory__rule, // 165
  _LoadI_memory__rule, // 166
  _LoadI_memory__rule, // 167
  _LoadI_memory__rule, // 168
  _LoadI_memory__rule, // 169
  _LoadI_memory__rule, // 170
  _LoadL_memory__rule, // 171
  _LoadL_memory__rule, // 172
  _LoadL_memory__rule, // 173
  _LoadL_memory__rule, // 174
  _LoadL_memory__rule, // 175
  _LoadL_memory__rule, // 176
  _LoadL_memory__rule, // 177
  _LoadL_memory__rule, // 178
  _LoadL_memory__rule, // 179
  rRegI_rule, // 180
  rRegI_rule, // 181
  rRegI_rule, // 182
  rRegI_rule, // 183
  rRegI_rule, // 184
  rRegI_rule, // 185
  no_rcx_RegI_rule, // 186
  immI0_rule, // 187
  no_rcx_RegI_rule, // 188
  immI_32_rule, // 189
  no_rcx_RegI_rule, // 190
  rRegI_rule, // 191
  rRegI_rule, // 192
  no_rcx_RegI_rule, // 193
  no_rcx_RegI_rule, // 194
  no_rcx_RegI_rule, // 195
  rRegL_rule, // 196
  rRegL_rule, // 197
  rRegL_rule, // 198
  rRegL_rule, // 199
  no_rcx_RegL_rule, // 200
  no_rcx_RegL_rule, // 201
  immI_64_rule, // 202
  no_rcx_RegL_rule, // 203
  rRegL_rule, // 204
  rRegL_rule, // 205
  no_rcx_RegL_rule, // 206
  no_rcx_RegL_rule, // 207
  no_rcx_RegL_rule, // 208
  rRegI_rule, // 209
  rRegI_rule, // 210
  _LoadI_memory__rule, // 211
  rRegI_rule, // 212
  _LoadI_memory__rule, // 213
  rRegI_rule, // 214
  _LoadI_memory__rule, // 215
  _LoadI_memory__rule, // 216
  rRegI_rule, // 217
  _LoadI_memory__rule, // 218
  _LoadL_memory__rule, // 219
  rRegL_rule, // 220
  _LoadL_memory__rule, // 221
  any_RegP_rule, // 222
  _LoadL_memory__rule, // 223
  rRegL_rule, // 224
  _LoadL_memory__rule, // 225
  _LoadL_memory__rule, // 226
  rRegL_rule, // 227
  _LoadL_memory__rule, // 228
  rRegI_rule, // 229
  _CmpLTMask_rRegI_rRegI_rule, // 230
  rRegI_rule, // 231
  rRegI_rule, // 232
  memory_rule, // 233
  memory_rule, // 234
  regF_rule, // 235
  _ConvF2D_regF__rule, // 236
  _LoadF_memory__rule, // 237
  _ConvF2D__LoadF_memory___rule, // 238
  immF_rule, // 239
  _ConvF2D_immF__rule, // 240
  _LoadI_memory__rule, // 241
  rdi_RegP_rule, // 242
  rsi_RegP_rule, // 243
  rdi_RegP_rule, // 244
  rsi_RegP_rule, // 245
  rsi_RegP_rule, // 246
  rdi_RegP_rule, // 247
  rRegI_rule, // 248
  memory_rule, // 249
  memory_rule, // 250
  rRegL_rule, // 251
  rsi_RegP_rule, // 252
  // last internally defined operand
  rRegI_rule, // 253
  rRegL_rule, // 254
  rRegP_rule, // 255
  regF_rule, // 256
  regD_rule, // 257
  indOffset8_rule, // 258
  indOffset32_rule, // 259
  indIndexOffset_rule, // 260
  indIndexScale_rule, // 261
  indIndexScaleOffset_rule, // 262
  indPosIndexScaleOffset_rule, // 263
  indCompressedOopOffset_rule, // 264
  indOffset8Narrow_rule, // 265
  indOffset32Narrow_rule, // 266
  indIndexOffsetNarrow_rule, // 267
  indIndexScaleNarrow_rule, // 268
  indIndexScaleOffsetNarrow_rule, // 269
  indPosIndexScaleOffsetNarrow_rule, // 270
  immI_rule, // 271
  immI0_rule, // 272
  immL_rule, // 273
  immL0_rule, // 274
  immUL32_rule, // 275
  immL32_rule, // 276
  immP_rule, // 277
  immP0_rule, // 278
  immP_poll_rule, // 279
  immP31_rule, // 280
  immF_rule, // 281
  immN0_rule, // 282
  immN_rule, // 283
  immF0_rule, // 284
  immD_rule, // 285
  immD0_rule, // 286
  stackSlotI_rule, // 287
  stackSlotL_rule, // 288
  stackSlotP_rule, // 289
  stackSlotF_rule, // 290
  stackSlotD_rule, // 291
  rRegI_rule, // 292
  _LoadI_memory__rule, // 293
  rRegL_rule, // 294
  _LoadL_memory__rule, // 295
  0, // 296
  rRegL_rule, // 297
  rRegP_rule, // 298
  rRegP_rule, // 299
  rRegP_rule, // 300
  rRegI_rule, // 301
  memory_rule, // 302
  memory_rule, // 303
  memory_rule, // 304
  regF_rule, // 305
  regF_rule, // 306
  regF_rule, // 307
  regF_rule, // 308
  regF_rule, // 309
  regF_rule, // 310
  regD_rule, // 311
  regD_rule, // 312
  regD_rule, // 313
  regD_rule, // 314
  regD_rule, // 315
  regD_rule, // 316
  regF_rule, // 317
  regD_rule, // 318
  regF_rule, // 319
  regD_rule, // 320
  regF_rule, // 321
  regD_rule, // 322
  stackSlotF_rule, // 323
  stackSlotI_rule, // 324
  stackSlotD_rule, // 325
  stackSlotL_rule, // 326
  stackSlotL_rule, // 327
  regF_rule, // 328
  regD_rule, // 329
  rRegI_rule, // 330
  rRegL_rule, // 331
  rRegI_rule, // 332
  rRegI_rule, // 333
  rRegI_rule, // 334
  rRegI_rule, // 335
  _AndI_rRegI_immI_rule, // 336
  _AndI_rRegI__LoadI_memory__rule, // 337
  _AndI__LoadI_memory__rRegI_rule, // 338
  rRegI_rule, // 339
  rRegI_rule, // 340
  rRegI_rule, // 341
  rRegI_rule, // 342
  rRegP_rule, // 343
  rRegP_rule, // 344
  rRegP_rule, // 345
  rRegP_rule, // 346
  _LoadP_memory__rule, // 347
  _LoadP_memory__rule, // 348
  rRegN_rule, // 349
  rRegN_rule, // 350
  rRegN_rule, // 351
  immN_rule, // 352
  rRegN_rule, // 353
  _LoadN_memory__rule, // 354
  _LoadN_memory__rule, // 355
  rRegL_rule, // 356
  rRegL_rule, // 357
  rRegL_rule, // 358
  rRegL_rule, // 359
  _AndL_rRegL_immL32_rule, // 360
  _AndL_rRegL__LoadL_memory__rule, // 361
  _AndL__LoadL_memory__rRegL_rule, // 362
  _PartialSubtypeCheck_rsi_RegP_rax_RegP_rule, // 363
  rRegP_rule, // 364
  rRegP_rule, // 365
  0, // 366
  0, // 367
  memory_rule, // 368
  _LoadB_memory__rule, // 369
  memory_rule, // 370
  _LoadUB_memory__rule, // 371
  _AndI__LoadUB_memory__immI8_rule, // 372
  memory_rule, // 373
  _LShiftI__LoadS_memory__immI_24_rule, // 374
  _LoadS_memory__rule, // 375
  memory_rule, // 376
  _LShiftI__LoadUS_memory__immI_24_rule, // 377
  _LoadUS_memory__rule, // 378
  _AndI__LoadUS_memory__immI_255_rule, // 379
  _AndI__LoadUS_memory__immI16_rule, // 380
  memory_rule, // 381
  _LShiftI__LoadI_memory__immI_24_rule, // 382
  _LoadI_memory__rule, // 383
  _LShiftI__LoadI_memory__immI_16_rule, // 384
  _LoadI_memory__rule, // 385
  _LoadI_memory__rule, // 386
  _AndI__LoadI_memory__immI_255_rule, // 387
  _AndI__LoadI_memory__immI_65535_rule, // 388
  _AndI__LoadI_memory__immI_rule, // 389
  memory_rule, // 390
  memory_rule, // 391
  memory_rule, // 392
  memory_rule, // 393
  memory_rule, // 394
  memory_rule, // 395
  memory_rule, // 396
  memory_rule, // 397
  memory_rule, // 398
  memory_rule, // 399
  memory_rule, // 400
  memory_rule, // 401
  memory_rule, // 402
  memory_rule, // 403
  memory_rule, // 404
  memory_rule, // 405
  memory_rule, // 406
  memory_rule, // 407
  memory_rule, // 408
  memory_rule, // 409
  memory_rule, // 410
  memory_rule, // 411
  memory_rule, // 412
  memory_rule, // 413
  memory_rule, // 414
  memory_rule, // 415
  memory_rule, // 416
  memory_rule, // 417
  memory_rule, // 418
  memory_rule, // 419
  memory_rule, // 420
  memory_rule, // 421
  memory_rule, // 422
  memory_rule, // 423
  memory_rule, // 424
  memory_rule, // 425
  memory_rule, // 426
  memory_rule, // 427
  memory_rule, // 428
  memory_rule, // 429
  memory_rule, // 430
  memory_rule, // 431
  memory_rule, // 432
  memory_rule, // 433
  memory_rule, // 434
  memory_rule, // 435
  memory_rule, // 436
  memory_rule, // 437
  memory_rule, // 438
  memory_rule, // 439
  memory_rule, // 440
  memory_rule, // 441
  memory_rule, // 442
  rRegI_rule, // 443
  rRegL_rule, // 444
  rRegI_rule, // 445
  rRegI_rule, // 446
  rRegI_rule, // 447
  rRegI_rule, // 448
  rRegL_rule, // 449
  rRegL_rule, // 450
  rRegI_rule, // 451
  rRegL_rule, // 452
  0, // 453
  0, // 454
  0, // 455
  0, // 456
  0, // 457
  rRegP_rule, // 458
  rRegP_rule, // 459
  rRegN_rule, // 460
  rRegN_rule, // 461
  _LShiftL_rRegL_immI2_rule, // 462
  _AddL__LShiftL_rRegL_immI2_immL32_rule, // 463
  rRegL_rule, // 464
  _Binary_cmpOp_rFlagsReg_rule, // 465
  _Binary_cmpOpU_rFlagsRegU_rule, // 466
  _Binary_cmpOpUCF_rFlagsRegUCF_rule, // 467
  _Binary_cmpOp_rFlagsReg_rule, // 468
  _Binary_cmpOpU_rFlagsRegU_rule, // 469
  _Binary_cmpOpUCF_rFlagsRegUCF_rule, // 470
  _Binary_cmpOp_rFlagsReg_rule, // 471
  _Binary_cmpOpU_rFlagsRegU_rule, // 472
  _Binary_cmpOpUCF_rFlagsRegUCF_rule, // 473
  _Binary_cmpOp_rFlagsReg_rule, // 474
  _Binary_cmpOpU_rFlagsRegU_rule, // 475
  _Binary_cmpOpUCF_rFlagsRegUCF_rule, // 476
  _Binary_cmpOp_rFlagsReg_rule, // 477
  _Binary_cmpOp_rFlagsReg_rule, // 478
  _Binary_cmpOpU_rFlagsRegU_rule, // 479
  _Binary_cmpOpUCF_rFlagsRegUCF_rule, // 480
  _Binary_cmpOpU_rFlagsRegU_rule, // 481
  _Binary_cmpOpUCF_rFlagsRegUCF_rule, // 482
  _Binary_cmpOp_rFlagsReg_rule, // 483
  _Binary_cmpOpU_rFlagsRegU_rule, // 484
  _Binary_cmpOpUCF_rFlagsRegUCF_rule, // 485
  _Binary_cmpOp_rFlagsReg_rule, // 486
  _Binary_cmpOpU_rFlagsRegU_rule, // 487
  _Binary_cmpOpUCF_rFlagsRegUCF_rule, // 488
  rRegI_rule, // 489
  rRegI_rule, // 490
  rRegI_rule, // 491
  _LoadI_memory__rule, // 492
  memory_rule, // 493
  memory_rule, // 494
  memory_rule, // 495
  rRegI_rule, // 496
  memory_rule, // 497
  rRegI_rule, // 498
  memory_rule, // 499
  rRegI_rule, // 500
  rRegL_rule, // 501
  rRegL_rule, // 502
  rRegL_rule, // 503
  _LoadL_memory__rule, // 504
  memory_rule, // 505
  memory_rule, // 506
  memory_rule, // 507
  rRegI_rule, // 508
  memory_rule, // 509
  rRegL_rule, // 510
  memory_rule, // 511
  rRegL_rule, // 512
  rRegP_rule, // 513
  rRegP_rule, // 514
  rRegP_rule, // 515
  memory_rule, // 516
  memory_rule, // 517
  memory_rule, // 518
  memory_rule, // 519
  memory_rule, // 520
  memory_rule, // 521
  rRegI_rule, // 522
  rRegI_rule, // 523
  rRegI_rule, // 524
  memory_rule, // 525
  memory_rule, // 526
  rRegL_rule, // 527
  rRegI_rule, // 528
  rRegL_rule, // 529
  memory_rule, // 530
  memory_rule, // 531
  rRegP_rule, // 532
  immI0_rule, // 533
  memory_rule, // 534
  immL0_rule, // 535
  memory_rule, // 536
  rRegI_rule, // 537
  rRegI_rule, // 538
  rRegI_rule, // 539
  _LoadI_memory__rule, // 540
  _LoadI_memory__rule, // 541
  rRegL_rule, // 542
  rRegL_rule, // 543
  rRegL_rule, // 544
  _LoadL_memory__rule, // 545
  _LoadL_memory__rule, // 546
  no_rax_RegL_rule, // 547
  rax_RegI_rule, // 548
  rax_RegL_rule, // 549
  rax_RegI_rule, // 550
  rax_RegL_rule, // 551
  0, // 552
  0, // 553
  0, // 554
  0, // 555
  no_rax_RegL_rule, // 556
  rax_RegI_rule, // 557
  rax_RegL_rule, // 558
  rRegI_rule, // 559
  memory_rule, // 560
  rRegI_rule, // 561
  memory_rule, // 562
  rRegI_rule, // 563
  memory_rule, // 564
  rRegI_rule, // 565
  memory_rule, // 566
  rRegI_rule, // 567
  memory_rule, // 568
  rRegI_rule, // 569
  memory_rule, // 570
  rRegI_rule, // 571
  memory_rule, // 572
  rRegI_rule, // 573
  memory_rule, // 574
  rRegI_rule, // 575
  memory_rule, // 576
  rRegL_rule, // 577
  memory_rule, // 578
  rRegL_rule, // 579
  memory_rule, // 580
  rRegL_rule, // 581
  memory_rule, // 582
  rRegL_rule, // 583
  memory_rule, // 584
  rRegL_rule, // 585
  memory_rule, // 586
  rRegL_rule, // 587
  memory_rule, // 588
  rRegL_rule, // 589
  memory_rule, // 590
  rRegL_rule, // 591
  memory_rule, // 592
  rRegL_rule, // 593
  memory_rule, // 594
  _LShiftI_rRegI_immI_24_rule, // 595
  _LShiftI_rRegI_immI_16_rule, // 596
  0, // 597
  0, // 598
  0, // 599
  _LShiftI_rRegI_immI1_rule, // 600
  _URShiftI_rRegI_immI_M1_rule, // 601
  _LShiftI_rRegI_immI8_rule, // 602
  _URShiftI_rRegI_immI8_rule, // 603
  _LShiftI_no_rcx_RegI_rcx_RegI_rule, // 604
  _URShiftI_no_rcx_RegI__SubI_immI0_rcx_RegI_rule, // 605
  _LShiftI_no_rcx_RegI_rcx_RegI_rule, // 606
  _URShiftI_no_rcx_RegI__SubI_immI_32_rcx_RegI_rule, // 607
  0, // 608
  0, // 609
  0, // 610
  _URShiftI_rRegI_immI1_rule, // 611
  _LShiftI_rRegI_immI_M1_rule, // 612
  _URShiftI_rRegI_immI8_rule, // 613
  _LShiftI_rRegI_immI8_rule, // 614
  _URShiftI_no_rcx_RegI_rcx_RegI_rule, // 615
  _LShiftI_no_rcx_RegI__SubI_immI0_rcx_RegI_rule, // 616
  _URShiftI_no_rcx_RegI_rcx_RegI_rule, // 617
  _LShiftI_no_rcx_RegI__SubI_immI_32_rcx_RegI_rule, // 618
  0, // 619
  0, // 620
  0, // 621
  _LShiftL_rRegL_immI1_rule, // 622
  _URShiftL_rRegL_immI_M1_rule, // 623
  _LShiftL_rRegL_immI8_rule, // 624
  _URShiftL_rRegL_immI8_rule, // 625
  _LShiftL_no_rcx_RegL_rcx_RegI_rule, // 626
  _URShiftL_no_rcx_RegL__SubI_immI0_rcx_RegI_rule, // 627
  _LShiftL_no_rcx_RegL_rcx_RegI_rule, // 628
  _URShiftL_no_rcx_RegL__SubI_immI_64_rcx_RegI_rule, // 629
  0, // 630
  0, // 631
  0, // 632
  _URShiftL_rRegL_immI1_rule, // 633
  _LShiftL_rRegL_immI_M1_rule, // 634
  _URShiftL_rRegL_immI8_rule, // 635
  _LShiftL_rRegL_immI8_rule, // 636
  _URShiftL_no_rcx_RegL_rcx_RegI_rule, // 637
  _LShiftL_no_rcx_RegL__SubI_immI0_rcx_RegI_rule, // 638
  _URShiftL_no_rcx_RegL_rcx_RegI_rule, // 639
  _LShiftL_no_rcx_RegL__SubI_immI_64_rcx_RegI_rule, // 640
  rRegI_rule, // 641
  rRegI_rule, // 642
  _AndI_rRegI_immI_255_rule, // 643
  rRegI_rule, // 644
  _AndI_rRegI_immI_65535_rule, // 645
  rRegI_rule, // 646
  rRegI_rule, // 647
  _LoadI_memory__rule, // 648
  memory_rule, // 649
  memory_rule, // 650
  memory_rule, // 651
  rRegI_rule, // 652
  rRegI_rule, // 653
  rRegI_rule, // 654
  _LoadI_memory__rule, // 655
  memory_rule, // 656
  memory_rule, // 657
  memory_rule, // 658
  rRegI_rule, // 659
  rRegI_rule, // 660
  rRegI_rule, // 661
  rRegI_rule, // 662
  _LoadI_memory__rule, // 663
  memory_rule, // 664
  memory_rule, // 665
  memory_rule, // 666
  rRegL_rule, // 667
  rRegL_rule, // 668
  rRegL_rule, // 669
  rRegL_rule, // 670
  rRegL_rule, // 671
  _LoadL_memory__rule, // 672
  memory_rule, // 673
  memory_rule, // 674
  memory_rule, // 675
  rRegL_rule, // 676
  rRegL_rule, // 677
  _CastP2X_any_RegP__rule, // 678
  rRegL_rule, // 679
  rRegL_rule, // 680
  _LoadL_memory__rule, // 681
  memory_rule, // 682
  memory_rule, // 683
  memory_rule, // 684
  rRegL_rule, // 685
  rRegL_rule, // 686
  rRegL_rule, // 687
  rRegL_rule, // 688
  _LoadL_memory__rule, // 689
  memory_rule, // 690
  memory_rule, // 691
  memory_rule, // 692
  rRegI_rule, // 693
  rRegP_rule, // 694
  rRegI_rule, // 695
  rRegI_rule, // 696
  _AndI__CmpLTMask_rRegI_rRegI_rRegI_rule, // 697
  _SubI_rRegI_rRegI_rule, // 698
  _AndI_rRegI__CmpLTMask_rRegI_rRegI_rule, // 699
  _SubI_rRegI_rRegI_rule, // 700
  regF_rule, // 701
  regF_rule, // 702
  regF_rule, // 703
  regD_rule, // 704
  regD_rule, // 705
  regD_rule, // 706
  regF_rule, // 707
  regF_rule, // 708
  _LoadF_memory__rule, // 709
  regF_rule, // 710
  regD_rule, // 711
  regD_rule, // 712
  _LoadD_memory__rule, // 713
  regD_rule, // 714
  regF_rule, // 715
  regF_rule, // 716
  regF_rule, // 717
  regD_rule, // 718
  regD_rule, // 719
  regD_rule, // 720
  regF_rule, // 721
  regF_rule, // 722
  _LoadF_memory__rule, // 723
  regF_rule, // 724
  regD_rule, // 725
  regD_rule, // 726
  _LoadD_memory__rule, // 727
  regD_rule, // 728
  regF_rule, // 729
  regF_rule, // 730
  regF_rule, // 731
  regD_rule, // 732
  regD_rule, // 733
  regD_rule, // 734
  _SqrtD__ConvF2D_regF___rule, // 735
  _SqrtD__ConvF2D__LoadF_memory____rule, // 736
  _SqrtD__ConvF2D_immF___rule, // 737
  regD_rule, // 738
  _LoadD_memory__rule, // 739
  immD_rule, // 740
  regD_rule, // 741
  regD_rule, // 742
  regD_rule, // 743
  regD_rule, // 744
  regD_rule, // 745
  regF_rule, // 746
  _LoadF_memory__rule, // 747
  regD_rule, // 748
  _LoadD_memory__rule, // 749
  regF_rule, // 750
  regF_rule, // 751
  regD_rule, // 752
  regD_rule, // 753
  rRegI_rule, // 754
  _LoadI_memory__rule, // 755
  rRegI_rule, // 756
  _LoadI_memory__rule, // 757
  rRegI_rule, // 758
  rRegI_rule, // 759
  rRegL_rule, // 760
  _LoadL_memory__rule, // 761
  rRegL_rule, // 762
  _LoadL_memory__rule, // 763
  rRegI_rule, // 764
  _ConvI2L_rRegI__rule, // 765
  _ConvI2L__LoadI_memory___rule, // 766
  rRegL_rule, // 767
  rRegL_rule, // 768
  regF_rule, // 769
  rRegI_rule, // 770
  regD_rule, // 771
  rRegL_rule, // 772
  regD_rule, // 773
  rRegI_rule, // 774
  immI0_rule, // 775
  regD_rule, // 776
  rRegI_rule, // 777
  immI0_rule, // 778
  regD_rule, // 779
  rRegI_rule, // 780
  immI0_rule, // 781
  regD_rule, // 782
  rRegI_rule, // 783
  immI0_rule, // 784
  regD_rule, // 785
  regF_rule, // 786
  immF0_rule, // 787
  rcx_RegL_rule, // 788
  _Binary_rdi_RegP_rcx_RegI_rule, // 789
  _Binary_rdi_RegP_rdx_RegI_rule, // 790
  _Binary_rdi_RegP_rdx_RegI_rule, // 791
  _Binary_rdi_RegP_rsi_RegP_rule, // 792
  rdi_RegP_rule, // 793
  rRegL_rule, // 794
  0, // 795
  rRegI_rule, // 796
  0, // 797
  rRegI_rule, // 798
  0, // 799
  cmpOp_rule, // 800
  cmpOp_rule, // 801
  cmpOpU_rule, // 802
  cmpOpUCF_rule, // 803
  cmpOpU_rule, // 804
  cmpOpUCF_rule, // 805
  cmpOpUCF2_rule, // 806
  rsi_RegP_rule, // 807
  0, // 808
  cmpOp_rule, // 809
  cmpOp_rule, // 810
  cmpOpU_rule, // 811
  cmpOpUCF_rule, // 812
  cmpOpU_rule, // 813
  cmpOpUCF_rule, // 814
  cmpOpUCF2_rule, // 815
  rRegP_rule, // 816
  0, // 817
  0, // 818
  0, // 819
  0, // 820
  0, // 821
  0, // 822
  0, // 823
  no_rbp_RegP_rule, // 824
  no_rbp_RegP_rule, // 825
  0, // 826
  0, // 827
  0, // 828
  // last instruction
  0 // no trailing comma
};

const        int   rightOp[] = {
  0, // 0
  0, // 1
  0, // 2
  0, // 3
  0, // 4
  0, // 5
  0, // 6
  0, // 7
  0, // 8
  0, // 9
  0, // 10
  0, // 11
  0, // 12
  0, // 13
  0, // 14
  0, // 15
  0, // 16
  0, // 17
  0, // 18
  0, // 19
  0, // 20
  0, // 21
  0, // 22
  0, // 23
  0, // 24
  0, // 25
  0, // 26
  0, // 27
  0, // 28
  0, // 29
  0, // 30
  0, // 31
  0, // 32
  0, // 33
  0, // 34
  0, // 35
  0, // 36
  0, // 37
  0, // 38
  0, // 39
  0, // 40
  0, // 41
  0, // 42
  0, // 43
  0, // 44
  0, // 45
  0, // 46
  0, // 47
  0, // 48
  0, // 49
  0, // 50
  0, // 51
  0, // 52
  0, // 53
  0, // 54
  0, // 55
  0, // 56
  0, // 57
  0, // 58
  0, // 59
  0, // 60
  0, // 61
  0, // 62
  0, // 63
  0, // 64
  0, // 65
  0, // 66
  0, // 67
  0, // 68
  0, // 69
  0, // 70
  0, // 71
  0, // 72
  0, // 73
  0, // 74
  0, // 75
  0, // 76
  immL8_rule, // 77
  immL32_rule, // 78
  immL32_rule, // 79
  rRegL_rule, // 80
  _LShiftL_rRegL_immI2_rule, // 81
  immL32_rule, // 82
  immL32_rule, // 83
  immL32_rule, // 84
  0, // 85
  immL8_rule, // 86
  immL32_rule, // 87
  immL32_rule, // 88
  rRegL_rule, // 89
  _LShiftL_rRegL_immI2_rule, // 90
  immL32_rule, // 91
  immL32_rule, // 92
  0, // 93
  0, // 94
  0, // 95
  0, // 96
  0, // 97
  0, // 98
  0, // 99
  0, // 100
  0, // 101
  // last operand
  0, // 102
  // last operand class
  rRegL_rule, // 103
  immI2_rule, // 104
  _LShiftL_rRegL_immI2_rule, // 105
  0, // 106
  immI2_rule, // 107
  _LShiftL__ConvI2L_rRegI__immI2_rule, // 108
  0, // 109
  rRegL_rule, // 110
  _LShiftL_rRegL_immI2_rule, // 111
  _LShiftL__ConvI2L_rRegI__immI2_rule, // 112
  0, // 113
  0, // 114
  immI8_rule, // 115
  0, // 116
  immI_24_rule, // 117
  0, // 118
  immI_24_rule, // 119
  immI_255_rule, // 120
  immI16_rule, // 121
  0, // 122
  immI_24_rule, // 123
  immI_16_rule, // 124
  immI_255_rule, // 125
  immI_65535_rule, // 126
  immI_rule, // 127
  0, // 128
  immL32_rule, // 129
  rFlagsReg_rule, // 130
  rRegI_rule, // 131
  rFlagsRegU_rule, // 132
  rFlagsRegUCF_rule, // 133
  _LoadI_memory__rule, // 134
  rRegN_rule, // 135
  rRegP_rule, // 136
  rRegL_rule, // 137
  _LoadL_memory__rule, // 138
  regF_rule, // 139
  regD_rule, // 140
  rRegI_rule, // 141
  _LoadI_memory__rule, // 142
  immI_rule, // 143
  immI1_rule, // 144
  immI_M1_rule, // 145
  rRegL_rule, // 146
  _LoadL_memory__rule, // 147
  immL32_rule, // 148
  immL1_rule, // 149
  immL_M1_rule, // 150
  rRegP_rule, // 151
  rRegI_rule, // 152
  rRegL_rule, // 153
  rRegN_rule, // 154
  rRegI_rule, // 155
  immI_rule, // 156
  rRegL_rule, // 157
  immL32_rule, // 158
  rRegI_rule, // 159
  _LoadI_memory__rule, // 160
  _LoadL_memory__rule, // 161
  immI1_rule, // 162
  immI8_rule, // 163
  rcx_RegI_rule, // 164
  immI1_rule, // 165
  immI8_rule, // 166
  rcx_RegI_rule, // 167
  immI1_rule, // 168
  immI8_rule, // 169
  rcx_RegI_rule, // 170
  immI1_rule, // 171
  immI8_rule, // 172
  rcx_RegI_rule, // 173
  immI1_rule, // 174
  immI8_rule, // 175
  rcx_RegI_rule, // 176
  immI1_rule, // 177
  immI8_rule, // 178
  rcx_RegI_rule, // 179
  immI_24_rule, // 180
  immI_16_rule, // 181
  immI1_rule, // 182
  immI_M1_rule, // 183
  immI8_rule, // 184
  immI8_rule, // 185
  rcx_RegI_rule, // 186
  rcx_RegI_rule, // 187
  _SubI_immI0_rcx_RegI_rule, // 188
  rcx_RegI_rule, // 189
  _SubI_immI_32_rcx_RegI_rule, // 190
  immI1_rule, // 191
  immI_M1_rule, // 192
  rcx_RegI_rule, // 193
  _SubI_immI0_rcx_RegI_rule, // 194
  _SubI_immI_32_rcx_RegI_rule, // 195
  immI1_rule, // 196
  immI_M1_rule, // 197
  immI8_rule, // 198
  immI8_rule, // 199
  rcx_RegI_rule, // 200
  _SubI_immI0_rcx_RegI_rule, // 201
  rcx_RegI_rule, // 202
  _SubI_immI_64_rcx_RegI_rule, // 203
  immI1_rule, // 204
  immI_M1_rule, // 205
  rcx_RegI_rule, // 206
  _SubI_immI0_rcx_RegI_rule, // 207
  _SubI_immI_64_rcx_RegI_rule, // 208
  immI_255_rule, // 209
  immI_65535_rule, // 210
  rRegI_rule, // 211
  _LoadI_memory__rule, // 212
  rRegI_rule, // 213
  _LoadI_memory__rule, // 214
  immI_rule, // 215
  rRegI_rule, // 216
  _LoadI_memory__rule, // 217
  immI_rule, // 218
  rRegL_rule, // 219
  _LoadL_memory__rule, // 220
  immL32_rule, // 221
  0, // 222
  rRegL_rule, // 223
  _LoadL_memory__rule, // 224
  immL32_rule, // 225
  rRegL_rule, // 226
  _LoadL_memory__rule, // 227
  immL32_rule, // 228
  rRegI_rule, // 229
  rRegI_rule, // 230
  rRegI_rule, // 231
  _CmpLTMask_rRegI_rRegI_rule, // 232
  0, // 233
  0, // 234
  0, // 235
  0, // 236
  0, // 237
  0, // 238
  0, // 239
  0, // 240
  0, // 241
  rcx_RegI_rule, // 242
  rdx_RegI_rule, // 243
  rdx_RegI_rule, // 244
  immI_rule, // 245
  rax_RegI_rule, // 246
  rsi_RegP_rule, // 247
  immI_rule, // 248
  0, // 249
  0, // 250
  immL32_rule, // 251
  rax_RegP_rule, // 252
  // last internally defined operand
  0, // 253
  0, // 254
  0, // 255
  0, // 256
  0, // 257
  0, // 258
  0, // 259
  0, // 260
  0, // 261
  0, // 262
  0, // 263
  0, // 264
  0, // 265
  0, // 266
  0, // 267
  0, // 268
  0, // 269
  0, // 270
  0, // 271
  0, // 272
  0, // 273
  0, // 274
  0, // 275
  0, // 276
  0, // 277
  0, // 278
  0, // 279
  0, // 280
  0, // 281
  0, // 282
  0, // 283
  0, // 284
  0, // 285
  0, // 286
  0, // 287
  0, // 288
  0, // 289
  0, // 290
  0, // 291
  0, // 292
  0, // 293
  0, // 294
  0, // 295
  0, // 296
  0, // 297
  0, // 298
  0, // 299
  0, // 300
  0, // 301
  _Binary_rax_RegP_rRegP_rule, // 302
  _Binary_rax_RegI_rRegI_rule, // 303
  _Binary_rax_RegL_rRegL_rule, // 304
  regF_rule, // 305
  regF_rule, // 306
  _LoadF_memory__rule, // 307
  _LoadF_memory__rule, // 308
  immF_rule, // 309
  immF_rule, // 310
  regD_rule, // 311
  regD_rule, // 312
  _LoadD_memory__rule, // 313
  _LoadD_memory__rule, // 314
  immD_rule, // 315
  immD_rule, // 316
  0, // 317
  0, // 318
  0, // 319
  0, // 320
  0, // 321
  0, // 322
  0, // 323
  0, // 324
  0, // 325
  0, // 326
  0, // 327
  0, // 328
  0, // 329
  0, // 330
  0, // 331
  rRegI_rule, // 332
  immI_rule, // 333
  _LoadI_memory__rule, // 334
  immI0_rule, // 335
  immI0_rule, // 336
  immI0_rule, // 337
  immI0_rule, // 338
  rRegI_rule, // 339
  immI_rule, // 340
  _LoadI_memory__rule, // 341
  immI0_rule, // 342
  rRegP_rule, // 343
  _LoadP_memory__rule, // 344
  _LoadP_memory__rule, // 345
  immP0_rule, // 346
  immP0_rule, // 347
  immP0_rule, // 348
  rRegN_rule, // 349
  _LoadN_memory__rule, // 350
  immN_rule, // 351
  _LoadN_memory__rule, // 352
  immN0_rule, // 353
  immN0_rule, // 354
  immN0_rule, // 355
  rRegL_rule, // 356
  immL32_rule, // 357
  _LoadL_memory__rule, // 358
  immL0_rule, // 359
  immL0_rule, // 360
  immL0_rule, // 361
  immL0_rule, // 362
  immP0_rule, // 363
  rRegP_rule, // 364
  rax_RegP_rule, // 365
  0, // 366
  0, // 367
  0, // 368
  0, // 369
  0, // 370
  0, // 371
  0, // 372
  0, // 373
  immI_24_rule, // 374
  0, // 375
  0, // 376
  immI_24_rule, // 377
  0, // 378
  0, // 379
  0, // 380
  0, // 381
  immI_24_rule, // 382
  immI_255_rule, // 383
  immI_16_rule, // 384
  immI_65535_rule, // 385
  0, // 386
  0, // 387
  0, // 388
  0, // 389
  0, // 390
  0, // 391
  0, // 392
  0, // 393
  0, // 394
  0, // 395
  0, // 396
  0, // 397
  0, // 398
  0, // 399
  0, // 400
  0, // 401
  0, // 402
  0, // 403
  0, // 404
  0, // 405
  0, // 406
  0, // 407
  0, // 408
  0, // 409
  0, // 410
  0, // 411
  0, // 412
  rRegI_rule, // 413
  rRegI_rule, // 414
  rRegI_rule, // 415
  rRegL_rule, // 416
  any_RegP_rule, // 417
  immP0_rule, // 418
  immP31_rule, // 419
  rRegN_rule, // 420
  immN0_rule, // 421
  immN_rule, // 422
  immI0_rule, // 423
  immI_rule, // 424
  immL0_rule, // 425
  immL32_rule, // 426
  immI0_rule, // 427
  immI16_rule, // 428
  immI0_rule, // 429
  immI8_rule, // 430
  regD_rule, // 431
  regD_rule, // 432
  regD_rule, // 433
  immI0_rule, // 434
  immI0_rule, // 435
  regD_rule, // 436
  regF_rule, // 437
  immF0_rule, // 438
  immF_rule, // 439
  regD_rule, // 440
  immD0_rule, // 441
  immD0_rule, // 442
  0, // 443
  0, // 444
  0, // 445
  0, // 446
  0, // 447
  0, // 448
  0, // 449
  0, // 450
  0, // 451
  0, // 452
  0, // 453
  0, // 454
  0, // 455
  0, // 456
  0, // 457
  0, // 458
  0, // 459
  0, // 460
  0, // 461
  0, // 462
  0, // 463
  0, // 464
  _Binary_rRegI_rRegI_rule, // 465
  _Binary_rRegI_rRegI_rule, // 466
  _Binary_rRegI_rRegI_rule, // 467
  _Binary_rRegI__LoadI_memory__rule, // 468
  _Binary_rRegI__LoadI_memory__rule, // 469
  _Binary_rRegI__LoadI_memory__rule, // 470
  _Binary_rRegN_rRegN_rule, // 471
  _Binary_rRegN_rRegN_rule, // 472
  _Binary_rRegN_rRegN_rule, // 473
  _Binary_rRegP_rRegP_rule, // 474
  _Binary_rRegP_rRegP_rule, // 475
  _Binary_rRegP_rRegP_rule, // 476
  _Binary_rRegL_rRegL_rule, // 477
  _Binary_rRegL__LoadL_memory__rule, // 478
  _Binary_rRegL_rRegL_rule, // 479
  _Binary_rRegL_rRegL_rule, // 480
  _Binary_rRegL__LoadL_memory__rule, // 481
  _Binary_rRegL__LoadL_memory__rule, // 482
  _Binary_regF_regF_rule, // 483
  _Binary_regF_regF_rule, // 484
  _Binary_regF_regF_rule, // 485
  _Binary_regD_regD_rule, // 486
  _Binary_regD_regD_rule, // 487
  _Binary_regD_regD_rule, // 488
  rRegI_rule, // 489
  immI_rule, // 490
  _LoadI_memory__rule, // 491
  rRegI_rule, // 492
  _AddI__LoadI_memory__rRegI_rule, // 493
  _AddI_rRegI__LoadI_memory__rule, // 494
  _AddI__LoadI_memory__immI_rule, // 495
  immI1_rule, // 496
  _AddI__LoadI_memory__immI1_rule, // 497
  immI_M1_rule, // 498
  _AddI__LoadI_memory__immI_M1_rule, // 499
  immI_rule, // 500
  rRegL_rule, // 501
  immL32_rule, // 502
  _LoadL_memory__rule, // 503
  rRegL_rule, // 504
  _AddL__LoadL_memory__rRegL_rule, // 505
  _AddL_rRegL__LoadL_memory__rule, // 506
  _AddL__LoadL_memory__immL32_rule, // 507
  immL1_rule, // 508
  _AddL__LoadL_memory__immL1_rule, // 509
  immL_M1_rule, // 510
  _AddL__LoadL_memory__immL_M1_rule, // 511
  immL32_rule, // 512
  rRegL_rule, // 513
  immL32_rule, // 514
  immL32_rule, // 515
  0, // 516
  0, // 517
  _Binary_rax_RegP_rRegP_rule, // 518
  _Binary_rax_RegL_rRegL_rule, // 519
  _Binary_rax_RegI_rRegI_rule, // 520
  _Binary_rax_RegN_rRegN_rule, // 521
  rRegI_rule, // 522
  immI_rule, // 523
  _LoadI_memory__rule, // 524
  _SubI__LoadI_memory__rRegI_rule, // 525
  _SubI__LoadI_memory__immI_rule, // 526
  rRegL_rule, // 527
  immL32_rule, // 528
  _LoadL_memory__rule, // 529
  _SubL__LoadL_memory__rRegL_rule, // 530
  _SubL__LoadL_memory__immL32_rule, // 531
  _SubI_immI0_rRegI_rule, // 532
  rRegI_rule, // 533
  _SubI_immI0__LoadI_memory__rule, // 534
  rRegL_rule, // 535
  _SubL_immL0__LoadL_memory__rule, // 536
  rRegI_rule, // 537
  immI_rule, // 538
  _LoadI_memory__rule, // 539
  rRegI_rule, // 540
  immI_rule, // 541
  rRegL_rule, // 542
  immL32_rule, // 543
  _LoadL_memory__rule, // 544
  rRegL_rule, // 545
  immL32_rule, // 546
  rax_RegL_rule, // 547
  no_rax_rdx_RegI_rule, // 548
  no_rax_rdx_RegL_rule, // 549
  no_rax_rdx_RegI_rule, // 550
  no_rax_rdx_RegL_rule, // 551
  0, // 552
  0, // 553
  0, // 554
  0, // 555
  immL10_rule, // 556
  no_rax_rdx_RegI_rule, // 557
  no_rax_rdx_RegL_rule, // 558
  immI1_rule, // 559
  _LShiftI__LoadI_memory__immI1_rule, // 560
  immI8_rule, // 561
  _LShiftI__LoadI_memory__immI8_rule, // 562
  rcx_RegI_rule, // 563
  _LShiftI__LoadI_memory__rcx_RegI_rule, // 564
  immI1_rule, // 565
  _RShiftI__LoadI_memory__immI1_rule, // 566
  immI8_rule, // 567
  _RShiftI__LoadI_memory__immI8_rule, // 568
  rcx_RegI_rule, // 569
  _RShiftI__LoadI_memory__rcx_RegI_rule, // 570
  immI1_rule, // 571
  _URShiftI__LoadI_memory__immI1_rule, // 572
  immI8_rule, // 573
  _URShiftI__LoadI_memory__immI8_rule, // 574
  rcx_RegI_rule, // 575
  _URShiftI__LoadI_memory__rcx_RegI_rule, // 576
  immI1_rule, // 577
  _LShiftL__LoadL_memory__immI1_rule, // 578
  immI8_rule, // 579
  _LShiftL__LoadL_memory__immI8_rule, // 580
  rcx_RegI_rule, // 581
  _LShiftL__LoadL_memory__rcx_RegI_rule, // 582
  immI1_rule, // 583
  _RShiftL__LoadL_memory__immI1_rule, // 584
  immI8_rule, // 585
  _RShiftL__LoadL_memory__immI8_rule, // 586
  rcx_RegI_rule, // 587
  _RShiftL__LoadL_memory__rcx_RegI_rule, // 588
  immI1_rule, // 589
  _URShiftL__LoadL_memory__immI1_rule, // 590
  immI8_rule, // 591
  _URShiftL__LoadL_memory__immI8_rule, // 592
  rcx_RegI_rule, // 593
  _URShiftL__LoadL_memory__rcx_RegI_rule, // 594
  immI_24_rule, // 595
  immI_16_rule, // 596
  0, // 597
  0, // 598
  0, // 599
  _URShiftI_rRegI_immI_M1_rule, // 600
  _LShiftI_rRegI_immI1_rule, // 601
  _URShiftI_rRegI_immI8_rule, // 602
  _LShiftI_rRegI_immI8_rule, // 603
  _URShiftI_no_rcx_RegI__SubI_immI0_rcx_RegI_rule, // 604
  _LShiftI_no_rcx_RegI_rcx_RegI_rule, // 605
  _URShiftI_no_rcx_RegI__SubI_immI_32_rcx_RegI_rule, // 606
  _LShiftI_no_rcx_RegI_rcx_RegI_rule, // 607
  0, // 608
  0, // 609
  0, // 610
  _LShiftI_rRegI_immI_M1_rule, // 611
  _URShiftI_rRegI_immI1_rule, // 612
  _LShiftI_rRegI_immI8_rule, // 613
  _URShiftI_rRegI_immI8_rule, // 614
  _LShiftI_no_rcx_RegI__SubI_immI0_rcx_RegI_rule, // 615
  _URShiftI_no_rcx_RegI_rcx_RegI_rule, // 616
  _LShiftI_no_rcx_RegI__SubI_immI_32_rcx_RegI_rule, // 617
  _URShiftI_no_rcx_RegI_rcx_RegI_rule, // 618
  0, // 619
  0, // 620
  0, // 621
  _URShiftL_rRegL_immI_M1_rule, // 622
  _LShiftL_rRegL_immI1_rule, // 623
  _URShiftL_rRegL_immI8_rule, // 624
  _LShiftL_rRegL_immI8_rule, // 625
  _URShiftL_no_rcx_RegL__SubI_immI0_rcx_RegI_rule, // 626
  _LShiftL_no_rcx_RegL_rcx_RegI_rule, // 627
  _URShiftL_no_rcx_RegL__SubI_immI_64_rcx_RegI_rule, // 628
  _LShiftL_no_rcx_RegL_rcx_RegI_rule, // 629
  0, // 630
  0, // 631
  0, // 632
  _LShiftL_rRegL_immI_M1_rule, // 633
  _URShiftL_rRegL_immI1_rule, // 634
  _LShiftL_rRegL_immI8_rule, // 635
  _URShiftL_rRegL_immI8_rule, // 636
  _LShiftL_no_rcx_RegL__SubI_immI0_rcx_RegI_rule, // 637
  _URShiftL_no_rcx_RegL_rcx_RegI_rule, // 638
  _LShiftL_no_rcx_RegL__SubI_immI_64_rcx_RegI_rule, // 639
  _URShiftL_no_rcx_RegL_rcx_RegI_rule, // 640
  rRegI_rule, // 641
  immI_255_rule, // 642
  0, // 643
  immI_65535_rule, // 644
  0, // 645
  immI_rule, // 646
  _LoadI_memory__rule, // 647
  rRegI_rule, // 648
  _AndI__LoadI_memory__rRegI_rule, // 649
  _AndI_rRegI__LoadI_memory__rule, // 650
  _AndI__LoadI_memory__immI_rule, // 651
  rRegI_rule, // 652
  immI_rule, // 653
  _LoadI_memory__rule, // 654
  rRegI_rule, // 655
  _OrI__LoadI_memory__rRegI_rule, // 656
  _OrI_rRegI__LoadI_memory__rule, // 657
  _OrI__LoadI_memory__immI_rule, // 658
  rRegI_rule, // 659
  immI_M1_rule, // 660
  immI_rule, // 661
  _LoadI_memory__rule, // 662
  rRegI_rule, // 663
  _XorI__LoadI_memory__rRegI_rule, // 664
  _XorI_rRegI__LoadI_memory__rule, // 665
  _XorI__LoadI_memory__immI_rule, // 666
  rRegL_rule, // 667
  immL_255_rule, // 668
  immL_65535_rule, // 669
  immL32_rule, // 670
  _LoadL_memory__rule, // 671
  rRegL_rule, // 672
  _AndL__LoadL_memory__rRegL_rule, // 673
  _AndL_rRegL__LoadL_memory__rule, // 674
  _AndL__LoadL_memory__immL32_rule, // 675
  rRegL_rule, // 676
  _CastP2X_any_RegP__rule, // 677
  rRegL_rule, // 678
  immL32_rule, // 679
  _LoadL_memory__rule, // 680
  rRegL_rule, // 681
  _OrL__LoadL_memory__rRegL_rule, // 682
  _OrL_rRegL__LoadL_memory__rule, // 683
  _OrL__LoadL_memory__immL32_rule, // 684
  rRegL_rule, // 685
  immL_M1_rule, // 686
  immL32_rule, // 687
  _LoadL_memory__rule, // 688
  rRegL_rule, // 689
  _XorL__LoadL_memory__rRegL_rule, // 690
  _XorL_rRegL__LoadL_memory__rule, // 691
  _XorL__LoadL_memory__immL32_rule, // 692
  0, // 693
  0, // 694
  rRegI_rule, // 695
  immI0_rule, // 696
  _SubI_rRegI_rRegI_rule, // 697
  _AndI__CmpLTMask_rRegI_rRegI_rRegI_rule, // 698
  _SubI_rRegI_rRegI_rule, // 699
  _AndI_rRegI__CmpLTMask_rRegI_rRegI_rule, // 700
  regF_rule, // 701
  _LoadF_memory__rule, // 702
  immF_rule, // 703
  regD_rule, // 704
  _LoadD_memory__rule, // 705
  immD_rule, // 706
  regF_rule, // 707
  _LoadF_memory__rule, // 708
  regF_rule, // 709
  immF_rule, // 710
  regD_rule, // 711
  _LoadD_memory__rule, // 712
  regD_rule, // 713
  immD_rule, // 714
  regF_rule, // 715
  _LoadF_memory__rule, // 716
  immF_rule, // 717
  regD_rule, // 718
  _LoadD_memory__rule, // 719
  immD_rule, // 720
  regF_rule, // 721
  _LoadF_memory__rule, // 722
  regF_rule, // 723
  immF_rule, // 724
  regD_rule, // 725
  _LoadD_memory__rule, // 726
  regD_rule, // 727
  immD_rule, // 728
  regF_rule, // 729
  _LoadF_memory__rule, // 730
  immF_rule, // 731
  regD_rule, // 732
  _LoadD_memory__rule, // 733
  immD_rule, // 734
  0, // 735
  0, // 736
  0, // 737
  0, // 738
  0, // 739
  0, // 740
  0, // 741
  0, // 742
  0, // 743
  0, // 744
  0, // 745
  0, // 746
  0, // 747
  0, // 748
  0, // 749
  0, // 750
  0, // 751
  0, // 752
  0, // 753
  0, // 754
  0, // 755
  0, // 756
  0, // 757
  0, // 758
  0, // 759
  0, // 760
  0, // 761
  0, // 762
  0, // 763
  0, // 764
  immL_32bits_rule, // 765
  immL_32bits_rule, // 766
  immL_32bits_rule, // 767
  0, // 768
  0, // 769
  0, // 770
  0, // 771
  0, // 772
  0, // 773
  0, // 774
  0, // 775
  0, // 776
  0, // 777
  0, // 778
  0, // 779
  0, // 780
  0, // 781
  0, // 782
  0, // 783
  0, // 784
  0, // 785
  0, // 786
  0, // 787
  rdi_RegP_rule, // 788
  _Binary_rsi_RegP_rdx_RegI_rule, // 789
  _Binary_rsi_RegP_immI_rule, // 790
  _Binary_rsi_RegP_rax_RegI_rule, // 791
  rcx_RegI_rule, // 792
  rsi_RegP_rule, // 793
  rRegL_rule, // 794
  0, // 795
  rRegI_rule, // 796
  0, // 797
  rRegI_rule, // 798
  0, // 799
  rFlagsReg_rule, // 800
  rFlagsReg_rule, // 801
  rFlagsRegU_rule, // 802
  rFlagsRegUCF_rule, // 803
  rFlagsRegU_rule, // 804
  rFlagsRegUCF_rule, // 805
  rFlagsRegUCF_rule, // 806
  rax_RegP_rule, // 807
  0, // 808
  rFlagsReg_rule, // 809
  rFlagsReg_rule, // 810
  rFlagsRegU_rule, // 811
  rFlagsRegUCF_rule, // 812
  rFlagsRegU_rule, // 813
  rFlagsRegUCF_rule, // 814
  rFlagsRegUCF_rule, // 815
  0, // 816
  0, // 817
  0, // 818
  0, // 819
  0, // 820
  0, // 821
  0, // 822
  0, // 823
  rbx_RegP_rule, // 824
  rax_RegP_rule, // 825
  0, // 826
  0, // 827
  0, // 828
  // last instruction
  0 // no trailing comma
};

const char        *ruleName[] = {
  "UNIVERSE", // 0
  "LABEL", // 1
  "SREGI", // 2
  "SREGP", // 3
  "SREGF", // 4
  "SREGD", // 5
  "SREGL", // 6
  "METHOD", // 7
  "IMMI", // 8
  "IMMI0", // 9
  "IMMI1", // 10
  "IMMI_M1", // 11
  "IMMI2", // 12
  "IMMI8", // 13
  "IMMI16", // 14
  "IMMI_32", // 15
  "IMMI_64", // 16
  "IMMP", // 17
  "IMMP0", // 18
  "IMMP_POLL", // 19
  "IMMN", // 20
  "IMMN0", // 21
  "IMMP31", // 22
  "IMML", // 23
  "IMML8", // 24
  "IMMUL32", // 25
  "IMML32", // 26
  "IMML0", // 27
  "IMML1", // 28
  "IMML_M1", // 29
  "IMML10", // 30
  "IMML_127", // 31
  "IMML_32BITS", // 32
  "IMMF0", // 33
  "IMMF", // 34
  "IMMD0", // 35
  "IMMD", // 36
  "IMMI_16", // 37
  "IMMI_24", // 38
  "IMMI_255", // 39
  "IMMI_65535", // 40
  "IMML_255", // 41
  "IMML_65535", // 42
  "RREGI", // 43
  "RAX_REGI", // 44
  "RBX_REGI", // 45
  "RCX_REGI", // 46
  "RDX_REGI", // 47
  "RDI_REGI", // 48
  "NO_RCX_REGI", // 49
  "NO_RAX_RDX_REGI", // 50
  "ANY_REGP", // 51
  "RREGP", // 52
  "RREGN", // 53
  "NO_RAX_REGP", // 54
  "NO_RBP_REGP", // 55
  "NO_RAX_RBX_REGP", // 56
  "RAX_REGP", // 57
  "RAX_REGN", // 58
  "RBX_REGP", // 59
  "RSI_REGP", // 60
  "RDI_REGP", // 61
  "RBP_REGP", // 62
  "R15_REGP", // 63
  "RREGL", // 64
  "NO_RAX_RDX_REGL", // 65
  "NO_RAX_REGL", // 66
  "NO_RCX_REGL", // 67
  "RAX_REGL", // 68
  "RCX_REGL", // 69
  "RDX_REGL", // 70
  "RFLAGSREG", // 71
  "RFLAGSREGU", // 72
  "RFLAGSREGUCF", // 73
  "REGF", // 74
  "REGD", // 75
  "INDIRECT", // 76
  "INDOFFSET8", // 77
  "INDOFFSET32", // 78
  "INDINDEXOFFSET", // 79
  "INDINDEX", // 80
  "INDINDEXSCALE", // 81
  "INDINDEXSCALEOFFSET", // 82
  "INDPOSINDEXSCALEOFFSET", // 83
  "INDCOMPRESSEDOOPOFFSET", // 84
  "INDIRECTNARROW", // 85
  "INDOFFSET8NARROW", // 86
  "INDOFFSET32NARROW", // 87
  "INDINDEXOFFSETNARROW", // 88
  "INDINDEXNARROW", // 89
  "INDINDEXSCALENARROW", // 90
  "INDINDEXSCALEOFFSETNARROW", // 91
  "INDPOSINDEXSCALEOFFSETNARROW", // 92
  "STACKSLOTP", // 93
  "STACKSLOTI", // 94
  "STACKSLOTF", // 95
  "STACKSLOTD", // 96
  "STACKSLOTL", // 97
  "CMPOP", // 98
  "CMPOPU", // 99
  "CMPOPUCF", // 100
  "CMPOPUCF2", // 101
  // last operand
  "MEMORY", // 102
  // last operand class
  "_AddP_any_RegP_rRegL", // 103
  "_LShiftL_rRegL_immI2", // 104
  "_AddP_any_RegP__LShiftL_rRegL_immI2", // 105
  "_ConvI2L_rRegI_", // 106
  "_LShiftL__ConvI2L_rRegI__immI2", // 107
  "_AddP_any_RegP__LShiftL__ConvI2L_rRegI__immI2", // 108
  "_DecodeN_rRegN_", // 109
  "_AddP__DecodeN_rRegN__rRegL", // 110
  "_AddP__DecodeN_rRegN___LShiftL_rRegL_immI2", // 111
  "_AddP__DecodeN_rRegN___LShiftL__ConvI2L_rRegI__immI2", // 112
  "_LoadB_memory_", // 113
  "_LoadUB_memory_", // 114
  "_AndI__LoadUB_memory__immI8", // 115
  "_LoadS_memory_", // 116
  "_LShiftI__LoadS_memory__immI_24", // 117
  "_LoadUS_memory_", // 118
  "_LShiftI__LoadUS_memory__immI_24", // 119
  "_AndI__LoadUS_memory__immI_255", // 120
  "_AndI__LoadUS_memory__immI16", // 121
  "_LoadI_memory_", // 122
  "_LShiftI__LoadI_memory__immI_24", // 123
  "_LShiftI__LoadI_memory__immI_16", // 124
  "_AndI__LoadI_memory__immI_255", // 125
  "_AndI__LoadI_memory__immI_65535", // 126
  "_AndI__LoadI_memory__immI", // 127
  "_LoadL_memory_", // 128
  "_AddL__LShiftL_rRegL_immI2_immL32", // 129
  "_Binary_cmpOp_rFlagsReg", // 130
  "_Binary_rRegI_rRegI", // 131
  "_Binary_cmpOpU_rFlagsRegU", // 132
  "_Binary_cmpOpUCF_rFlagsRegUCF", // 133
  "_Binary_rRegI__LoadI_memory_", // 134
  "_Binary_rRegN_rRegN", // 135
  "_Binary_rRegP_rRegP", // 136
  "_Binary_rRegL_rRegL", // 137
  "_Binary_rRegL__LoadL_memory_", // 138
  "_Binary_regF_regF", // 139
  "_Binary_regD_regD", // 140
  "_AddI__LoadI_memory__rRegI", // 141
  "_AddI_rRegI__LoadI_memory_", // 142
  "_AddI__LoadI_memory__immI", // 143
  "_AddI__LoadI_memory__immI1", // 144
  "_AddI__LoadI_memory__immI_M1", // 145
  "_AddL__LoadL_memory__rRegL", // 146
  "_AddL_rRegL__LoadL_memory_", // 147
  "_AddL__LoadL_memory__immL32", // 148
  "_AddL__LoadL_memory__immL1", // 149
  "_AddL__LoadL_memory__immL_M1", // 150
  "_Binary_rax_RegP_rRegP", // 151
  "_Binary_rax_RegI_rRegI", // 152
  "_Binary_rax_RegL_rRegL", // 153
  "_Binary_rax_RegN_rRegN", // 154
  "_SubI__LoadI_memory__rRegI", // 155
  "_SubI__LoadI_memory__immI", // 156
  "_SubL__LoadL_memory__rRegL", // 157
  "_SubL__LoadL_memory__immL32", // 158
  "_SubI_immI0_rRegI", // 159
  "_SubI_immI0__LoadI_memory_", // 160
  "_SubL_immL0__LoadL_memory_", // 161
  "_LShiftI__LoadI_memory__immI1", // 162
  "_LShiftI__LoadI_memory__immI8", // 163
  "_LShiftI__LoadI_memory__rcx_RegI", // 164
  "_RShiftI__LoadI_memory__immI1", // 165
  "_RShiftI__LoadI_memory__immI8", // 166
  "_RShiftI__LoadI_memory__rcx_RegI", // 167
  "_URShiftI__LoadI_memory__immI1", // 168
  "_URShiftI__LoadI_memory__immI8", // 169
  "_URShiftI__LoadI_memory__rcx_RegI", // 170
  "_LShiftL__LoadL_memory__immI1", // 171
  "_LShiftL__LoadL_memory__immI8", // 172
  "_LShiftL__LoadL_memory__rcx_RegI", // 173
  "_RShiftL__LoadL_memory__immI1", // 174
  "_RShiftL__LoadL_memory__immI8", // 175
  "_RShiftL__LoadL_memory__rcx_RegI", // 176
  "_URShiftL__LoadL_memory__immI1", // 177
  "_URShiftL__LoadL_memory__immI8", // 178
  "_URShiftL__LoadL_memory__rcx_RegI", // 179
  "_LShiftI_rRegI_immI_24", // 180
  "_LShiftI_rRegI_immI_16", // 181
  "_LShiftI_rRegI_immI1", // 182
  "_URShiftI_rRegI_immI_M1", // 183
  "_LShiftI_rRegI_immI8", // 184
  "_URShiftI_rRegI_immI8", // 185
  "_LShiftI_no_rcx_RegI_rcx_RegI", // 186
  "_SubI_immI0_rcx_RegI", // 187
  "_URShiftI_no_rcx_RegI__SubI_immI0_rcx_RegI", // 188
  "_SubI_immI_32_rcx_RegI", // 189
  "_URShiftI_no_rcx_RegI__SubI_immI_32_rcx_RegI", // 190
  "_URShiftI_rRegI_immI1", // 191
  "_LShiftI_rRegI_immI_M1", // 192
  "_URShiftI_no_rcx_RegI_rcx_RegI", // 193
  "_LShiftI_no_rcx_RegI__SubI_immI0_rcx_RegI", // 194
  "_LShiftI_no_rcx_RegI__SubI_immI_32_rcx_RegI", // 195
  "_LShiftL_rRegL_immI1", // 196
  "_URShiftL_rRegL_immI_M1", // 197
  "_LShiftL_rRegL_immI8", // 198
  "_URShiftL_rRegL_immI8", // 199
  "_LShiftL_no_rcx_RegL_rcx_RegI", // 200
  "_URShiftL_no_rcx_RegL__SubI_immI0_rcx_RegI", // 201
  "_SubI_immI_64_rcx_RegI", // 202
  "_URShiftL_no_rcx_RegL__SubI_immI_64_rcx_RegI", // 203
  "_URShiftL_rRegL_immI1", // 204
  "_LShiftL_rRegL_immI_M1", // 205
  "_URShiftL_no_rcx_RegL_rcx_RegI", // 206
  "_LShiftL_no_rcx_RegL__SubI_immI0_rcx_RegI", // 207
  "_LShiftL_no_rcx_RegL__SubI_immI_64_rcx_RegI", // 208
  "_AndI_rRegI_immI_255", // 209
  "_AndI_rRegI_immI_65535", // 210
  "_AndI__LoadI_memory__rRegI", // 211
  "_AndI_rRegI__LoadI_memory_", // 212
  "_OrI__LoadI_memory__rRegI", // 213
  "_OrI_rRegI__LoadI_memory_", // 214
  "_OrI__LoadI_memory__immI", // 215
  "_XorI__LoadI_memory__rRegI", // 216
  "_XorI_rRegI__LoadI_memory_", // 217
  "_XorI__LoadI_memory__immI", // 218
  "_AndL__LoadL_memory__rRegL", // 219
  "_AndL_rRegL__LoadL_memory_", // 220
  "_AndL__LoadL_memory__immL32", // 221
  "_CastP2X_any_RegP_", // 222
  "_OrL__LoadL_memory__rRegL", // 223
  "_OrL_rRegL__LoadL_memory_", // 224
  "_OrL__LoadL_memory__immL32", // 225
  "_XorL__LoadL_memory__rRegL", // 226
  "_XorL_rRegL__LoadL_memory_", // 227
  "_XorL__LoadL_memory__immL32", // 228
  "_CmpLTMask_rRegI_rRegI", // 229
  "_AndI__CmpLTMask_rRegI_rRegI_rRegI", // 230
  "_SubI_rRegI_rRegI", // 231
  "_AndI_rRegI__CmpLTMask_rRegI_rRegI", // 232
  "_LoadF_memory_", // 233
  "_LoadD_memory_", // 234
  "_ConvF2D_regF_", // 235
  "_SqrtD__ConvF2D_regF__", // 236
  "_ConvF2D__LoadF_memory__", // 237
  "_SqrtD__ConvF2D__LoadF_memory___", // 238
  "_ConvF2D_immF_", // 239
  "_SqrtD__ConvF2D_immF__", // 240
  "_ConvI2L__LoadI_memory__", // 241
  "_Binary_rdi_RegP_rcx_RegI", // 242
  "_Binary_rsi_RegP_rdx_RegI", // 243
  "_Binary_rdi_RegP_rdx_RegI", // 244
  "_Binary_rsi_RegP_immI", // 245
  "_Binary_rsi_RegP_rax_RegI", // 246
  "_Binary_rdi_RegP_rsi_RegP", // 247
  "_AndI_rRegI_immI", // 248
  "_LoadP_memory_", // 249
  "_LoadN_memory_", // 250
  "_AndL_rRegL_immL32", // 251
  "_PartialSubtypeCheck_rsi_RegP_rax_RegP", // 252
  // last internally defined operand
  "storeSSI", // 253
  "storeSSL", // 254
  "storeSSP", // 255
  "storeSSF", // 256
  "storeSSD", // 257
  "leaP8", // 258
  "leaP32", // 259
  "leaPIdxOff", // 260
  "leaPIdxScale", // 261
  "leaPIdxScaleOff", // 262
  "leaPPosIdxScaleOff", // 263
  "leaPCompressedOopOffset", // 264
  "leaP8Narrow", // 265
  "leaP32Narrow", // 266
  "leaPIdxOffNarrow", // 267
  "leaPIdxScaleNarrow", // 268
  "leaPIdxScaleOffNarrow", // 269
  "leaPPosIdxScaleOffNarrow", // 270
  "loadConI", // 271
  "loadConI0", // 272
  "loadConL", // 273
  "loadConL0", // 274
  "loadConUL32", // 275
  "loadConL32", // 276
  "loadConP", // 277
  "loadConP0", // 278
  "loadConP_poll", // 279
  "loadConP31", // 280
  "loadConF", // 281
  "loadConN0", // 282
  "loadConN", // 283
  "loadConF0", // 284
  "loadConD", // 285
  "loadConD0", // 286
  "loadSSI", // 287
  "loadSSL", // 288
  "loadSSP", // 289
  "loadSSF", // 290
  "loadSSD", // 291
  "popCountI", // 292
  "popCountI_mem", // 293
  "popCountL", // 294
  "popCountL_mem", // 295
  "membar_volatile", // 296
  "castX2P", // 297
  "castP2X", // 298
  "checkCastPP", // 299
  "castPP", // 300
  "castII", // 301
  "storePConditional", // 302
  "storeIConditional", // 303
  "storeLConditional", // 304
  "cmpF_cc_reg", // 305
  "cmpF_cc_reg_CF", // 306
  "cmpF_cc_mem", // 307
  "cmpF_cc_memCF", // 308
  "cmpF_cc_imm", // 309
  "cmpF_cc_immCF", // 310
  "cmpD_cc_reg", // 311
  "cmpD_cc_reg_CF", // 312
  "cmpD_cc_mem", // 313
  "cmpD_cc_memCF", // 314
  "cmpD_cc_imm", // 315
  "cmpD_cc_immCF", // 316
  "absF_reg", // 317
  "absD_reg", // 318
  "negF_reg", // 319
  "negD_reg", // 320
  "roundFloat_nop", // 321
  "roundDouble_nop", // 322
  "MoveF2I_stack_reg", // 323
  "MoveI2F_stack_reg", // 324
  "MoveD2L_stack_reg", // 325
  "MoveL2D_stack_reg_partial", // 326
  "MoveL2D_stack_reg", // 327
  "MoveF2I_reg_reg", // 328
  "MoveD2L_reg_reg", // 329
  "MoveI2F_reg_reg", // 330
  "MoveL2D_reg_reg", // 331
  "compI_rReg", // 332
  "compI_rReg_imm", // 333
  "compI_rReg_mem", // 334
  "testI_reg", // 335
  "testI_reg_imm", // 336
  "testI_reg_mem", // 337
  "testI_reg_mem_0", // 338
  "compU_rReg", // 339
  "compU_rReg_imm", // 340
  "compU_rReg_mem", // 341
  "testU_reg", // 342
  "compP_rReg", // 343
  "compP_rReg_mem", // 344
  "compP_mem_rReg", // 345
  "testP_reg", // 346
  "testP_mem", // 347
  "testP_mem_reg0", // 348
  "compN_rReg", // 349
  "compN_rReg_mem", // 350
  "compN_rReg_imm", // 351
  "compN_mem_imm", // 352
  "testN_reg", // 353
  "testN_mem", // 354
  "testN_mem_reg0", // 355
  "compL_rReg", // 356
  "compL_rReg_imm", // 357
  "compL_rReg_mem", // 358
  "testL_reg", // 359
  "testL_reg_imm", // 360
  "testL_reg_mem", // 361
  "testL_reg_mem_0", // 362
  "partialSubtypeCheck_vs_Zero", // 363
  "cmpFastLock", // 364
  "cmpFastUnlock", // 365
  "safePoint_poll", // 366
  "tlsLoadP", // 367
  "loadB", // 368
  "loadB2L", // 369
  "loadUB", // 370
  "loadUB2L", // 371
  "loadUB2L_immI8", // 372
  "loadS", // 373
  "loadS2B", // 374
  "loadS2L", // 375
  "loadUS", // 376
  "loadUS2B", // 377
  "loadUS2L", // 378
  "loadUS2L_immI_255", // 379
  "loadUS2L_immI16", // 380
  "loadI", // 381
  "loadI2B", // 382
  "loadI2UB", // 383
  "loadI2S", // 384
  "loadI2US", // 385
  "loadI2L", // 386
  "loadI2L_immI_255", // 387
  "loadI2L_immI_65535", // 388
  "loadI2L_immI", // 389
  "loadUI2L", // 390
  "loadL", // 391
  "loadRange", // 392
  "loadP", // 393
  "loadN", // 394
  "loadKlass", // 395
  "loadNKlass", // 396
  "loadF", // 397
  "loadD_partial", // 398
  "loadD", // 399
  "loadA8B", // 400
  "loadA4S", // 401
  "loadA4C", // 402
  "load2IU", // 403
  "loadA2F", // 404
  "prefetchr", // 405
  "prefetchrNTA", // 406
  "prefetchrT0", // 407
  "prefetchrT2", // 408
  "prefetchw", // 409
  "prefetchwNTA", // 410
  "prefetchwT0", // 411
  "prefetchwT2", // 412
  "storeB", // 413
  "storeC", // 414
  "storeI", // 415
  "storeL", // 416
  "storeP", // 417
  "storeImmP0", // 418
  "storeImmP", // 419
  "storeN", // 420
  "storeImmN0", // 421
  "storeImmN", // 422
  "storeImmI0", // 423
  "storeImmI", // 424
  "storeImmL0", // 425
  "storeImmL", // 426
  "storeImmC0", // 427
  "storeImmI16", // 428
  "storeImmB0", // 429
  "storeImmB", // 430
  "storeA8B", // 431
  "storeA4C", // 432
  "storeA2I", // 433
  "storeImmCM0_reg", // 434
  "storeImmCM0", // 435
  "storeA2F", // 436
  "storeF", // 437
  "storeF0", // 438
  "storeF_imm", // 439
  "storeD", // 440
  "storeD0_imm", // 441
  "storeD0", // 442
  "bytes_reverse_int", // 443
  "bytes_reverse_long", // 444
  "bytes_reverse_unsigned_short", // 445
  "bytes_reverse_short", // 446
  "countLeadingZerosI", // 447
  "countLeadingZerosI_bsr", // 448
  "countLeadingZerosL", // 449
  "countLeadingZerosL_bsr", // 450
  "countTrailingZerosI", // 451
  "countTrailingZerosL", // 452
  "membar_acquire", // 453
  "membar_acquire_lock", // 454
  "membar_release", // 455
  "membar_release_lock", // 456
  "unnecessary_membar_volatile", // 457
  "encodeHeapOop", // 458
  "encodeHeapOop_not_null", // 459
  "decodeHeapOop", // 460
  "decodeHeapOop_not_null", // 461
  "jumpXtnd_offset", // 462
  "jumpXtnd_addr", // 463
  "jumpXtnd", // 464
  "cmovI_reg", // 465
  "cmovI_regU", // 466
  "cmovI_regUCF", // 467
  "cmovI_mem", // 468
  "cmovI_memU", // 469
  "cmovI_memUCF", // 470
  "cmovN_reg", // 471
  "cmovN_regU", // 472
  "cmovN_regUCF", // 473
  "cmovP_reg", // 474
  "cmovP_regU", // 475
  "cmovP_regUCF", // 476
  "cmovL_reg", // 477
  "cmovL_mem", // 478
  "cmovL_regU", // 479
  "cmovL_regUCF", // 480
  "cmovL_memU", // 481
  "cmovL_memUCF", // 482
  "cmovF_reg", // 483
  "cmovF_regU", // 484
  "cmovF_regUCF", // 485
  "cmovD_reg", // 486
  "cmovD_regU", // 487
  "cmovD_regUCF", // 488
  "addI_rReg", // 489
  "addI_rReg_imm", // 490
  "addI_rReg_mem", // 491
  "addI_rReg_mem_0", // 492
  "addI_mem_rReg", // 493
  "addI_mem_rReg_0", // 494
  "addI_mem_imm", // 495
  "incI_rReg", // 496
  "incI_mem", // 497
  "decI_rReg", // 498
  "decI_mem", // 499
  "leaI_rReg_immI", // 500
  "addL_rReg", // 501
  "addL_rReg_imm", // 502
  "addL_rReg_mem", // 503
  "addL_rReg_mem_0", // 504
  "addL_mem_rReg", // 505
  "addL_mem_rReg_0", // 506
  "addL_mem_imm", // 507
  "incL_rReg", // 508
  "incL_mem", // 509
  "decL_rReg", // 510
  "decL_mem", // 511
  "leaL_rReg_immL", // 512
  "addP_rReg", // 513
  "addP_rReg_imm", // 514
  "leaP_rReg_imm", // 515
  "loadPLocked", // 516
  "loadLLocked", // 517
  "compareAndSwapP", // 518
  "compareAndSwapL", // 519
  "compareAndSwapI", // 520
  "compareAndSwapN", // 521
  "subI_rReg", // 522
  "subI_rReg_imm", // 523
  "subI_rReg_mem", // 524
  "subI_mem_rReg", // 525
  "subI_mem_imm", // 526
  "subL_rReg", // 527
  "subL_rReg_imm", // 528
  "subL_rReg_mem", // 529
  "subL_mem_rReg", // 530
  "subL_mem_imm", // 531
  "subP_rReg", // 532
  "negI_rReg", // 533
  "negI_mem", // 534
  "negL_rReg", // 535
  "negL_mem", // 536
  "mulI_rReg", // 537
  "mulI_rReg_imm", // 538
  "mulI_mem", // 539
  "mulI_mem_0", // 540
  "mulI_mem_imm", // 541
  "mulL_rReg", // 542
  "mulL_rReg_imm", // 543
  "mulL_mem", // 544
  "mulL_mem_0", // 545
  "mulL_mem_imm", // 546
  "mulHiL_rReg", // 547
  "divI_rReg", // 548
  "divL_rReg", // 549
  "divModI_rReg_divmod", // 550
  "divModL_rReg_divmod", // 551
  "loadConL_0x6666666666666667", // 552
  "mul_hi", // 553
  "sarL_rReg_63", // 554
  "sarL_rReg_2", // 555
  "divL_10", // 556
  "modI_rReg", // 557
  "modL_rReg", // 558
  "salI_rReg_1", // 559
  "salI_mem_1", // 560
  "salI_rReg_imm", // 561
  "salI_mem_imm", // 562
  "salI_rReg_CL", // 563
  "salI_mem_CL", // 564
  "sarI_rReg_1", // 565
  "sarI_mem_1", // 566
  "sarI_rReg_imm", // 567
  "sarI_mem_imm", // 568
  "sarI_rReg_CL", // 569
  "sarI_mem_CL", // 570
  "shrI_rReg_1", // 571
  "shrI_mem_1", // 572
  "shrI_rReg_imm", // 573
  "shrI_mem_imm", // 574
  "shrI_rReg_CL", // 575
  "shrI_mem_CL", // 576
  "salL_rReg_1", // 577
  "salL_mem_1", // 578
  "salL_rReg_imm", // 579
  "salL_mem_imm", // 580
  "salL_rReg_CL", // 581
  "salL_mem_CL", // 582
  "sarL_rReg_1", // 583
  "sarL_mem_1", // 584
  "sarL_rReg_imm", // 585
  "sarL_mem_imm", // 586
  "sarL_rReg_CL", // 587
  "sarL_mem_CL", // 588
  "shrL_rReg_1", // 589
  "shrL_mem_1", // 590
  "shrL_rReg_imm", // 591
  "shrL_mem_imm", // 592
  "shrL_rReg_CL", // 593
  "shrL_mem_CL", // 594
  "i2b", // 595
  "i2s", // 596
  "rolI_rReg_imm1", // 597
  "rolI_rReg_imm8", // 598
  "rolI_rReg_CL", // 599
  "rolI_rReg_i1", // 600
  "rolI_rReg_i1_0", // 601
  "rolI_rReg_i8", // 602
  "rolI_rReg_i8_0", // 603
  "rolI_rReg_Var_C0", // 604
  "rolI_rReg_Var_C0_0", // 605
  "rolI_rReg_Var_C32", // 606
  "rolI_rReg_Var_C32_0", // 607
  "rorI_rReg_imm1", // 608
  "rorI_rReg_imm8", // 609
  "rorI_rReg_CL", // 610
  "rorI_rReg_i1", // 611
  "rorI_rReg_i1_0", // 612
  "rorI_rReg_i8", // 613
  "rorI_rReg_i8_0", // 614
  "rorI_rReg_Var_C0", // 615
  "rorI_rReg_Var_C0_0", // 616
  "rorI_rReg_Var_C32", // 617
  "rorI_rReg_Var_C32_0", // 618
  "rolL_rReg_imm1", // 619
  "rolL_rReg_imm8", // 620
  "rolL_rReg_CL", // 621
  "rolL_rReg_i1", // 622
  "rolL_rReg_i1_0", // 623
  "rolL_rReg_i8", // 624
  "rolL_rReg_i8_0", // 625
  "rolL_rReg_Var_C0", // 626
  "rolL_rReg_Var_C0_0", // 627
  "rolL_rReg_Var_C64", // 628
  "rolL_rReg_Var_C64_0", // 629
  "rorL_rReg_imm1", // 630
  "rorL_rReg_imm8", // 631
  "rorL_rReg_CL", // 632
  "rorL_rReg_i1", // 633
  "rorL_rReg_i1_0", // 634
  "rorL_rReg_i8", // 635
  "rorL_rReg_i8_0", // 636
  "rorL_rReg_Var_C0", // 637
  "rorL_rReg_Var_C0_0", // 638
  "rorL_rReg_Var_C64", // 639
  "rorL_rReg_Var_C64_0", // 640
  "andI_rReg", // 641
  "andI_rReg_imm255", // 642
  "andI2L_rReg_imm255", // 643
  "andI_rReg_imm65535", // 644
  "andI2L_rReg_imm65535", // 645
  "andI_rReg_imm", // 646
  "andI_rReg_mem", // 647
  "andI_rReg_mem_0", // 648
  "andI_mem_rReg", // 649
  "andI_mem_rReg_0", // 650
  "andI_mem_imm", // 651
  "orI_rReg", // 652
  "orI_rReg_imm", // 653
  "orI_rReg_mem", // 654
  "orI_rReg_mem_0", // 655
  "orI_mem_rReg", // 656
  "orI_mem_rReg_0", // 657
  "orI_mem_imm", // 658
  "xorI_rReg", // 659
  "xorI_rReg_im1", // 660
  "xorI_rReg_imm", // 661
  "xorI_rReg_mem", // 662
  "xorI_rReg_mem_0", // 663
  "xorI_mem_rReg", // 664
  "xorI_mem_rReg_0", // 665
  "xorI_mem_imm", // 666
  "andL_rReg", // 667
  "andL_rReg_imm255", // 668
  "andL_rReg_imm65535", // 669
  "andL_rReg_imm", // 670
  "andL_rReg_mem", // 671
  "andL_rReg_mem_0", // 672
  "andL_mem_rReg", // 673
  "andL_mem_rReg_0", // 674
  "andL_mem_imm", // 675
  "orL_rReg", // 676
  "orL_rReg_castP2X", // 677
  "orL_rReg_castP2X_0", // 678
  "orL_rReg_imm", // 679
  "orL_rReg_mem", // 680
  "orL_rReg_mem_0", // 681
  "orL_mem_rReg", // 682
  "orL_mem_rReg_0", // 683
  "orL_mem_imm", // 684
  "xorL_rReg", // 685
  "xorL_rReg_im1", // 686
  "xorL_rReg_imm", // 687
  "xorL_rReg_mem", // 688
  "xorL_rReg_mem_0", // 689
  "xorL_mem_rReg", // 690
  "xorL_mem_rReg_0", // 691
  "xorL_mem_imm", // 692
  "convI2B", // 693
  "convP2B", // 694
  "cmpLTMask", // 695
  "cmpLTMask0", // 696
  "cadd_cmpLTMask", // 697
  "cadd_cmpLTMask_1", // 698
  "cadd_cmpLTMask_0", // 699
  "cadd_cmpLTMask_2", // 700
  "cmpF_reg", // 701
  "cmpF_mem", // 702
  "cmpF_imm", // 703
  "cmpD_reg", // 704
  "cmpD_mem", // 705
  "cmpD_imm", // 706
  "addF_reg", // 707
  "addF_mem", // 708
  "addF_mem_0", // 709
  "addF_imm", // 710
  "addD_reg", // 711
  "addD_mem", // 712
  "addD_mem_0", // 713
  "addD_imm", // 714
  "subF_reg", // 715
  "subF_mem", // 716
  "subF_imm", // 717
  "subD_reg", // 718
  "subD_mem", // 719
  "subD_imm", // 720
  "mulF_reg", // 721
  "mulF_mem", // 722
  "mulF_mem_0", // 723
  "mulF_imm", // 724
  "mulD_reg", // 725
  "mulD_mem", // 726
  "mulD_mem_0", // 727
  "mulD_imm", // 728
  "divF_reg", // 729
  "divF_mem", // 730
  "divF_imm", // 731
  "divD_reg", // 732
  "divD_mem", // 733
  "divD_imm", // 734
  "sqrtF_reg", // 735
  "sqrtF_mem", // 736
  "sqrtF_imm", // 737
  "sqrtD_reg", // 738
  "sqrtD_mem", // 739
  "sqrtD_imm", // 740
  "cosD_reg", // 741
  "sinD_reg", // 742
  "tanD_reg", // 743
  "log10D_reg", // 744
  "logD_reg", // 745
  "convF2D_reg_reg", // 746
  "convF2D_reg_mem", // 747
  "convD2F_reg_reg", // 748
  "convD2F_reg_mem", // 749
  "convF2I_reg_reg", // 750
  "convF2L_reg_reg", // 751
  "convD2I_reg_reg", // 752
  "convD2L_reg_reg", // 753
  "convI2F_reg_reg", // 754
  "convI2F_reg_mem", // 755
  "convI2D_reg_reg", // 756
  "convI2D_reg_mem", // 757
  "convXI2F_reg", // 758
  "convXI2D_reg", // 759
  "convL2F_reg_reg", // 760
  "convL2F_reg_mem", // 761
  "convL2D_reg_reg", // 762
  "convL2D_reg_mem", // 763
  "convI2L_reg_reg", // 764
  "convI2L_reg_reg_zex", // 765
  "convI2L_reg_mem_zex", // 766
  "zerox_long_reg_reg", // 767
  "convL2I_reg_reg", // 768
  "MoveF2I_reg_stack", // 769
  "MoveI2F_reg_stack", // 770
  "MoveD2L_reg_stack", // 771
  "MoveL2D_reg_stack", // 772
  "Repl8B_reg", // 773
  "Repl8B_rRegI", // 774
  "Repl8B_immI0", // 775
  "Repl4S_reg", // 776
  "Repl4S_rRegI", // 777
  "Repl4S_immI0", // 778
  "Repl4C_reg", // 779
  "Repl4C_rRegI", // 780
  "Repl4C_immI0", // 781
  "Repl2I_reg", // 782
  "Repl2I_rRegI", // 783
  "Repl2I_immI0", // 784
  "Repl2F_reg", // 785
  "Repl2F_regF", // 786
  "Repl2F_immF0", // 787
  "rep_stos", // 788
  "string_compare", // 789
  "string_indexof_con", // 790
  "string_indexof", // 791
  "string_equals", // 792
  "array_equals", // 793
  "cmpL3_reg_reg", // 794
  "cmovI_reg_g", // 795
  "minI_rReg", // 796
  "cmovI_reg_l", // 797
  "maxI_rReg", // 798
  "jmpDir", // 799
  "jmpCon", // 800
  "jmpLoopEnd", // 801
  "jmpLoopEndU", // 802
  "jmpLoopEndUCF", // 803
  "jmpConU", // 804
  "jmpConUCF", // 805
  "jmpConUCF2", // 806
  "partialSubtypeCheck", // 807
  "jmpDir_short", // 808
  "jmpCon_short", // 809
  "jmpLoopEnd_short", // 810
  "jmpLoopEndU_short", // 811
  "jmpLoopEndUCF_short", // 812
  "jmpConU_short", // 813
  "jmpConUCF_short", // 814
  "jmpConUCF2_short", // 815
  "safePoint_poll_far", // 816
  "CallStaticJavaDirect", // 817
  "CallStaticJavaHandle", // 818
  "CallDynamicJavaDirect", // 819
  "CallRuntimeDirect", // 820
  "CallLeafDirect", // 821
  "CallLeafNoFPDirect", // 822
  "Ret", // 823
  "TailCalljmpInd", // 824
  "tailjmpInd", // 825
  "CreateException", // 826
  "RethrowException", // 827
  "ShouldNotReachHere", // 828
  // last instruction
  "no trailing comma"
};

const        bool  swallowed[] = {
  false, // 0
  false, // 1
  false, // 2
  false, // 3
  false, // 4
  false, // 5
  false, // 6
  false, // 7
  true, // 8
  true, // 9
  true, // 10
  true, // 11
  true, // 12
  true, // 13
  true, // 14
  true, // 15
  true, // 16
  true, // 17
  true, // 18
  true, // 19
  true, // 20
  true, // 21
  true, // 22
  true, // 23
  true, // 24
  true, // 25
  true, // 26
  true, // 27
  true, // 28
  true, // 29
  true, // 30
  true, // 31
  true, // 32
  true, // 33
  true, // 34
  true, // 35
  true, // 36
  true, // 37
  true, // 38
  true, // 39
  true, // 40
  true, // 41
  true, // 42
  false, // 43
  false, // 44
  false, // 45
  false, // 46
  false, // 47
  false, // 48
  false, // 49
  false, // 50
  false, // 51
  false, // 52
  false, // 53
  false, // 54
  false, // 55
  false, // 56
  false, // 57
  false, // 58
  false, // 59
  false, // 60
  false, // 61
  false, // 62
  false, // 63
  false, // 64
  false, // 65
  false, // 66
  false, // 67
  false, // 68
  false, // 69
  false, // 70
  false, // 71
  false, // 72
  false, // 73
  false, // 74
  false, // 75
  false, // 76
  false, // 77
  false, // 78
  false, // 79
  false, // 80
  false, // 81
  false, // 82
  false, // 83
  false, // 84
  false, // 85
  false, // 86
  false, // 87
  false, // 88
  false, // 89
  false, // 90
  false, // 91
  false, // 92
  false, // 93
  false, // 94
  false, // 95
  false, // 96
  false, // 97
  true, // 98
  true, // 99
  true, // 100
  true, // 101
  // last operand
  false, // 102
  // last operand class
  false, // 103
  false, // 104
  false, // 105
  false, // 106
  false, // 107
  false, // 108
  false, // 109
  false, // 110
  false, // 111
  false, // 112
  false, // 113
  false, // 114
  false, // 115
  false, // 116
  false, // 117
  false, // 118
  false, // 119
  false, // 120
  false, // 121
  false, // 122
  false, // 123
  false, // 124
  false, // 125
  false, // 126
  false, // 127
  false, // 128
  false, // 129
  false, // 130
  false, // 131
  false, // 132
  false, // 133
  false, // 134
  false, // 135
  false, // 136
  false, // 137
  false, // 138
  false, // 139
  false, // 140
  false, // 141
  false, // 142
  false, // 143
  false, // 144
  false, // 145
  false, // 146
  false, // 147
  false, // 148
  false, // 149
  false, // 150
  false, // 151
  false, // 152
  false, // 153
  false, // 154
  false, // 155
  false, // 156
  false, // 157
  false, // 158
  false, // 159
  false, // 160
  false, // 161
  false, // 162
  false, // 163
  false, // 164
  false, // 165
  false, // 166
  false, // 167
  false, // 168
  false, // 169
  false, // 170
  false, // 171
  false, // 172
  false, // 173
  false, // 174
  false, // 175
  false, // 176
  false, // 177
  false, // 178
  false, // 179
  false, // 180
  false, // 181
  false, // 182
  false, // 183
  false, // 184
  false, // 185
  false, // 186
  false, // 187
  false, // 188
  false, // 189
  false, // 190
  false, // 191
  false, // 192
  false, // 193
  false, // 194
  false, // 195
  false, // 196
  false, // 197
  false, // 198
  false, // 199
  false, // 200
  false, // 201
  false, // 202
  false, // 203
  false, // 204
  false, // 205
  false, // 206
  false, // 207
  false, // 208
  false, // 209
  false, // 210
  false, // 211
  false, // 212
  false, // 213
  false, // 214
  false, // 215
  false, // 216
  false, // 217
  false, // 218
  false, // 219
  false, // 220
  false, // 221
  false, // 222
  false, // 223
  false, // 224
  false, // 225
  false, // 226
  false, // 227
  false, // 228
  false, // 229
  false, // 230
  false, // 231
  false, // 232
  false, // 233
  false, // 234
  false, // 235
  false, // 236
  false, // 237
  false, // 238
  false, // 239
  false, // 240
  false, // 241
  false, // 242
  false, // 243
  false, // 244
  false, // 245
  false, // 246
  false, // 247
  false, // 248
  false, // 249
  false, // 250
  false, // 251
  false, // 252
  // last internally defined operand
  false, // 253
  false, // 254
  false, // 255
  false, // 256
  false, // 257
  false, // 258
  false, // 259
  false, // 260
  false, // 261
  false, // 262
  false, // 263
  false, // 264
  false, // 265
  false, // 266
  false, // 267
  false, // 268
  false, // 269
  false, // 270
  false, // 271
  false, // 272
  false, // 273
  false, // 274
  false, // 275
  false, // 276
  false, // 277
  false, // 278
  false, // 279
  false, // 280
  false, // 281
  false, // 282
  false, // 283
  false, // 284
  false, // 285
  false, // 286
  false, // 287
  false, // 288
  false, // 289
  false, // 290
  false, // 291
  false, // 292
  false, // 293
  false, // 294
  false, // 295
  false, // 296
  false, // 297
  false, // 298
  false, // 299
  false, // 300
  false, // 301
  false, // 302
  false, // 303
  false, // 304
  false, // 305
  false, // 306
  false, // 307
  false, // 308
  false, // 309
  false, // 310
  false, // 311
  false, // 312
  false, // 313
  false, // 314
  false, // 315
  false, // 316
  false, // 317
  false, // 318
  false, // 319
  false, // 320
  false, // 321
  false, // 322
  false, // 323
  false, // 324
  false, // 325
  false, // 326
  false, // 327
  false, // 328
  false, // 329
  false, // 330
  false, // 331
  false, // 332
  false, // 333
  false, // 334
  false, // 335
  false, // 336
  false, // 337
  false, // 338
  false, // 339
  false, // 340
  false, // 341
  false, // 342
  false, // 343
  false, // 344
  false, // 345
  false, // 346
  false, // 347
  false, // 348
  false, // 349
  false, // 350
  false, // 351
  false, // 352
  false, // 353
  false, // 354
  false, // 355
  false, // 356
  false, // 357
  false, // 358
  false, // 359
  false, // 360
  false, // 361
  false, // 362
  false, // 363
  false, // 364
  false, // 365
  false, // 366
  false, // 367
  false, // 368
  false, // 369
  false, // 370
  false, // 371
  false, // 372
  false, // 373
  false, // 374
  false, // 375
  false, // 376
  false, // 377
  false, // 378
  false, // 379
  false, // 380
  false, // 381
  false, // 382
  false, // 383
  false, // 384
  false, // 385
  false, // 386
  false, // 387
  false, // 388
  false, // 389
  false, // 390
  false, // 391
  false, // 392
  false, // 393
  false, // 394
  false, // 395
  false, // 396
  false, // 397
  false, // 398
  false, // 399
  false, // 400
  false, // 401
  false, // 402
  false, // 403
  false, // 404
  false, // 405
  false, // 406
  false, // 407
  false, // 408
  false, // 409
  false, // 410
  false, // 411
  false, // 412
  false, // 413
  false, // 414
  false, // 415
  false, // 416
  false, // 417
  false, // 418
  false, // 419
  false, // 420
  false, // 421
  false, // 422
  false, // 423
  false, // 424
  false, // 425
  false, // 426
  false, // 427
  false, // 428
  false, // 429
  false, // 430
  false, // 431
  false, // 432
  false, // 433
  false, // 434
  false, // 435
  false, // 436
  false, // 437
  false, // 438
  false, // 439
  false, // 440
  false, // 441
  false, // 442
  false, // 443
  false, // 444
  false, // 445
  false, // 446
  false, // 447
  false, // 448
  false, // 449
  false, // 450
  false, // 451
  false, // 452
  false, // 453
  false, // 454
  false, // 455
  false, // 456
  false, // 457
  false, // 458
  false, // 459
  false, // 460
  false, // 461
  false, // 462
  false, // 463
  false, // 464
  false, // 465
  false, // 466
  false, // 467
  false, // 468
  false, // 469
  false, // 470
  false, // 471
  false, // 472
  false, // 473
  false, // 474
  false, // 475
  false, // 476
  false, // 477
  false, // 478
  false, // 479
  false, // 480
  false, // 481
  false, // 482
  false, // 483
  false, // 484
  false, // 485
  false, // 486
  false, // 487
  false, // 488
  false, // 489
  false, // 490
  false, // 491
  false, // 492
  false, // 493
  false, // 494
  false, // 495
  false, // 496
  false, // 497
  false, // 498
  false, // 499
  false, // 500
  false, // 501
  false, // 502
  false, // 503
  false, // 504
  false, // 505
  false, // 506
  false, // 507
  false, // 508
  false, // 509
  false, // 510
  false, // 511
  false, // 512
  false, // 513
  false, // 514
  false, // 515
  false, // 516
  false, // 517
  false, // 518
  false, // 519
  false, // 520
  false, // 521
  false, // 522
  false, // 523
  false, // 524
  false, // 525
  false, // 526
  false, // 527
  false, // 528
  false, // 529
  false, // 530
  false, // 531
  false, // 532
  false, // 533
  false, // 534
  false, // 535
  false, // 536
  false, // 537
  false, // 538
  false, // 539
  false, // 540
  false, // 541
  false, // 542
  false, // 543
  false, // 544
  false, // 545
  false, // 546
  false, // 547
  false, // 548
  false, // 549
  false, // 550
  false, // 551
  false, // 552
  false, // 553
  false, // 554
  false, // 555
  false, // 556
  false, // 557
  false, // 558
  false, // 559
  false, // 560
  false, // 561
  false, // 562
  false, // 563
  false, // 564
  false, // 565
  false, // 566
  false, // 567
  false, // 568
  false, // 569
  false, // 570
  false, // 571
  false, // 572
  false, // 573
  false, // 574
  false, // 575
  false, // 576
  false, // 577
  false, // 578
  false, // 579
  false, // 580
  false, // 581
  false, // 582
  false, // 583
  false, // 584
  false, // 585
  false, // 586
  false, // 587
  false, // 588
  false, // 589
  false, // 590
  false, // 591
  false, // 592
  false, // 593
  false, // 594
  false, // 595
  false, // 596
  false, // 597
  false, // 598
  false, // 599
  false, // 600
  false, // 601
  false, // 602
  false, // 603
  false, // 604
  false, // 605
  false, // 606
  false, // 607
  false, // 608
  false, // 609
  false, // 610
  false, // 611
  false, // 612
  false, // 613
  false, // 614
  false, // 615
  false, // 616
  false, // 617
  false, // 618
  false, // 619
  false, // 620
  false, // 621
  false, // 622
  false, // 623
  false, // 624
  false, // 625
  false, // 626
  false, // 627
  false, // 628
  false, // 629
  false, // 630
  false, // 631
  false, // 632
  false, // 633
  false, // 634
  false, // 635
  false, // 636
  false, // 637
  false, // 638
  false, // 639
  false, // 640
  false, // 641
  false, // 642
  false, // 643
  false, // 644
  false, // 645
  false, // 646
  false, // 647
  false, // 648
  false, // 649
  false, // 650
  false, // 651
  false, // 652
  false, // 653
  false, // 654
  false, // 655
  false, // 656
  false, // 657
  false, // 658
  false, // 659
  false, // 660
  false, // 661
  false, // 662
  false, // 663
  false, // 664
  false, // 665
  false, // 666
  false, // 667
  false, // 668
  false, // 669
  false, // 670
  false, // 671
  false, // 672
  false, // 673
  false, // 674
  false, // 675
  false, // 676
  false, // 677
  false, // 678
  false, // 679
  false, // 680
  false, // 681
  false, // 682
  false, // 683
  false, // 684
  false, // 685
  false, // 686
  false, // 687
  false, // 688
  false, // 689
  false, // 690
  false, // 691
  false, // 692
  false, // 693
  false, // 694
  false, // 695
  false, // 696
  false, // 697
  false, // 698
  false, // 699
  false, // 700
  false, // 701
  false, // 702
  false, // 703
  false, // 704
  false, // 705
  false, // 706
  false, // 707
  false, // 708
  false, // 709
  false, // 710
  false, // 711
  false, // 712
  false, // 713
  false, // 714
  false, // 715
  false, // 716
  false, // 717
  false, // 718
  false, // 719
  false, // 720
  false, // 721
  false, // 722
  false, // 723
  false, // 724
  false, // 725
  false, // 726
  false, // 727
  false, // 728
  false, // 729
  false, // 730
  false, // 731
  false, // 732
  false, // 733
  false, // 734
  false, // 735
  false, // 736
  false, // 737
  false, // 738
  false, // 739
  false, // 740
  false, // 741
  false, // 742
  false, // 743
  false, // 744
  false, // 745
  false, // 746
  false, // 747
  false, // 748
  false, // 749
  false, // 750
  false, // 751
  false, // 752
  false, // 753
  false, // 754
  false, // 755
  false, // 756
  false, // 757
  false, // 758
  false, // 759
  false, // 760
  false, // 761
  false, // 762
  false, // 763
  false, // 764
  false, // 765
  false, // 766
  false, // 767
  false, // 768
  false, // 769
  false, // 770
  false, // 771
  false, // 772
  false, // 773
  false, // 774
  false, // 775
  false, // 776
  false, // 777
  false, // 778
  false, // 779
  false, // 780
  false, // 781
  false, // 782
  false, // 783
  false, // 784
  false, // 785
  false, // 786
  false, // 787
  false, // 788
  false, // 789
  false, // 790
  false, // 791
  false, // 792
  false, // 793
  false, // 794
  false, // 795
  false, // 796
  false, // 797
  false, // 798
  false, // 799
  false, // 800
  false, // 801
  false, // 802
  false, // 803
  false, // 804
  false, // 805
  false, // 806
  false, // 807
  false, // 808
  false, // 809
  false, // 810
  false, // 811
  false, // 812
  false, // 813
  false, // 814
  false, // 815
  false, // 816
  false, // 817
  false, // 818
  false, // 819
  false, // 820
  false, // 821
  false, // 822
  false, // 823
  false, // 824
  false, // 825
  false, // 826
  false, // 827
  false, // 828
  // last instruction
  false // no trailing comma
};

// Mapping from machine-independent opcode to boolean
const        char must_clone[] = {
  0, // Node: 0
  0, // Set: 1
  0, // RegN: 2
  0, // RegI: 3
  0, // RegP: 4
  0, // RegF: 5
  0, // RegD: 6
  0, // RegL: 7
  0, // RegFlags: 8
  0, // _last_machine_leaf: 9
  0, // AbsD: 10
  0, // AbsF: 11
  0, // AbsI: 12
  0, // AddD: 13
  0, // AddF: 14
  0, // AddI: 15
  0, // AddL: 16
  0, // AddP: 17
  0, // Allocate: 18
  0, // AllocateArray: 19
  0, // AndI: 20
  0, // AndL: 21
  0, // AryEq: 22
  0, // AtanD: 23
  1, // Binary: 24
  1, // Bool: 25
  0, // BoxLock: 26
  0, // ReverseBytesI: 27
  0, // ReverseBytesL: 28
  0, // ReverseBytesUS: 29
  0, // ReverseBytesS: 30
  0, // CProj: 31
  0, // CallDynamicJava: 32
  0, // CallJava: 33
  0, // CallLeaf: 34
  0, // CallLeafNoFP: 35
  0, // CallRuntime: 36
  0, // CallStaticJava: 37
  0, // CastII: 38
  0, // CastX2P: 39
  0, // CastP2X: 40
  0, // CastPP: 41
  0, // Catch: 42
  0, // CatchProj: 43
  0, // CheckCastPP: 44
  0, // ClearArray: 45
  0, // ConstraintCast: 46
  0, // CMoveD: 47
  0, // CMoveF: 48
  0, // CMoveI: 49
  0, // CMoveL: 50
  0, // CMoveP: 51
  0, // CMoveN: 52
  1, // CmpN: 53
  1, // CmpD: 54
  0, // CmpD3: 55
  1, // CmpF: 56
  0, // CmpF3: 57
  1, // CmpI: 58
  1, // CmpL: 59
  0, // CmpL3: 60
  0, // CmpLTMask: 61
  1, // CmpP: 62
  1, // CmpU: 63
  0, // CompareAndSwapI: 64
  0, // CompareAndSwapL: 65
  0, // CompareAndSwapP: 66
  0, // CompareAndSwapN: 67
  0, // Con: 68
  0, // ConN: 69
  0, // ConD: 70
  0, // ConF: 71
  0, // ConI: 72
  0, // ConL: 73
  0, // ConP: 74
  0, // Conv2B: 75
  0, // ConvD2F: 76
  0, // ConvD2I: 77
  0, // ConvD2L: 78
  0, // ConvF2D: 79
  0, // ConvF2I: 80
  0, // ConvF2L: 81
  0, // ConvI2D: 82
  0, // ConvI2F: 83
  0, // ConvI2L: 84
  0, // ConvL2D: 85
  0, // ConvL2F: 86
  0, // ConvL2I: 87
  0, // CosD: 88
  0, // CountedLoop: 89
  0, // CountedLoopEnd: 90
  0, // CountLeadingZerosI: 91
  0, // CountLeadingZerosL: 92
  0, // CountTrailingZerosI: 93
  0, // CountTrailingZerosL: 94
  0, // CreateEx: 95
  0, // DecodeN: 96
  0, // DivD: 97
  0, // DivF: 98
  0, // DivI: 99
  0, // DivL: 100
  0, // DivMod: 101
  0, // DivModI: 102
  0, // DivModL: 103
  0, // EncodeP: 104
  0, // ExpD: 105
  1, // FastLock: 106
  1, // FastUnlock: 107
  0, // Goto: 108
  0, // Halt: 109
  0, // If: 110
  0, // IfFalse: 111
  0, // IfTrue: 112
  0, // Initialize: 113
  0, // JProj: 114
  0, // Jump: 115
  0, // JumpProj: 116
  0, // LShiftI: 117
  0, // LShiftL: 118
  0, // LoadB: 119
  0, // LoadUB: 120
  0, // LoadUS: 121
  0, // LoadD: 122
  0, // LoadD_unaligned: 123
  0, // LoadF: 124
  0, // LoadI: 125
  0, // LoadUI2L: 126
  0, // LoadKlass: 127
  0, // LoadNKlass: 128
  0, // LoadL: 129
  0, // LoadL_unaligned: 130
  0, // LoadPLocked: 131
  0, // LoadLLocked: 132
  0, // LoadP: 133
  0, // LoadN: 134
  0, // LoadRange: 135
  0, // LoadS: 136
  0, // Lock: 137
  0, // LogD: 138
  0, // Log10D: 139
  0, // Loop: 140
  0, // LoopLimit: 141
  0, // Mach: 142
  0, // MachProj: 143
  0, // MaxI: 144
  0, // MemBarAcquire: 145
  0, // MemBarCPUOrder: 146
  0, // MemBarRelease: 147
  0, // MemBarVolatile: 148
  0, // MergeMem: 149
  0, // MinI: 150
  0, // ModD: 151
  0, // ModF: 152
  0, // ModI: 153
  0, // ModL: 154
  0, // MoveI2F: 155
  0, // MoveF2I: 156
  0, // MoveL2D: 157
  0, // MoveD2L: 158
  0, // MulD: 159
  0, // MulF: 160
  0, // MulHiL: 161
  0, // MulI: 162
  0, // MulL: 163
  0, // Multi: 164
  0, // NegD: 165
  0, // NegF: 166
  0, // NeverBranch: 167
  0, // Opaque1: 168
  0, // Opaque2: 169
  0, // OrI: 170
  0, // OrL: 171
  0, // PCTable: 172
  0, // Parm: 173
  0, // PartialSubtypeCheck: 174
  0, // Phi: 175
  0, // PopCountI: 176
  0, // PopCountL: 177
  0, // PowD: 178
  0, // PrefetchRead: 179
  0, // PrefetchWrite: 180
  0, // Proj: 181
  0, // RShiftI: 182
  0, // RShiftL: 183
  0, // Region: 184
  0, // Rethrow: 185
  0, // Return: 186
  0, // Root: 187
  0, // RoundDouble: 188
  0, // RoundFloat: 189
  0, // SafePoint: 190
  0, // SafePointScalarObject: 191
  0, // SCMemProj: 192
  0, // SinD: 193
  0, // SqrtD: 194
  0, // Start: 195
  0, // StartOSR: 196
  0, // StoreB: 197
  0, // StoreC: 198
  0, // StoreCM: 199
  0, // StorePConditional: 200
  0, // StoreIConditional: 201
  0, // StoreLConditional: 202
  0, // StoreD: 203
  0, // StoreF: 204
  0, // StoreI: 205
  0, // StoreL: 206
  0, // StoreP: 207
  0, // StoreN: 208
  0, // StrComp: 209
  0, // StrEquals: 210
  0, // StrIndexOf: 211
  0, // SubD: 212
  0, // SubF: 213
  0, // SubI: 214
  0, // SubL: 215
  0, // TailCall: 216
  0, // TailJump: 217
  0, // TanD: 218
  0, // ThreadLocal: 219
  0, // Unlock: 220
  0, // URShiftI: 221
  0, // URShiftL: 222
  0, // XorI: 223
  0, // XorL: 224
  0, // Vector: 225
  0, // AddVB: 226
  0, // AddVC: 227
  0, // AddVS: 228
  0, // AddVI: 229
  0, // AddVL: 230
  0, // AddVF: 231
  0, // AddVD: 232
  0, // SubVB: 233
  0, // SubVC: 234
  0, // SubVS: 235
  0, // SubVI: 236
  0, // SubVL: 237
  0, // SubVF: 238
  0, // SubVD: 239
  0, // MulVF: 240
  0, // MulVD: 241
  0, // DivVF: 242
  0, // DivVD: 243
  0, // LShiftVB: 244
  0, // LShiftVC: 245
  0, // LShiftVS: 246
  0, // LShiftVI: 247
  0, // URShiftVB: 248
  0, // URShiftVC: 249
  0, // URShiftVS: 250
  0, // URShiftVI: 251
  0, // AndV: 252
  0, // OrV: 253
  0, // XorV: 254
  0, // VectorLoad: 255
  0, // Load16B: 256
  0, // Load8B: 257
  0, // Load4B: 258
  0, // Load8C: 259
  0, // Load4C: 260
  0, // Load2C: 261
  0, // Load8S: 262
  0, // Load4S: 263
  0, // Load2S: 264
  0, // Load4I: 265
  0, // Load2I: 266
  0, // Load2L: 267
  0, // Load4F: 268
  0, // Load2F: 269
  0, // Load2D: 270
  0, // VectorStore: 271
  0, // Store16B: 272
  0, // Store8B: 273
  0, // Store4B: 274
  0, // Store8C: 275
  0, // Store4C: 276
  0, // Store2C: 277
  0, // Store4I: 278
  0, // Store2I: 279
  0, // Store2L: 280
  0, // Store4F: 281
  0, // Store2F: 282
  0, // Store2D: 283
  0, // Pack: 284
  0, // PackB: 285
  0, // PackS: 286
  0, // PackC: 287
  0, // PackI: 288
  0, // PackL: 289
  0, // PackF: 290
  0, // PackD: 291
  0, // Pack2x1B: 292
  0, // Pack2x2B: 293
  0, // Replicate16B: 294
  0, // Replicate8B: 295
  0, // Replicate4B: 296
  0, // Replicate8S: 297
  0, // Replicate4S: 298
  0, // Replicate2S: 299
  0, // Replicate8C: 300
  0, // Replicate4C: 301
  0, // Replicate2C: 302
  0, // Replicate4I: 303
  0, // Replicate2I: 304
  0, // Replicate2L: 305
  0, // Replicate4F: 306
  0, // Replicate2F: 307
  0, // Replicate2D: 308
  0, // Extract: 309
  0, // ExtractB: 310
  0, // ExtractS: 311
  0, // ExtractC: 312
  0, // ExtractI: 313
  0, // ExtractL: 314
  0, // ExtractF: 315
  0 // no trailing comma // ExtractD: 316
};
//  The following instructions can cisc-spill
//  popCountI can cisc-spill operand 1 to popCountI_mem
//  popCountL can cisc-spill operand 1 to popCountL_mem
//  cmovI_reg can cisc-spill operand 4 to cmovI_mem
//  cmovI_regU can cisc-spill operand 4 to cmovI_memU
//  cmovI_regUCF can cisc-spill operand 4 to cmovI_memUCF
//  cmovL_reg can cisc-spill operand 4 to cmovL_mem
//  cmovL_regU can cisc-spill operand 4 to cmovL_memU
//  cmovL_regUCF can cisc-spill operand 4 to cmovL_memUCF
//  addI_rReg can cisc-spill operand 2 to addI_rReg_mem
//  addL_rReg can cisc-spill operand 2 to addL_rReg_mem
//  subI_rReg can cisc-spill operand 2 to subI_rReg_mem
//  subL_rReg can cisc-spill operand 2 to subL_rReg_mem
//  mulI_rReg can cisc-spill operand 2 to mulI_mem
//  mulI_rReg_imm can cisc-spill operand 1 to mulI_mem_imm
//  mulL_rReg can cisc-spill operand 2 to mulL_mem
//  mulL_rReg_imm can cisc-spill operand 1 to mulL_mem_imm
//  i2b can cisc-spill operand 1 to loadI2B
//  i2s can cisc-spill operand 1 to loadI2S
//  andI_rReg can cisc-spill operand 2 to andI_rReg_mem
//  andI2L_rReg_imm255 can cisc-spill operand 1 to loadI2L_immI_255
//  andI2L_rReg_imm65535 can cisc-spill operand 1 to loadI2L_immI_65535
//  orI_rReg can cisc-spill operand 2 to orI_rReg_mem
//  xorI_rReg can cisc-spill operand 2 to xorI_rReg_mem
//  andL_rReg can cisc-spill operand 2 to andL_rReg_mem
//  orL_rReg can cisc-spill operand 2 to orL_rReg_mem
//  xorL_rReg can cisc-spill operand 2 to xorL_rReg_mem
//  cmpF_cc_reg can cisc-spill operand 2 to cmpF_cc_mem
//  cmpF_cc_reg_CF can cisc-spill operand 2 to cmpF_cc_memCF
//  cmpD_cc_reg can cisc-spill operand 2 to cmpD_cc_mem
//  cmpD_cc_reg_CF can cisc-spill operand 2 to cmpD_cc_memCF
//  cmpF_reg can cisc-spill operand 2 to cmpF_mem
//  cmpD_reg can cisc-spill operand 2 to cmpD_mem
//  addF_reg can cisc-spill operand 2 to addF_mem
//  addD_reg can cisc-spill operand 2 to addD_mem
//  subF_reg can cisc-spill operand 2 to subF_mem
//  subD_reg can cisc-spill operand 2 to subD_mem
//  mulF_reg can cisc-spill operand 2 to mulF_mem
//  mulD_reg can cisc-spill operand 2 to mulD_mem
//  divF_reg can cisc-spill operand 2 to divF_mem
//  divD_reg can cisc-spill operand 2 to divD_mem
//  sqrtF_reg can cisc-spill operand 1 to sqrtF_mem
//  sqrtD_reg can cisc-spill operand 1 to sqrtD_mem
//  convF2D_reg_reg can cisc-spill operand 1 to convF2D_reg_mem
//  convD2F_reg_reg can cisc-spill operand 1 to convD2F_reg_mem
//  convL2F_reg_reg can cisc-spill operand 1 to convL2F_reg_mem
//  convL2D_reg_reg can cisc-spill operand 1 to convL2D_reg_mem
//  convI2L_reg_reg can cisc-spill operand 1 to loadI2L
//  convI2L_reg_reg_zex can cisc-spill operand 1 to convI2L_reg_mem_zex
//  MoveF2I_reg_reg can cisc-spill operand 1 to MoveF2I_stack_reg
//  MoveD2L_reg_reg can cisc-spill operand 1 to MoveD2L_stack_reg
//  MoveI2F_reg_reg can cisc-spill operand 1 to MoveI2F_stack_reg
//  compI_rReg can cisc-spill operand 2 to compI_rReg_mem
//  compU_rReg can cisc-spill operand 2 to compU_rReg_mem
//  compP_rReg can cisc-spill operand 2 to compP_rReg_mem
//  compL_rReg can cisc-spill operand 2 to compL_rReg_mem



// An array of character pointers to machine register names.
const char *Matcher::regName[REG_COUNT] = {
  "R10",
  "R10_H",
  "R11",
  "R11_H",
  "R8",
  "R8_H",
  "R9",
  "R9_H",
  "R12",
  "R12_H",
  "RCX",
  "RCX_H",
  "RBX",
  "RBX_H",
  "RDI",
  "RDI_H",
  "RDX",
  "RDX_H",
  "RSI",
  "RSI_H",
  "RAX",
  "RAX_H",
  "RBP",
  "RBP_H",
  "R13",
  "R13_H",
  "R14",
  "R14_H",
  "R15",
  "R15_H",
  "RSP",
  "RSP_H",
  "XMM0",
  "XMM0_H",
  "XMM1",
  "XMM1_H",
  "XMM2",
  "XMM2_H",
  "XMM3",
  "XMM3_H",
  "XMM4",
  "XMM4_H",
  "XMM5",
  "XMM5_H",
  "XMM6",
  "XMM6_H",
  "XMM7",
  "XMM7_H",
  "XMM8",
  "XMM8_H",
  "XMM9",
  "XMM9_H",
  "XMM10",
  "XMM10_H",
  "XMM11",
  "XMM11_H",
  "XMM12",
  "XMM12_H",
  "XMM13",
  "XMM13_H",
  "XMM14",
  "XMM14_H",
  "XMM15",
  "XMM15_H",
  "RFLAGS" // no trailing comma
};

// An array of character pointers to machine register names.
const VMReg OptoReg::opto2vm[REG_COUNT] = {
	r10->as_VMReg(),
	r10->as_VMReg()->next(),
	r11->as_VMReg(),
	r11->as_VMReg()->next(),
	r8->as_VMReg(),
	r8->as_VMReg()->next(),
	r9->as_VMReg(),
	r9->as_VMReg()->next(),
	r12->as_VMReg(),
	r12->as_VMReg()->next(),
	rcx->as_VMReg(),
	rcx->as_VMReg()->next(),
	rbx->as_VMReg(),
	rbx->as_VMReg()->next(),
	rdi->as_VMReg(),
	rdi->as_VMReg()->next(),
	rdx->as_VMReg(),
	rdx->as_VMReg()->next(),
	rsi->as_VMReg(),
	rsi->as_VMReg()->next(),
	rax->as_VMReg(),
	rax->as_VMReg()->next(),
	rbp->as_VMReg(),
	rbp->as_VMReg()->next(),
	r13->as_VMReg(),
	r13->as_VMReg()->next(),
	r14->as_VMReg(),
	r14->as_VMReg()->next(),
	r15->as_VMReg(),
	r15->as_VMReg()->next(),
	rsp->as_VMReg(),
	rsp->as_VMReg()->next(),
	xmm0->as_VMReg(),
	xmm0->as_VMReg()->next(),
	xmm1->as_VMReg(),
	xmm1->as_VMReg()->next(),
	xmm2->as_VMReg(),
	xmm2->as_VMReg()->next(),
	xmm3->as_VMReg(),
	xmm3->as_VMReg()->next(),
	xmm4->as_VMReg(),
	xmm4->as_VMReg()->next(),
	xmm5->as_VMReg(),
	xmm5->as_VMReg()->next(),
	xmm6->as_VMReg(),
	xmm6->as_VMReg()->next(),
	xmm7->as_VMReg(),
	xmm7->as_VMReg()->next(),
	xmm8->as_VMReg(),
	xmm8->as_VMReg()->next(),
	xmm9->as_VMReg(),
	xmm9->as_VMReg()->next(),
	xmm10->as_VMReg(),
	xmm10->as_VMReg()->next(),
	xmm11->as_VMReg(),
	xmm11->as_VMReg()->next(),
	xmm12->as_VMReg(),
	xmm12->as_VMReg()->next(),
	xmm13->as_VMReg(),
	xmm13->as_VMReg()->next(),
	xmm14->as_VMReg(),
	xmm14->as_VMReg()->next(),
	xmm15->as_VMReg(),
	xmm15->as_VMReg()->next(),
	VMRegImpl::Bad() // no trailing comma
	};

 OptoReg::Name OptoReg::vm2opto[ConcreteRegisterImpl::number_of_registers];

// An array of the machine register encode values
const unsigned char Matcher::_regEncode[REG_COUNT] = {
  (unsigned char)'\xA',  // R10
  (unsigned char)'\xA',  // R10_H
  (unsigned char)'\xB',  // R11
  (unsigned char)'\xB',  // R11_H
  (unsigned char)'\x8',  // R8
  (unsigned char)'\x8',  // R8_H
  (unsigned char)'\x9',  // R9
  (unsigned char)'\x9',  // R9_H
  (unsigned char)'\xC',  // R12
  (unsigned char)'\xC',  // R12_H
  (unsigned char)'\x1',  // RCX
  (unsigned char)'\x1',  // RCX_H
  (unsigned char)'\x3',  // RBX
  (unsigned char)'\x3',  // RBX_H
  (unsigned char)'\x7',  // RDI
  (unsigned char)'\x7',  // RDI_H
  (unsigned char)'\x2',  // RDX
  (unsigned char)'\x2',  // RDX_H
  (unsigned char)'\x6',  // RSI
  (unsigned char)'\x6',  // RSI_H
  (unsigned char)'\x0',  // RAX
  (unsigned char)'\x0',  // RAX_H
  (unsigned char)'\x5',  // RBP
  (unsigned char)'\x5',  // RBP_H
  (unsigned char)'\xD',  // R13
  (unsigned char)'\xD',  // R13_H
  (unsigned char)'\xE',  // R14
  (unsigned char)'\xE',  // R14_H
  (unsigned char)'\xF',  // R15
  (unsigned char)'\xF',  // R15_H
  (unsigned char)'\x4',  // RSP
  (unsigned char)'\x4',  // RSP_H
  (unsigned char)'\x0',  // XMM0
  (unsigned char)'\x0',  // XMM0_H
  (unsigned char)'\x1',  // XMM1
  (unsigned char)'\x1',  // XMM1_H
  (unsigned char)'\x2',  // XMM2
  (unsigned char)'\x2',  // XMM2_H
  (unsigned char)'\x3',  // XMM3
  (unsigned char)'\x3',  // XMM3_H
  (unsigned char)'\x4',  // XMM4
  (unsigned char)'\x4',  // XMM4_H
  (unsigned char)'\x5',  // XMM5
  (unsigned char)'\x5',  // XMM5_H
  (unsigned char)'\x6',  // XMM6
  (unsigned char)'\x6',  // XMM6_H
  (unsigned char)'\x7',  // XMM7
  (unsigned char)'\x7',  // XMM7_H
  (unsigned char)'\x8',  // XMM8
  (unsigned char)'\x8',  // XMM8_H
  (unsigned char)'\x9',  // XMM9
  (unsigned char)'\x9',  // XMM9_H
  (unsigned char)'\xA',  // XMM10
  (unsigned char)'\xA',  // XMM10_H
  (unsigned char)'\xB',  // XMM11
  (unsigned char)'\xB',  // XMM11_H
  (unsigned char)'\xC',  // XMM12
  (unsigned char)'\xC',  // XMM12_H
  (unsigned char)'\xD',  // XMM13
  (unsigned char)'\xD',  // XMM13_H
  (unsigned char)'\xE',  // XMM14
  (unsigned char)'\xE',  // XMM14_H
  (unsigned char)'\xF',  // XMM15
  (unsigned char)'\xF',  // XMM15_H
  (unsigned char)'\x10' // no trailing comma  // RFLAGS
};


//------------------Define classes derived from MachOper---------------------
MachOper  *labelOper::clone(Compile* C) const {
  return  new (C) labelOper(_label, _block_num);
}
uint labelOper::opcode() const { return LABEL; }

const RegMask *sRegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *sRegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *sRegFOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *sRegDOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *sRegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

MachOper  *methodOper::clone(Compile* C) const {
  return  new (C) methodOper(_method);
}
uint methodOper::opcode() const { return METHOD; }

const RegMask *rRegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_REG_mask;
}

const RegMask *rax_RegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_RAX_REG_mask;
}

const RegMask *rbx_RegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_RBX_REG_mask;
}

const RegMask *rcx_RegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_RCX_REG_mask;
}

const RegMask *rdx_RegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_RDX_REG_mask;
}

const RegMask *rdi_RegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_RDI_REG_mask;
}

const RegMask *no_rcx_RegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_NO_RCX_REG_mask;
}

const RegMask *no_rax_rdx_RegIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_NO_RAX_RDX_REG_mask;
}

const RegMask *any_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &ANY_REG_mask;
}

const RegMask *rRegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask;
}

const RegMask *rRegNOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_REG_mask;
}

const RegMask *no_rax_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_NO_RAX_REG_mask;
}

const RegMask *no_rbp_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_NO_RBP_REG_mask;
}

const RegMask *no_rax_rbx_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_NO_RAX_RBX_REG_mask;
}

const RegMask *rax_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_RAX_REG_mask;
}

const RegMask *rax_RegNOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_RAX_REG_mask;
}

const RegMask *rbx_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_RBX_REG_mask;
}

const RegMask *rsi_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_RSI_REG_mask;
}

const RegMask *rdi_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_RDI_REG_mask;
}

const RegMask *rbp_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_RBP_REG_mask;
}

const RegMask *r15_RegPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_R15_REG_mask;
}

const RegMask *rRegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &LONG_REG_mask;
}

const RegMask *no_rax_rdx_RegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &LONG_NO_RAX_RDX_REG_mask;
}

const RegMask *no_rax_RegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &LONG_NO_RAX_RDX_REG_mask;
}

const RegMask *no_rcx_RegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &LONG_NO_RCX_REG_mask;
}

const RegMask *rax_RegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &LONG_RAX_REG_mask;
}

const RegMask *rcx_RegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &LONG_RCX_REG_mask;
}

const RegMask *rdx_RegLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &LONG_RDX_REG_mask;
}

const RegMask *rFlagsRegOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_FLAGS_mask;
}

const RegMask *rFlagsRegUOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_FLAGS_mask;
}

const RegMask *rFlagsRegUCFOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_FLAGS_mask;
}

const RegMask *regFOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &FLOAT_REG_mask;
}

const RegMask *regDOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &DOUBLE_REG_mask;
}

const RegMask *indirectOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &PTR_REG_mask;
}

const RegMask *indOffset8Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &ANY_REG_mask;
}

const RegMask *indOffset32Oper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &ANY_REG_mask;
}

const RegMask *indIndexOffsetOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &ANY_REG_mask;
  case 1: return &LONG_REG_mask;
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indIndexOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &ANY_REG_mask;
  case 1: return &LONG_REG_mask;
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indIndexScaleOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &ANY_REG_mask;
  case 1: return &LONG_REG_mask;
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indIndexScaleOffsetOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &ANY_REG_mask;
  case 1: return &LONG_REG_mask;
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indPosIndexScaleOffsetOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &ANY_REG_mask;
  case 1: return &INT_REG_mask;
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indCompressedOopOffsetOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_REG_mask;
}

const RegMask *indirectNarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_REG_mask;
}

const RegMask *indOffset8NarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_REG_mask;
}

const RegMask *indOffset32NarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &INT_REG_mask;
}

const RegMask *indIndexOffsetNarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &INT_REG_mask;
  case 1: return &LONG_REG_mask;
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indIndexNarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &INT_REG_mask;
  case 1: return &LONG_REG_mask;
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indIndexScaleNarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &INT_REG_mask;
  case 1: return &LONG_REG_mask;
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indIndexScaleOffsetNarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  switch (index) {
  case 0: return &INT_REG_mask;
  case 1: return &LONG_REG_mask;
  }
  ShouldNotReachHere();
  return NULL;
}

const RegMask *indPosIndexScaleOffsetNarrowOper::in_RegMask(int index) const {
  assert(0 <= index && index < 2, "index out of range");
  return &INT_REG_mask;
}

const RegMask *stackSlotPOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *stackSlotIOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *stackSlotFOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *stackSlotDOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

const RegMask *stackSlotLOper::in_RegMask(int index) const {
  assert(0 <= index && index < 1, "index out of range");
  return &(Compile::current()->FIRST_STACK_mask());
}

//------------------Define members for classes derived from MachNode----------

void popCountINode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *popCountINode::cisc_version( int offset, Compile* C ) {
  popCountI_memNode *node = new (C) popCountI_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void popCountLNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask;
}

// Build CISC version of this instruction
MachNode *popCountLNode::cisc_version( int offset, Compile* C ) {
  popCountL_memNode *node = new (C) popCountL_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void cmovI_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *cmovI_regNode::cisc_version( int offset, Compile* C ) {
  cmovI_memNode *node = new (C) cmovI_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void cmovI_regUNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *cmovI_regUNode::cisc_version( int offset, Compile* C ) {
  cmovI_memUNode *node = new (C) cmovI_memUNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void cmovI_regUCFNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *cmovI_regUCFNode::cisc_version( int offset, Compile* C ) {
  cmovI_memUCFNode *node = new (C) cmovI_memUCFNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void cmovL_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask;
}

// Build CISC version of this instruction
MachNode *cmovL_regNode::cisc_version( int offset, Compile* C ) {
  cmovL_memNode *node = new (C) cmovL_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void cmovL_regUNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask;
}

// Build CISC version of this instruction
MachNode *cmovL_regUNode::cisc_version( int offset, Compile* C ) {
  cmovL_memUNode *node = new (C) cmovL_memUNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void cmovL_regUCFNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask;
}

// Build CISC version of this instruction
MachNode *cmovL_regUCFNode::cisc_version( int offset, Compile* C ) {
  cmovL_memUCFNode *node = new (C) cmovL_memUCFNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void addI_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *addI_rRegNode::cisc_version( int offset, Compile* C ) {
  addI_rReg_memNode *node = new (C) addI_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void addL_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask;
}

// Build CISC version of this instruction
MachNode *addL_rRegNode::cisc_version( int offset, Compile* C ) {
  addL_rReg_memNode *node = new (C) addL_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void subI_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *subI_rRegNode::cisc_version( int offset, Compile* C ) {
  subI_rReg_memNode *node = new (C) subI_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void subL_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask;
}

// Build CISC version of this instruction
MachNode *subL_rRegNode::cisc_version( int offset, Compile* C ) {
  subL_rReg_memNode *node = new (C) subL_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void mulI_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *mulI_rRegNode::cisc_version( int offset, Compile* C ) {
  mulI_memNode *node = new (C) mulI_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void mulI_rReg_immNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *mulI_rReg_immNode::cisc_version( int offset, Compile* C ) {
  mulI_mem_immNode *node = new (C) mulI_mem_immNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void mulL_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask;
}

// Build CISC version of this instruction
MachNode *mulL_rRegNode::cisc_version( int offset, Compile* C ) {
  mulL_memNode *node = new (C) mulL_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void mulL_rReg_immNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask;
}

// Build CISC version of this instruction
MachNode *mulL_rReg_immNode::cisc_version( int offset, Compile* C ) {
  mulL_mem_immNode *node = new (C) mulL_mem_immNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void i2bNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *i2bNode::cisc_version( int offset, Compile* C ) {
  loadI2BNode *node = new (C) loadI2BNode();
  node->_num_opnds = 3;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void i2sNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *i2sNode::cisc_version( int offset, Compile* C ) {
  loadI2SNode *node = new (C) loadI2SNode();
  node->_num_opnds = 3;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void andI_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *andI_rRegNode::cisc_version( int offset, Compile* C ) {
  andI_rReg_memNode *node = new (C) andI_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void andI2L_rReg_imm255Node::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *andI2L_rReg_imm255Node::cisc_version( int offset, Compile* C ) {
  loadI2L_immI_255Node *node = new (C) loadI2L_immI_255Node();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void andI2L_rReg_imm65535Node::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *andI2L_rReg_imm65535Node::cisc_version( int offset, Compile* C ) {
  loadI2L_immI_65535Node *node = new (C) loadI2L_immI_65535Node();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void orI_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *orI_rRegNode::cisc_version( int offset, Compile* C ) {
  orI_rReg_memNode *node = new (C) orI_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void xorI_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *xorI_rRegNode::cisc_version( int offset, Compile* C ) {
  xorI_rReg_memNode *node = new (C) xorI_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void andL_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask;
}

// Build CISC version of this instruction
MachNode *andL_rRegNode::cisc_version( int offset, Compile* C ) {
  andL_rReg_memNode *node = new (C) andL_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void orL_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask;
}

// Build CISC version of this instruction
MachNode *orL_rRegNode::cisc_version( int offset, Compile* C ) {
  orL_rReg_memNode *node = new (C) orL_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void xorL_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask;
}

// Build CISC version of this instruction
MachNode *xorL_rRegNode::cisc_version( int offset, Compile* C ) {
  xorL_rReg_memNode *node = new (C) xorL_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void cmpF_cc_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask;
}

// Build CISC version of this instruction
MachNode *cmpF_cc_regNode::cisc_version( int offset, Compile* C ) {
  cmpF_cc_memNode *node = new (C) cmpF_cc_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void cmpF_cc_reg_CFNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask;
}

// Build CISC version of this instruction
MachNode *cmpF_cc_reg_CFNode::cisc_version( int offset, Compile* C ) {
  cmpF_cc_memCFNode *node = new (C) cmpF_cc_memCFNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void cmpD_cc_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask;
}

// Build CISC version of this instruction
MachNode *cmpD_cc_regNode::cisc_version( int offset, Compile* C ) {
  cmpD_cc_memNode *node = new (C) cmpD_cc_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void cmpD_cc_reg_CFNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask;
}

// Build CISC version of this instruction
MachNode *cmpD_cc_reg_CFNode::cisc_version( int offset, Compile* C ) {
  cmpD_cc_memCFNode *node = new (C) cmpD_cc_memCFNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void cmpF_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask;
}

// Build CISC version of this instruction
MachNode *cmpF_regNode::cisc_version( int offset, Compile* C ) {
  cmpF_memNode *node = new (C) cmpF_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void cmpD_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask;
}

// Build CISC version of this instruction
MachNode *cmpD_regNode::cisc_version( int offset, Compile* C ) {
  cmpD_memNode *node = new (C) cmpD_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void addF_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask;
}

// Build CISC version of this instruction
MachNode *addF_regNode::cisc_version( int offset, Compile* C ) {
  addF_memNode *node = new (C) addF_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void addD_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask;
}

// Build CISC version of this instruction
MachNode *addD_regNode::cisc_version( int offset, Compile* C ) {
  addD_memNode *node = new (C) addD_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void subF_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask;
}

// Build CISC version of this instruction
MachNode *subF_regNode::cisc_version( int offset, Compile* C ) {
  subF_memNode *node = new (C) subF_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void subD_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask;
}

// Build CISC version of this instruction
MachNode *subD_regNode::cisc_version( int offset, Compile* C ) {
  subD_memNode *node = new (C) subD_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void mulF_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask;
}

// Build CISC version of this instruction
MachNode *mulF_regNode::cisc_version( int offset, Compile* C ) {
  mulF_memNode *node = new (C) mulF_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void mulD_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask;
}

// Build CISC version of this instruction
MachNode *mulD_regNode::cisc_version( int offset, Compile* C ) {
  mulD_memNode *node = new (C) mulD_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void divF_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask;
}

// Build CISC version of this instruction
MachNode *divF_regNode::cisc_version( int offset, Compile* C ) {
  divF_memNode *node = new (C) divF_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void divD_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask;
}

// Build CISC version of this instruction
MachNode *divD_regNode::cisc_version( int offset, Compile* C ) {
  divD_memNode *node = new (C) divD_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void sqrtF_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask;
}

// Build CISC version of this instruction
MachNode *sqrtF_regNode::cisc_version( int offset, Compile* C ) {
  sqrtF_memNode *node = new (C) sqrtF_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void sqrtD_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask;
}

// Build CISC version of this instruction
MachNode *sqrtD_regNode::cisc_version( int offset, Compile* C ) {
  sqrtD_memNode *node = new (C) sqrtD_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void convF2D_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask;
}

// Build CISC version of this instruction
MachNode *convF2D_reg_regNode::cisc_version( int offset, Compile* C ) {
  convF2D_reg_memNode *node = new (C) convF2D_reg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void convD2F_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask;
}

// Build CISC version of this instruction
MachNode *convD2F_reg_regNode::cisc_version( int offset, Compile* C ) {
  convD2F_reg_memNode *node = new (C) convD2F_reg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void convL2F_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask;
}

// Build CISC version of this instruction
MachNode *convL2F_reg_regNode::cisc_version( int offset, Compile* C ) {
  convL2F_reg_memNode *node = new (C) convL2F_reg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void convL2D_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask;
}

// Build CISC version of this instruction
MachNode *convL2D_reg_regNode::cisc_version( int offset, Compile* C ) {
  convL2D_reg_memNode *node = new (C) convL2D_reg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void convI2L_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *convI2L_reg_regNode::cisc_version( int offset, Compile* C ) {
  loadI2LNode *node = new (C) loadI2LNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void convI2L_reg_reg_zexNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *convI2L_reg_reg_zexNode::cisc_version( int offset, Compile* C ) {
  convI2L_reg_mem_zexNode *node = new (C) convI2L_reg_mem_zexNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void MoveF2I_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_FLOAT_REG_mask;
}

// Build CISC version of this instruction
MachNode *MoveF2I_reg_regNode::cisc_version( int offset, Compile* C ) {
  MoveF2I_stack_regNode *node = new (C) MoveF2I_stack_regNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void MoveD2L_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_DOUBLE_REG_mask;
}

// Build CISC version of this instruction
MachNode *MoveD2L_reg_regNode::cisc_version( int offset, Compile* C ) {
  MoveD2L_stack_regNode *node = new (C) MoveD2L_stack_regNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void MoveI2F_reg_regNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *MoveI2F_reg_regNode::cisc_version( int offset, Compile* C ) {
  MoveI2F_stack_regNode *node = new (C) MoveI2F_stack_regNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void compI_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *compI_rRegNode::cisc_version( int offset, Compile* C ) {
  compI_rReg_memNode *node = new (C) compI_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void compU_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_INT_REG_mask;
}

// Build CISC version of this instruction
MachNode *compU_rRegNode::cisc_version( int offset, Compile* C ) {
  compU_rReg_memNode *node = new (C) compU_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void compP_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_PTR_REG_mask;
}

// Build CISC version of this instruction
MachNode *compP_rRegNode::cisc_version( int offset, Compile* C ) {
  compP_rReg_memNode *node = new (C) compP_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}


void compL_rRegNode::use_cisc_RegMask() {
  _cisc_RegMask = &STACK_OR_LONG_REG_mask;
}

// Build CISC version of this instruction
MachNode *compL_rRegNode::cisc_version( int offset, Compile* C ) {
  compL_rReg_memNode *node = new (C) compL_rReg_memNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  // Construct operand to access [stack_pointer + offset]
  node->set_opnd_array(cisc_operand(), new (C) indOffset32Oper(offset));

  return node;
}

// Build short branch version of this instruction
MachNode *jmpDirNode::short_branch_version(Compile* C) {
  jmpDir_shortNode *node = new (C) jmpDir_shortNode();

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  return node;
}

// Build short branch version of this instruction
MachNode *jmpConNode::short_branch_version(Compile* C) {
  jmpCon_shortNode *node = new (C) jmpCon_shortNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  return node;
}

// Build short branch version of this instruction
MachNode *jmpLoopEndNode::short_branch_version(Compile* C) {
  jmpLoopEnd_shortNode *node = new (C) jmpLoopEnd_shortNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  return node;
}

// Build short branch version of this instruction
MachNode *jmpLoopEndUNode::short_branch_version(Compile* C) {
  jmpLoopEndU_shortNode *node = new (C) jmpLoopEndU_shortNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  return node;
}

// Build short branch version of this instruction
MachNode *jmpLoopEndUCFNode::short_branch_version(Compile* C) {
  jmpLoopEndUCF_shortNode *node = new (C) jmpLoopEndUCF_shortNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  return node;
}

// Build short branch version of this instruction
MachNode *jmpConUNode::short_branch_version(Compile* C) {
  jmpConU_shortNode *node = new (C) jmpConU_shortNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  return node;
}

// Build short branch version of this instruction
MachNode *jmpConUCFNode::short_branch_version(Compile* C) {
  jmpConUCF_shortNode *node = new (C) jmpConUCF_shortNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  return node;
}

// Build short branch version of this instruction
MachNode *jmpConUCF2Node::short_branch_version(Compile* C) {
  jmpConUCF2_shortNode *node = new (C) jmpConUCF2_shortNode();
  node->_prob = _prob;
  node->_fcnt = _fcnt;

  // Copy _idx, inputs and operands to new node
  fill_new_machnode(node, C);
  return node;
}


// Copy _idx, inputs and operands to new node
void MachNode::fill_new_machnode( MachNode* node, Compile* C) const {
  // New node must use same node index
  node->set_idx( _idx );
  // Copy machine-independent inputs
  for( uint j = 0; j < req(); j++ ) {
    node->add_req(in(j));
  }
  // Copy my operands, except for cisc position
  int nopnds = num_opnds();
  assert( node->num_opnds() == (uint)nopnds, "Must have same number of operands");
  MachOper **to = node->_opnds;
  for( int i = 0; i < nopnds; i++ ) {
    if( i != cisc_operand() ) 
      to[i] = _opnds[i]->clone(C);
  }
}

void jmpDirNode::label_set( Label& label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(1));
  oper->_label     = &label;
  oper->_block_num = block_num;
}
void jmpConNode::label_set( Label& label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = &label;
  oper->_block_num = block_num;
}
void jmpLoopEndNode::label_set( Label& label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = &label;
  oper->_block_num = block_num;
}
void jmpLoopEndUNode::label_set( Label& label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = &label;
  oper->_block_num = block_num;
}
void jmpLoopEndUCFNode::label_set( Label& label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = &label;
  oper->_block_num = block_num;
}
void jmpConUNode::label_set( Label& label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = &label;
  oper->_block_num = block_num;
}
void jmpConUCFNode::label_set( Label& label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = &label;
  oper->_block_num = block_num;
}
void jmpConUCF2Node::label_set( Label& label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = &label;
  oper->_block_num = block_num;
}
void jmpDir_shortNode::label_set( Label& label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(1));
  oper->_label     = &label;
  oper->_block_num = block_num;
}
void jmpCon_shortNode::label_set( Label& label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = &label;
  oper->_block_num = block_num;
}
void jmpLoopEnd_shortNode::label_set( Label& label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = &label;
  oper->_block_num = block_num;
}
void jmpLoopEndU_shortNode::label_set( Label& label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = &label;
  oper->_block_num = block_num;
}
void jmpLoopEndUCF_shortNode::label_set( Label& label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = &label;
  oper->_block_num = block_num;
}
void jmpConU_shortNode::label_set( Label& label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = &label;
  oper->_block_num = block_num;
}
void jmpConUCF_shortNode::label_set( Label& label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = &label;
  oper->_block_num = block_num;
}
void jmpConUCF2_shortNode::label_set( Label& label, uint block_num ) {
  labelOper* oper  = (labelOper*)(opnd_array(3));
  oper->_label     = &label;
  oper->_block_num = block_num;
}
void CallStaticJavaDirectNode::method_set( intptr_t method ) {
  ((methodOper*)opnd_array(1))->_method = method;
}

void CallStaticJavaHandleNode::method_set( intptr_t method ) {
  ((methodOper*)opnd_array(1))->_method = method;
}

void CallDynamicJavaDirectNode::method_set( intptr_t method ) {
  ((methodOper*)opnd_array(1))->_method = method;
}

void CallRuntimeDirectNode::method_set( intptr_t method ) {
  ((methodOper*)opnd_array(1))->_method = method;
}

void CallLeafDirectNode::method_set( intptr_t method ) {
  ((methodOper*)opnd_array(1))->_method = method;
}

void CallLeafNoFPDirectNode::method_set( intptr_t method ) {
  ((methodOper*)opnd_array(1))->_method = method;
}

int  loadBNode::reloc()   const {
  return  1;
}

int  loadB2LNode::reloc()   const {
  return  1;
}

int  loadUBNode::reloc()   const {
  return  1;
}

int  loadUB2LNode::reloc()   const {
  return  1;
}

int  loadUB2L_immI8Node::reloc()   const {
  return  1;
}

int  loadSNode::reloc()   const {
  return  1;
}

int  loadS2BNode::reloc()   const {
  return  1;
}

int  loadS2LNode::reloc()   const {
  return  1;
}

int  loadUSNode::reloc()   const {
  return  1;
}

int  loadUS2BNode::reloc()   const {
  return  1;
}

int  loadUS2LNode::reloc()   const {
  return  1;
}

int  loadUS2L_immI_255Node::reloc()   const {
  return  1;
}

int  loadUS2L_immI16Node::reloc()   const {
  return  1;
}

int  loadINode::reloc()   const {
  return  1;
}

int  loadI2BNode::reloc()   const {
  return  1;
}

int  loadI2UBNode::reloc()   const {
  return  1;
}

int  loadI2SNode::reloc()   const {
  return  1;
}

int  loadI2USNode::reloc()   const {
  return  1;
}

int  loadI2LNode::reloc()   const {
  return  1;
}

int  loadI2L_immI_255Node::reloc()   const {
  return  1;
}

int  loadI2L_immI_65535Node::reloc()   const {
  return  1;
}

int  loadI2L_immINode::reloc()   const {
  return  1;
}

int  loadUI2LNode::reloc()   const {
  return  1;
}

int  loadLNode::reloc()   const {
  return  1;
}

int  loadRangeNode::reloc()   const {
  return  1;
}

int  loadPNode::reloc()   const {
  return  1;
}

int  loadNNode::reloc()   const {
  return  1;
}

int  loadKlassNode::reloc()   const {
  return  1;
}

int  loadNKlassNode::reloc()   const {
  return  1;
}

int  loadFNode::reloc()   const {
  return  1;
}

int  loadD_partialNode::reloc()   const {
  return  1;
}

int  loadDNode::reloc()   const {
  return  1;
}

int  loadA8BNode::reloc()   const {
  return  1;
}

int  loadA4SNode::reloc()   const {
  return  1;
}

int  loadA4CNode::reloc()   const {
  return  1;
}

int  load2IUNode::reloc()   const {
  return  1;
}

int  loadA2FNode::reloc()   const {
  return  1;
}

int  loadConPNode::reloc()   const {
  return  1;
}

int  loadConP0Node::reloc()   const {
  return  1;
}

int  loadConP_pollNode::reloc()   const {
  return  1;
}

int  loadConP31Node::reloc()   const {
  return  1;
}

int  loadConFNode::reloc()   const {
  return  2;
}

int  loadConF0Node::reloc()   const {
  return  2;
}

int  loadConDNode::reloc()   const {
  return  2;
}

int  loadConD0Node::reloc()   const {
  return  2;
}

int  prefetchrNode::reloc()   const {
  return  1;
}

int  prefetchrNTANode::reloc()   const {
  return  1;
}

int  prefetchrT0Node::reloc()   const {
  return  1;
}

int  prefetchrT2Node::reloc()   const {
  return  1;
}

int  prefetchwNode::reloc()   const {
  return  1;
}

int  prefetchwNTANode::reloc()   const {
  return  1;
}

int  prefetchwT0Node::reloc()   const {
  return  1;
}

int  prefetchwT2Node::reloc()   const {
  return  1;
}

int  storeBNode::reloc()   const {
  return  2;
}

int  storeCNode::reloc()   const {
  return  2;
}

int  storeINode::reloc()   const {
  return  2;
}

int  storeLNode::reloc()   const {
  return  2;
}

int  storePNode::reloc()   const {
  return  2;
}

int  storeImmP0Node::reloc()   const {
  return  3;
}

int  storeImmPNode::reloc()   const {
  return  3;
}

int  storeNNode::reloc()   const {
  return  2;
}

int  storeImmN0Node::reloc()   const {
  return  2;
}

int  storeImmNNode::reloc()   const {
  return  2;
}

int  storeImmI0Node::reloc()   const {
  return  2;
}

int  storeImmINode::reloc()   const {
  return  2;
}

int  storeImmL0Node::reloc()   const {
  return  2;
}

int  storeImmLNode::reloc()   const {
  return  2;
}

int  storeImmC0Node::reloc()   const {
  return  2;
}

int  storeImmI16Node::reloc()   const {
  return  2;
}

int  storeImmB0Node::reloc()   const {
  return  2;
}

int  storeImmBNode::reloc()   const {
  return  2;
}

int  storeA8BNode::reloc()   const {
  return  2;
}

int  storeA4CNode::reloc()   const {
  return  2;
}

int  storeA2INode::reloc()   const {
  return  2;
}

int  storeImmCM0_regNode::reloc()   const {
  return  2;
}

int  storeImmCM0Node::reloc()   const {
  return  2;
}

int  storeA2FNode::reloc()   const {
  return  2;
}

int  storeFNode::reloc()   const {
  return  2;
}

int  storeF0Node::reloc()   const {
  return  3;
}

int  storeF_immNode::reloc()   const {
  return  3;
}

int  storeDNode::reloc()   const {
  return  2;
}

int  storeD0_immNode::reloc()   const {
  return  3;
}

int  storeD0Node::reloc()   const {
  return  3;
}

int  popCountI_memNode::reloc()   const {
  return  1;
}

int  popCountL_memNode::reloc()   const {
  return  1;
}

int  cmovI_memNode::reloc()   const {
  return  1;
}

int  cmovI_memUNode::reloc()   const {
  return  1;
}

int  cmovI_memUCFNode::reloc()   const {
  return  1;
}

int  cmovL_memNode::reloc()   const {
  return  1;
}

int  cmovL_memUNode::reloc()   const {
  return  1;
}

int  cmovL_memUCFNode::reloc()   const {
  return  1;
}

int  addI_rReg_memNode::reloc()   const {
  return  1;
}

int  addI_rReg_mem_0Node::reloc()   const {
  return  1;
}

int  addI_mem_rRegNode::reloc()   const {
  return  3;
}

int  addI_mem_rReg_0Node::reloc()   const {
  return  3;
}

int  addI_mem_immNode::reloc()   const {
  return  3;
}

int  incI_memNode::reloc()   const {
  return  3;
}

int  decI_memNode::reloc()   const {
  return  3;
}

int  addL_rReg_memNode::reloc()   const {
  return  1;
}

int  addL_rReg_mem_0Node::reloc()   const {
  return  1;
}

int  addL_mem_rRegNode::reloc()   const {
  return  3;
}

int  addL_mem_rReg_0Node::reloc()   const {
  return  3;
}

int  addL_mem_immNode::reloc()   const {
  return  3;
}

int  incL_memNode::reloc()   const {
  return  3;
}

int  decL_memNode::reloc()   const {
  return  3;
}

int  loadPLockedNode::reloc()   const {
  return  1;
}

int  loadLLockedNode::reloc()   const {
  return  1;
}

int  storePConditionalNode::reloc()   const {
  return  1;
}

int  storeIConditionalNode::reloc()   const {
  return  1;
}

int  storeLConditionalNode::reloc()   const {
  return  1;
}

int  compareAndSwapPNode::reloc()   const {
  return  1;
}

int  compareAndSwapLNode::reloc()   const {
  return  1;
}

int  compareAndSwapINode::reloc()   const {
  return  1;
}

int  compareAndSwapNNode::reloc()   const {
  return  1;
}

int  subI_rReg_memNode::reloc()   const {
  return  1;
}

int  subI_mem_rRegNode::reloc()   const {
  return  3;
}

int  subI_mem_immNode::reloc()   const {
  return  3;
}

int  subL_rReg_memNode::reloc()   const {
  return  1;
}

int  subL_mem_rRegNode::reloc()   const {
  return  3;
}

int  subL_mem_immNode::reloc()   const {
  return  3;
}

int  negI_memNode::reloc()   const {
  return  3;
}

int  negL_memNode::reloc()   const {
  return  3;
}

int  mulI_memNode::reloc()   const {
  return  1;
}

int  mulI_mem_0Node::reloc()   const {
  return  1;
}

int  mulI_mem_immNode::reloc()   const {
  return  1;
}

int  mulL_memNode::reloc()   const {
  return  1;
}

int  mulL_mem_0Node::reloc()   const {
  return  1;
}

int  mulL_mem_immNode::reloc()   const {
  return  1;
}

int  salI_mem_1Node::reloc()   const {
  return  3;
}

int  salI_mem_immNode::reloc()   const {
  return  3;
}

int  salI_mem_CLNode::reloc()   const {
  return  3;
}

int  sarI_mem_1Node::reloc()   const {
  return  3;
}

int  sarI_mem_immNode::reloc()   const {
  return  3;
}

int  sarI_mem_CLNode::reloc()   const {
  return  3;
}

int  shrI_mem_1Node::reloc()   const {
  return  3;
}

int  shrI_mem_immNode::reloc()   const {
  return  3;
}

int  shrI_mem_CLNode::reloc()   const {
  return  3;
}

int  salL_mem_1Node::reloc()   const {
  return  3;
}

int  salL_mem_immNode::reloc()   const {
  return  3;
}

int  salL_mem_CLNode::reloc()   const {
  return  3;
}

int  sarL_mem_1Node::reloc()   const {
  return  3;
}

int  sarL_mem_immNode::reloc()   const {
  return  3;
}

int  sarL_mem_CLNode::reloc()   const {
  return  3;
}

int  shrL_mem_1Node::reloc()   const {
  return  3;
}

int  shrL_mem_immNode::reloc()   const {
  return  3;
}

int  shrL_mem_CLNode::reloc()   const {
  return  3;
}

int  andI_rReg_memNode::reloc()   const {
  return  1;
}

int  andI_rReg_mem_0Node::reloc()   const {
  return  1;
}

int  andI_mem_rRegNode::reloc()   const {
  return  3;
}

int  andI_mem_rReg_0Node::reloc()   const {
  return  3;
}

int  andI_mem_immNode::reloc()   const {
  return  3;
}

int  orI_rReg_memNode::reloc()   const {
  return  1;
}

int  orI_rReg_mem_0Node::reloc()   const {
  return  1;
}

int  orI_mem_rRegNode::reloc()   const {
  return  3;
}

int  orI_mem_rReg_0Node::reloc()   const {
  return  3;
}

int  orI_mem_immNode::reloc()   const {
  return  3;
}

int  xorI_rReg_memNode::reloc()   const {
  return  1;
}

int  xorI_rReg_mem_0Node::reloc()   const {
  return  1;
}

int  xorI_mem_rRegNode::reloc()   const {
  return  3;
}

int  xorI_mem_rReg_0Node::reloc()   const {
  return  3;
}

int  xorI_mem_immNode::reloc()   const {
  return  3;
}

int  andL_rReg_memNode::reloc()   const {
  return  1;
}

int  andL_rReg_mem_0Node::reloc()   const {
  return  1;
}

int  andL_mem_rRegNode::reloc()   const {
  return  3;
}

int  andL_mem_rReg_0Node::reloc()   const {
  return  3;
}

int  andL_mem_immNode::reloc()   const {
  return  3;
}

int  orL_rReg_memNode::reloc()   const {
  return  1;
}

int  orL_rReg_mem_0Node::reloc()   const {
  return  1;
}

int  orL_mem_rRegNode::reloc()   const {
  return  3;
}

int  orL_mem_rReg_0Node::reloc()   const {
  return  3;
}

int  orL_mem_immNode::reloc()   const {
  return  3;
}

int  xorL_rReg_memNode::reloc()   const {
  return  1;
}

int  xorL_rReg_mem_0Node::reloc()   const {
  return  1;
}

int  xorL_mem_rRegNode::reloc()   const {
  return  3;
}

int  xorL_mem_rReg_0Node::reloc()   const {
  return  3;
}

int  xorL_mem_immNode::reloc()   const {
  return  3;
}

int  cmpF_cc_memNode::reloc()   const {
  return  1;
}

int  cmpF_cc_memCFNode::reloc()   const {
  return  1;
}

int  cmpF_cc_immNode::reloc()   const {
  return  1;
}

int  cmpF_cc_immCFNode::reloc()   const {
  return  1;
}

int  cmpD_cc_memNode::reloc()   const {
  return  1;
}

int  cmpD_cc_memCFNode::reloc()   const {
  return  1;
}

int  cmpD_cc_immNode::reloc()   const {
  return  1;
}

int  cmpD_cc_immCFNode::reloc()   const {
  return  1;
}

int  cmpF_memNode::reloc()   const {
  return  1;
}

int  cmpF_immNode::reloc()   const {
  return  1;
}

int  cmpD_memNode::reloc()   const {
  return  1;
}

int  cmpD_immNode::reloc()   const {
  return  1;
}

int  addF_memNode::reloc()   const {
  return  1;
}

int  addF_mem_0Node::reloc()   const {
  return  1;
}

int  addF_immNode::reloc()   const {
  return  1;
}

int  addD_memNode::reloc()   const {
  return  1;
}

int  addD_mem_0Node::reloc()   const {
  return  1;
}

int  addD_immNode::reloc()   const {
  return  1;
}

int  subF_memNode::reloc()   const {
  return  1;
}

int  subF_immNode::reloc()   const {
  return  1;
}

int  subD_memNode::reloc()   const {
  return  1;
}

int  subD_immNode::reloc()   const {
  return  1;
}

int  mulF_memNode::reloc()   const {
  return  1;
}

int  mulF_mem_0Node::reloc()   const {
  return  1;
}

int  mulF_immNode::reloc()   const {
  return  1;
}

int  mulD_memNode::reloc()   const {
  return  1;
}

int  mulD_mem_0Node::reloc()   const {
  return  1;
}

int  mulD_immNode::reloc()   const {
  return  1;
}

int  divF_memNode::reloc()   const {
  return  1;
}

int  divF_immNode::reloc()   const {
  return  1;
}

int  divD_memNode::reloc()   const {
  return  1;
}

int  divD_immNode::reloc()   const {
  return  1;
}

int  sqrtF_memNode::reloc()   const {
  return  1;
}

int  sqrtF_immNode::reloc()   const {
  return  1;
}

int  sqrtD_memNode::reloc()   const {
  return  1;
}

int  sqrtD_immNode::reloc()   const {
  return  1;
}

int  convF2D_reg_memNode::reloc()   const {
  return  1;
}

int  convD2F_reg_memNode::reloc()   const {
  return  1;
}

int  convI2F_reg_memNode::reloc()   const {
  return  1;
}

int  convI2D_reg_memNode::reloc()   const {
  return  1;
}

int  convL2F_reg_memNode::reloc()   const {
  return  1;
}

int  convL2D_reg_memNode::reloc()   const {
  return  1;
}

int  convI2L_reg_mem_zexNode::reloc()   const {
  return  1;
}

int  Repl2F_immF0Node::reloc()   const {
  return  1;
}

int  compI_rReg_memNode::reloc()   const {
  return  1;
}

int  testI_reg_memNode::reloc()   const {
  return  1;
}

int  testI_reg_mem_0Node::reloc()   const {
  return  1;
}

int  compU_rReg_memNode::reloc()   const {
  return  1;
}

int  compP_rReg_memNode::reloc()   const {
  return  1;
}

int  compP_mem_rRegNode::reloc()   const {
  return  1;
}

int  testP_regNode::reloc()   const {
  return  1;
}

int  testP_memNode::reloc()   const {
  return  2;
}

int  testP_mem_reg0Node::reloc()   const {
  return  2;
}

int  compN_rReg_memNode::reloc()   const {
  return  1;
}

int  compN_mem_immNode::reloc()   const {
  return  1;
}

int  testN_memNode::reloc()   const {
  return  1;
}

int  testN_mem_reg0Node::reloc()   const {
  return  1;
}

int  compL_rReg_memNode::reloc()   const {
  return  1;
}

int  testL_reg_memNode::reloc()   const {
  return  1;
}

int  testL_reg_mem_0Node::reloc()   const {
  return  1;
}

int  partialSubtypeCheck_vs_ZeroNode::reloc()   const {
  return  1;
}

int  safePoint_pollNode::reloc()   const {
  return  1;
}

int  safePoint_poll_farNode::reloc()   const {
  return  1;
}

int  CallStaticJavaDirectNode::reloc()   const {
  return  1;
}

int  CallStaticJavaHandleNode::reloc()   const {
  return  1;
}

int  CallDynamicJavaDirectNode::reloc()   const {
  return  1;
}

int  CallRuntimeDirectNode::reloc()   const {
  return  1;
}

int  CallLeafDirectNode::reloc()   const {
  return  1;
}

int  CallLeafNoFPDirectNode::reloc()   const {
  return  1;
}

int  RetNode::reloc()   const {
  return  1;
}

int  TailCalljmpIndNode::reloc()   const {
  return  1;
}

int  tailjmpIndNode::reloc()   const {
  return  1;
}

int  RethrowExceptionNode::reloc()   const {
  return  1;
}


void loadBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {
    MacroAssembler _masm(&cbuf);

#line 5782 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movsbl(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9146 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadB2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {
    MacroAssembler _masm(&cbuf);

#line 5797 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movsbq(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9161 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadUBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {
    MacroAssembler _masm(&cbuf);

#line 5812 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movzbl(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9176 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadUB2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {
    MacroAssembler _masm(&cbuf);

#line 5827 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movzbq(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9191 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadUB2L_immI8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 5841 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register Rdst = opnd_array(0)->as_Register(ra_,this);
    __ movzbq(Rdst, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
    __ andl(Rdst, opnd_array(2)->constant());
  
#line 9209 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {
    MacroAssembler _masm(&cbuf);

#line 5857 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movswl(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9224 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadS2BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 5870 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movsbl(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9240 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadS2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {
    MacroAssembler _masm(&cbuf);

#line 5884 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movswq(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9255 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadUSNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {
    MacroAssembler _masm(&cbuf);

#line 5899 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movzwl(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9270 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadUS2BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 5912 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movsbl(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9286 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadUS2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {
    MacroAssembler _masm(&cbuf);

#line 5926 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movzwq(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9301 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadUS2L_immI_255Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 5938 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movzbq(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9317 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadUS2L_immI16Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 5951 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register Rdst = opnd_array(0)->as_Register(ra_,this);
    __ movzwq(Rdst, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
    __ andl(Rdst, opnd_array(2)->constant());
  
#line 9335 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {
    MacroAssembler _masm(&cbuf);

#line 5967 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movl(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9350 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadI2BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 5980 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movsbl(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9366 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadI2UBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 5992 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movzbl(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9382 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadI2SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 6004 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movswl(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9398 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadI2USNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 6016 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movzwl(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9414 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadI2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {
    MacroAssembler _masm(&cbuf);

#line 6030 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movslq(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9429 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadI2L_immI_255Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 6042 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movzbq(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9445 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadI2L_immI_65535Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 6053 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movzwq(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9461 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadI2L_immINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 6066 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register Rdst = opnd_array(0)->as_Register(ra_,this);
    __ movl(Rdst, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
    __ andl(Rdst, opnd_array(2)->constant());
  
#line 9479 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadUI2LNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {
    MacroAssembler _masm(&cbuf);

#line 6082 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movl(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9494 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {
    MacroAssembler _masm(&cbuf);

#line 6097 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movq(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9509 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadRangeNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 9549 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 9557 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 9573 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 9615 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 9623 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 9639 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {
    MacroAssembler _masm(&cbuf);

#line 6135 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

     __ movl(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
   
#line 9654 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadKlassNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 9696 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 9704 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 9720 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadNKlassNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {
    MacroAssembler _masm(&cbuf);

#line 6161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movl(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9735 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 9749 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 9783 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 9791 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x10 /*tertiary()*/));
  
#line 9799 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 9815 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadD_partialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x66 /*primary()*/));
  
#line 9829 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 9863 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 9871 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x12 /*tertiary()*/));
  
#line 9879 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 9895 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 9909 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 9943 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 9951 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x10 /*tertiary()*/));
  
#line 9959 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 9975 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadA8BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3274 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);
    __ movq(opnd_array(0)->as_XMMRegister(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 9990 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadA4SNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3274 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);
    __ movq(opnd_array(0)->as_XMMRegister(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 10005 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadA4CNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3274 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);
    __ movq(opnd_array(0)->as_XMMRegister(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 10020 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void load2IUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3274 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);
    __ movq(opnd_array(0)->as_XMMRegister(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 10035 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadA2FNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3274 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);
    __ movq(opnd_array(0)->as_XMMRegister(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 10050 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void leaP8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 10092 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 10100 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 10116 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void leaP32Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 10158 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 10166 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 10182 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void leaPIdxOffNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 10224 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 10232 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 10248 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void leaPIdxScaleNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 10290 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 10298 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 10314 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void leaPIdxScaleOffNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 10356 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 10364 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 10380 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void leaPPosIdxScaleOffNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 10422 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 10430 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 10446 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void leaPCompressedOopOffsetNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 10488 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 10496 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 10512 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void leaP8NarrowNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 10554 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 10562 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 10578 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void leaP32NarrowNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 10620 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 10628 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 10644 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void leaPIdxOffNarrowNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 10686 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 10694 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 10710 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void leaPIdxScaleNarrowNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 10752 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 10760 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 10776 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void leaPIdxScaleOffNarrowNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 10818 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 10826 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 10842 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void leaPPosIdxScaleOffNarrowNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 10884 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 10892 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 10908 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2689 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xB8 | dstenc);
    emit_d32(cbuf, opnd_array(1)->constant());
  
#line 10928 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConI0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(0)->reg(ra_,this) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 10952 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 10960 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(0)->reg(ra_,this) & 7);
  
#line 10968 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2700 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xB8 | dstenc);
    emit_d64(cbuf, opnd_array(1)->constantL());
  
#line 10990 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConL0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(0)->reg(ra_,this) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 11014 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 11022 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(0)->reg(ra_,this) & 7);
  
#line 11030 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConUL32Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2713 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // same as load_immI, but this time we care about zeroes in the high word
    int dstenc = opnd_array(0)->reg(ra_,this);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xB8 | dstenc);
    emit_d32(cbuf, opnd_array(1)->constantL());
  
#line 11051 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConL32Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2725 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xC7);
    emit_rm(cbuf, 0x03, 0x00, dstenc);
    emit_d32(cbuf, opnd_array(1)->constantL());
  
#line 11074 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2751 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xB8 | dstenc);
    // This next line should be generated from ADLC
    if (opnd_array(1)->constant_is_oop()) {
      emit_d64_reloc(cbuf, opnd_array(1)->constant(), relocInfo::oop_type, RELOC_IMM64);
    } else {
      emit_d64(cbuf, opnd_array(1)->constant());
    }
  
#line 11101 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConP0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(0)->reg(ra_,this) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 11125 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 11133 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(0)->reg(ra_,this) & 7);
  
#line 11141 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConP_pollNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 6498 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_type);
    __ lea(opnd_array(0)->as_Register(ra_,this), polling_page);
  
#line 11157 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConP31Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2739 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // same as load_immI, but this time we care about zeroes in the high word
    int dstenc = opnd_array(0)->reg(ra_,this);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xB8 | dstenc);
    
if ( opnd_array(1)->constant_is_oop() ) {
  emit_d32_reloc(cbuf, opnd_array(1)->constant(), relocInfo::oop_type, 0);
} else {
  emit_d32(cbuf, opnd_array(1)->constant());
};
  
#line 11183 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 6520 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movflt(opnd_array(0)->as_XMMRegister(ra_,this), InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 11198 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConFNode::eval_constant(Compile* C) {
  {

#line 6521 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(1));
#line 11206 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConN0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 6530 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ xorq(opnd_array(0)->as_Register(ra_,this), opnd_array(0)->as_Register(ra_,this));
  
#line 11221 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 6541 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    address con = (address)opnd_array(1)->constant();
    if (con == NULL) {
      ShouldNotReachHere();
    } else {
      __ set_narrow_oop(opnd_array(0)->as_Register(ra_,this), (jobject)opnd_array(1)->constant());
    }
  
#line 11241 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConF0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(0)->reg(ra_,this) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 11265 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 11273 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x57 /*secondary()*/));
  
#line 11281 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(0)->reg(ra_,this) & 7);
  
#line 11289 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 6568 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movdbl(opnd_array(0)->as_XMMRegister(ra_,this), InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 11304 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConDNode::eval_constant(Compile* C) {
  {

#line 6569 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(1));
#line 11312 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConD0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x66 /*primary()*/));
  
#line 11326 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(0)->reg(ra_,this) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 11344 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 11352 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x57 /*tertiary()*/));
  
#line 11360 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(0)->reg(ra_,this) & 7);
  
#line 11368 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadSSINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 11408 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 11416 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 11432 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadSSLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 11474 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 11482 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 11498 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadSSPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 11540 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 11548 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 11564 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadSSFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 11578 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 11612 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 11620 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x10 /*tertiary()*/));
  
#line 11628 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 11644 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadSSDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 6636 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movdbl(opnd_array(0)->as_XMMRegister(ra_,this), Address(rsp, opnd_array(1)->disp(ra_,this,idx1)));
  
#line 11659 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void prefetchrNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 11683 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 11691 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0D /*secondary()*/));
  
#line 11699 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 11719 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void prefetchrNTANode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 11743 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 11751 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x18 /*secondary()*/));
  
#line 11759 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 11779 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void prefetchrT0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 11803 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 11811 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x18 /*secondary()*/));
  
#line 11819 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x01);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 11839 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void prefetchrT2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 11863 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 11871 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x18 /*secondary()*/));
  
#line 11879 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x03);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 11899 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void prefetchwNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 11923 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 11931 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0D /*secondary()*/));
  
#line 11939 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x01);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 11959 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void prefetchwNTANode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 11983 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 11991 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x18 /*secondary()*/));
  
#line 11999 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 12019 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void prefetchwT0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 12043 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 12051 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x18 /*secondary()*/));
  
#line 12059 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x01);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 12079 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void prefetchwT2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 12103 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 12111 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x18 /*secondary()*/));
  
#line 12119 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x03);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 12139 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2933 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        } else if (opnd_array(2)->reg(ra_,this,idx2) >= 4) {
          emit_opcode(cbuf, Assembler::REX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 12182 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x88 /*primary()*/));
  
#line 12190 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 12206 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeCNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2167 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, 0x66);
  
#line 12221 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 12255 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x89 /*primary()*/));
  
#line 12263 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 12279 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 12320 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x89 /*primary()*/));
  
#line 12328 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 12344 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 12387 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x89 /*primary()*/));
  
#line 12395 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 12411 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storePNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 12454 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x89 /*primary()*/));
  
#line 12462 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 12478 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeImmP0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 6802 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movq(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), r12);
  
#line 12494 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeImmPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 12521 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xC7 /*primary()*/));
  
#line 12529 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 12549 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2831 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Output immediate
    
if ( opnd_array(2)->constant_is_oop() ) {
  emit_d32_reloc(cbuf, opnd_array(2)->constant(), relocInfo::oop_type, 0);
} else {
  emit_d32(cbuf, opnd_array(2)->constant());
};
  
#line 12563 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 6827 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), opnd_array(2)->as_Register(ra_,this,idx2));
  
#line 12579 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeImmN0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 6840 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), r12);
  
#line 12595 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeImmNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 6852 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    address con = (address)opnd_array(2)->constant();
    if (con == NULL) {
      __ movl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), (int32_t)0);
    } else {
      __ set_narrow_oop(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), (jobject)opnd_array(2)->constant());
    }
  
#line 12616 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeImmI0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 6871 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), r12);
  
#line 12632 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeImmINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 12657 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xC7 /*primary()*/));
  
#line 12665 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 12685 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2831 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Output immediate
    emit_d32(cbuf, opnd_array(2)->constant());
  
#line 12694 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeImmL0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 6896 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movq(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), r12);
  
#line 12710 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeImmLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 12737 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xC7 /*primary()*/));
  
#line 12745 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 12765 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2831 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Output immediate
    emit_d32(cbuf, opnd_array(2)->constantL());
  
#line 12774 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeImmC0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 6921 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movw(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), r12);
  
#line 12790 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeImmI16Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2167 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, 0x66);
  
#line 12805 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 12823 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xC7 /*primary()*/));
  
#line 12831 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 12851 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2851 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Output immediate
    emit_d16(cbuf, opnd_array(2)->constant());
  
#line 12860 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeImmB0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 6947 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movb(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), r12);
  
#line 12876 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeImmBNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 12901 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xC6 /*primary()*/));
  
#line 12909 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 12929 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 12943 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeA8BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3279 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);
    __ movq(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), opnd_array(2)->as_XMMRegister(ra_,this,idx2));
  
#line 12959 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeA4CNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3279 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);
    __ movq(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), opnd_array(2)->as_XMMRegister(ra_,this,idx2));
  
#line 12975 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeA2INode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3279 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);
    __ movq(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), opnd_array(2)->as_XMMRegister(ra_,this,idx2));
  
#line 12991 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeImmCM0_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 6999 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movb(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), r12);
  
#line 13007 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeImmCM0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 13032 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xC6 /*primary()*/));
  
#line 13040 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 13060 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 13074 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeA2FNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3279 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);
    __ movq(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), opnd_array(2)->as_XMMRegister(ra_,this,idx2));
  
#line 13090 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 13105 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 13139 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 13147 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x11 /*tertiary()*/));
  
#line 13155 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 13171 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeF0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 7045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), r12);
  
#line 13187 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeF_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 13212 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xC7 /*primary()*/));
  
#line 13220 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 13240 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2843 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Output Float immediate bits
    jfloat jf = opnd_array(2)->constantF();
    jint jf_as_bits = jint_cast(jf);
    emit_d32(cbuf, jf_as_bits);
  
#line 13251 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 13266 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 13300 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 13308 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x11 /*tertiary()*/));
  
#line 13316 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 13332 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeD0_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 13359 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xC7 /*primary()*/));
  
#line 13367 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 13387 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2843 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Output Float immediate bits
    jfloat jf = opnd_array(2)->constantD();
    jint jf_as_bits = jint_cast(jf);
    emit_d32(cbuf, jf_as_bits);
  
#line 13398 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeD0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 7094 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movq(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), r12);
  
#line 13414 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeSSINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 13454 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x89 /*primary()*/));
  
#line 13462 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(0)->base(ra_,this,idx0);
    int index = opnd_array(0)->index(ra_,this,idx0);
    int scale = opnd_array(0)->scale();
    int disp = opnd_array(0)->disp(ra_,this,0);
    bool disp_is_oop = opnd_array(0)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 13478 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeSSLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 13520 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x89 /*primary()*/));
  
#line 13528 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(0)->base(ra_,this,idx0);
    int index = opnd_array(0)->index(ra_,this,idx0);
    int scale = opnd_array(0)->scale();
    int disp = opnd_array(0)->disp(ra_,this,0);
    bool disp_is_oop = opnd_array(0)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 13544 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeSSPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 13586 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x89 /*primary()*/));
  
#line 13594 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(0)->base(ra_,this,idx0);
    int index = opnd_array(0)->index(ra_,this,idx0);
    int scale = opnd_array(0)->scale();
    int disp = opnd_array(0)->disp(ra_,this,0);
    bool disp_is_oop = opnd_array(0)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 13610 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeSSFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 13624 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 13658 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 13666 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x11 /*tertiary()*/));
  
#line 13674 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(0)->base(ra_,this,idx0);
    int index = opnd_array(0)->index(ra_,this,idx0);
    int scale = opnd_array(0)->scale();
    int disp = opnd_array(0)->disp(ra_,this,0);
    bool disp_is_oop = opnd_array(0)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 13690 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeSSDNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 13704 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 13738 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 13746 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x11 /*tertiary()*/));
  
#line 13754 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(0)->base(ra_,this,idx0);
    int index = opnd_array(0)->index(ra_,this,idx0);
    int scale = opnd_array(0)->scale();
    int disp = opnd_array(0)->disp(ra_,this,0);
    bool disp_is_oop = opnd_array(0)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 13770 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void bytes_reverse_intNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 13786 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 13794 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2446 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // BSWAP
    emit_cc(cbuf, (0xC8 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1));
  
#line 13803 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void bytes_reverse_longNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 13821 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 13829 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2446 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // BSWAP
    emit_cc(cbuf, (0xC8 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1));
  
#line 13838 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void bytes_reverse_unsigned_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 7180 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ bswapl(opnd_array(1)->as_Register(ra_,this,idx1));
    __ shrl(opnd_array(1)->as_Register(ra_,this,idx1), 16);
  
#line 13854 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void bytes_reverse_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 7192 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ bswapl(opnd_array(1)->as_Register(ra_,this,idx1));
    __ sarl(opnd_array(1)->as_Register(ra_,this,idx1), 16);
  
#line 13870 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void countLeadingZerosINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 7207 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ lzcntl(opnd_array(0)->as_Register(ra_,this), opnd_array(1)->as_Register(ra_,this,idx1));
  
#line 13885 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void countLeadingZerosI_bsrNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 7224 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register Rdst = opnd_array(0)->as_Register(ra_,this);
    Register Rsrc = opnd_array(1)->as_Register(ra_,this,idx1);
    Label skip;
    __ bsrl(Rdst, Rsrc);
    __ jccb(Assembler::notZero, skip);
    __ movl(Rdst, -1);
    __ bind(skip);
    __ negl(Rdst);
    __ addl(Rdst, BitsPerInt - 1);
  
#line 13908 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void countLeadingZerosLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 7244 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ lzcntq(opnd_array(0)->as_Register(ra_,this), opnd_array(1)->as_Register(ra_,this,idx1));
  
#line 13923 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void countLeadingZerosL_bsrNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 7261 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register Rdst = opnd_array(0)->as_Register(ra_,this);
    Register Rsrc = opnd_array(1)->as_Register(ra_,this,idx1);
    Label skip;
    __ bsrq(Rdst, Rsrc);
    __ jccb(Assembler::notZero, skip);
    __ movl(Rdst, -1);
    __ bind(skip);
    __ negl(Rdst);
    __ addl(Rdst, BitsPerLong - 1);
  
#line 13946 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void countTrailingZerosINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 7283 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register Rdst = opnd_array(0)->as_Register(ra_,this);
    Label done;
    __ bsfl(Rdst, opnd_array(1)->as_Register(ra_,this,idx1));
    __ jccb(Assembler::notZero, done);
    __ movl(Rdst, BitsPerInt);
    __ bind(done);
  
#line 13966 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void countTrailingZerosLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 7302 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register Rdst = opnd_array(0)->as_Register(ra_,this);
    Label done;
    __ bsfq(Rdst, opnd_array(1)->as_Register(ra_,this,idx1));
    __ jccb(Assembler::notZero, done);
    __ movl(Rdst, BitsPerLong);
    __ bind(done);
  
#line 13986 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void popCountINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 7321 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ popcntl(opnd_array(0)->as_Register(ra_,this), opnd_array(1)->as_Register(ra_,this,idx1));
  
#line 14001 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void popCountI_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {
    MacroAssembler _masm(&cbuf);

#line 7332 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ popcntl(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 14016 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void popCountLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 7344 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ popcntq(opnd_array(0)->as_Register(ra_,this), opnd_array(1)->as_Register(ra_,this,idx1));
  
#line 14031 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void popCountL_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {
    MacroAssembler _masm(&cbuf);

#line 7356 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ popcntq(opnd_array(0)->as_Register(ra_,this), Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 14046 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void membar_acquireNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  // User did not define which encode class to use.
}
uint  membar_acquireNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 0);
}
void membar_acquire_lockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  // User did not define which encode class to use.
}
uint  membar_acquire_lockNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 0);
}
void membar_releaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  // User did not define which encode class to use.
}
uint  membar_releaseNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 0);
}
void membar_release_lockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  // User did not define which encode class to use.
}
uint  membar_release_lockNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 0);
}
void membar_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 7425 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ membar(Assembler::StoreLoad);
  
#line 14105 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void unnecessary_membar_volatileNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  // User did not define which encode class to use.
}
uint  unnecessary_membar_volatileNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 0);
}
void castX2PNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2804 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int srcenc = opnd_array(1)->reg(ra_,this,idx1);
    int dstenc = opnd_array(0)->reg(ra_,this);

    if (dstenc != srcenc) {
      if (dstenc < 8) {
        if (srcenc < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WB);
          srcenc -= 8;
        }
      } else {
        if (srcenc < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRB);
          srcenc -= 8;
        }
        dstenc -= 8;
      }
      emit_opcode(cbuf, 0x8B);
      emit_rm(cbuf, 0x3, dstenc, srcenc);
    }
  
#line 14152 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void castP2XNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2804 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int srcenc = opnd_array(1)->reg(ra_,this,idx1);
    int dstenc = opnd_array(0)->reg(ra_,this);

    if (dstenc != srcenc) {
      if (dstenc < 8) {
        if (srcenc < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WB);
          srcenc -= 8;
        }
      } else {
        if (srcenc < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRB);
          srcenc -= 8;
        }
        dstenc -= 8;
      }
      emit_opcode(cbuf, 0x8B);
      emit_rm(cbuf, 0x3, dstenc, srcenc);
    }
  
#line 14188 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void encodeHeapOopNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 7470 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register s = opnd_array(1)->as_Register(ra_,this,idx1);
    Register d = opnd_array(0)->as_Register(ra_,this);
    if (s != d) {
      __ movq(d, s);
    }
    __ encode_heap_oop(d);
  
#line 14208 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void encodeHeapOop_not_nullNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 7486 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ encode_heap_oop_not_null(opnd_array(0)->as_Register(ra_,this), opnd_array(1)->as_Register(ra_,this,idx1));
  
#line 14223 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void decodeHeapOopNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 7498 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register s = opnd_array(1)->as_Register(ra_,this,idx1);
    Register d = opnd_array(0)->as_Register(ra_,this);
    if (s != d) {
      __ movq(d, s);
    }
    __ decode_heap_oop(d);
  
#line 14243 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void decodeHeapOop_not_nullNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 7515 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register s = opnd_array(1)->as_Register(ra_,this,idx1);
    Register d = opnd_array(0)->as_Register(ra_,this);
    if (s != d) {
      __ decode_heap_oop_not_null(d, s);
    } else {
      __ decode_heap_oop_not_null(d);
    }
  
#line 14264 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void jumpXtnd_offsetNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  ra_->C->constant_table().fill_jump_table(cbuf, (MachConstantNode*) this, _index2label);
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 7539 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
    // to do that and the compiler is using that register as one it can allocate.
    // So we build it all by hand.
    // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
    // ArrayAddress dispatch(table, index);
    Address dispatch(opnd_array(3)->as_Register(ra_,this,idx3), opnd_array(1)->as_Register(ra_,this,idx1), (Address::ScaleFactor) opnd_array(2)->constant());
    __ lea(opnd_array(3)->as_Register(ra_,this,idx3), InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ jmp(dispatch);
  
#line 14289 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void jumpXtnd_offsetNode::eval_constant(Compile* C) {
  _constant = C->constant_table().allocate_jump_table(this);
  // User did not define an encode section.
}
void jumpXtnd_addrNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  ra_->C->constant_table().fill_jump_table(cbuf, (MachConstantNode*) this, _index2label);
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 7560 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
    // to do that and the compiler is using that register as one it can allocate.
    // So we build it all by hand.
    // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
    // ArrayAddress dispatch(table, index);
    Address dispatch(opnd_array(4)->as_Register(ra_,this,idx4), opnd_array(1)->as_Register(ra_,this,idx1), (Address::ScaleFactor) opnd_array(2)->constant(), (int) opnd_array(3)->constantL());
    __ lea(opnd_array(4)->as_Register(ra_,this,idx4), InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ jmp(dispatch);
  
#line 14319 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void jumpXtnd_addrNode::eval_constant(Compile* C) {
  _constant = C->constant_table().allocate_jump_table(this);
  // User did not define an encode section.
}
void jumpXtndNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
  ra_->C->constant_table().fill_jump_table(cbuf, (MachConstantNode*) this, _index2label);
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 7581 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
    // to do that and the compiler is using that register as one it can allocate.
    // So we build it all by hand.
    // Address index(noreg, switch_reg, Address::times_1);
    // ArrayAddress dispatch(table, index);
    Address dispatch(opnd_array(2)->as_Register(ra_,this,idx2), opnd_array(1)->as_Register(ra_,this,idx1), Address::times_1);
    __ lea(opnd_array(2)->as_Register(ra_,this,idx2), InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ jmp(dispatch);
  
#line 14347 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void jumpXtndNode::eval_constant(Compile* C) {
  _constant = C->constant_table().allocate_jump_table(this);
  // User did not define an encode section.
}
void cmovI_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 14378 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2483 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 14388 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3) & 7, opnd_array(4)->reg(ra_,this,idx4) & 7);
  
#line 14396 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovI_regUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 14423 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2483 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 14433 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3) & 7, opnd_array(4)->reg(ra_,this,idx4) & 7);
  
#line 14441 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovI_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(4)->base(ra_,this,idx4) < 8) {
        if (opnd_array(4)->index(ra_,this,idx4) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(4)->base(ra_,this,idx4) < 8) {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 14484 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2483 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 14494 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3);
    int base = opnd_array(4)->base(ra_,this,idx4);
    int index = opnd_array(4)->index(ra_,this,idx4);
    int scale = opnd_array(4)->scale();
    int disp = opnd_array(4)->disp(ra_,this,idx4);
    bool disp_is_oop = opnd_array(4)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 14510 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovI_memUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(4)->base(ra_,this,idx4) < 8) {
        if (opnd_array(4)->index(ra_,this,idx4) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(4)->base(ra_,this,idx4) < 8) {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 14553 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2483 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 14563 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3);
    int base = opnd_array(4)->base(ra_,this,idx4);
    int index = opnd_array(4)->index(ra_,this,idx4);
    int scale = opnd_array(4)->scale();
    int disp = opnd_array(4)->disp(ra_,this,idx4);
    bool disp_is_oop = opnd_array(4)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 14579 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovN_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 14606 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2483 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 14616 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3) & 7, opnd_array(4)->reg(ra_,this,idx4) & 7);
  
#line 14624 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovN_regUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 14651 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2483 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 14661 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3) & 7, opnd_array(4)->reg(ra_,this,idx4) & 7);
  
#line 14669 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovP_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 14698 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2483 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 14708 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3) & 7, opnd_array(4)->reg(ra_,this,idx4) & 7);
  
#line 14716 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovP_regUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 14745 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2483 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 14755 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3) & 7, opnd_array(4)->reg(ra_,this,idx4) & 7);
  
#line 14763 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovL_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 14792 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2483 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 14802 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3) & 7, opnd_array(4)->reg(ra_,this,idx4) & 7);
  
#line 14810 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovL_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(4)->base(ra_,this,idx4) < 8) {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(4)->base(ra_,this,idx4) < 8) {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 14855 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2483 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 14865 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3);
    int base = opnd_array(4)->base(ra_,this,idx4);
    int index = opnd_array(4)->index(ra_,this,idx4);
    int scale = opnd_array(4)->scale();
    int disp = opnd_array(4)->disp(ra_,this,idx4);
    bool disp_is_oop = opnd_array(4)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 14881 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovL_regUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 14910 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2483 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 14920 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3) & 7, opnd_array(4)->reg(ra_,this,idx4) & 7);
  
#line 14928 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovL_memUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(4)->base(ra_,this,idx4) < 8) {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(4)->base(ra_,this,idx4) < 8) {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(4)->index(ra_,this,idx4) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 14973 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2483 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // CMOV
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x40 /*secondary()*/), opnd_array(1)->ccode());
  
#line 14983 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3);
    int base = opnd_array(4)->base(ra_,this,idx4);
    int index = opnd_array(4)->index(ra_,this,idx4);
    int scale = opnd_array(4)->scale();
    int disp = opnd_array(4)->disp(ra_,this,idx4);
    bool disp_is_oop = opnd_array(4)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 14999 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 2490 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Invert sense of branch from sense of cmov
    emit_cc(cbuf, 0x70, opnd_array(1)->ccode() ^ 1);
    emit_d8(cbuf, (opnd_array(3)->reg(ra_,this,idx3) < 8 && opnd_array(4)->reg(ra_,this,idx4) < 8)
                  ? (UseXmmRegToRegMoveAll ? 3 : 4)
                  : (UseXmmRegToRegMoveAll ? 4 : 5) ); // REX
    // UseXmmRegToRegMoveAll ? movaps(dst, src) : movss(dst, src)
    if (!UseXmmRegToRegMoveAll) emit_opcode(cbuf, 0xF3);
    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, UseXmmRegToRegMoveAll ? 0x28 : 0x10);
    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3) & 7, opnd_array(4)->reg(ra_,this,idx4) & 7);
  
#line 15036 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovF_regUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 2490 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Invert sense of branch from sense of cmov
    emit_cc(cbuf, 0x70, opnd_array(1)->ccode() ^ 1);
    emit_d8(cbuf, (opnd_array(3)->reg(ra_,this,idx3) < 8 && opnd_array(4)->reg(ra_,this,idx4) < 8)
                  ? (UseXmmRegToRegMoveAll ? 3 : 4)
                  : (UseXmmRegToRegMoveAll ? 4 : 5) ); // REX
    // UseXmmRegToRegMoveAll ? movaps(dst, src) : movss(dst, src)
    if (!UseXmmRegToRegMoveAll) emit_opcode(cbuf, 0xF3);
    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, UseXmmRegToRegMoveAll ? 0x28 : 0x10);
    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3) & 7, opnd_array(4)->reg(ra_,this,idx4) & 7);
  
#line 15073 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 2515 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Invert sense of branch from sense of cmov
    emit_cc(cbuf, 0x70, opnd_array(1)->ccode() ^ 1);
    emit_d8(cbuf, opnd_array(3)->reg(ra_,this,idx3) < 8 && opnd_array(4)->reg(ra_,this,idx4) < 8 ? 4 : 5); // REX

    //  UseXmmRegToRegMoveAll ? movapd(dst, src) : movsd(dst, src)
    emit_opcode(cbuf, UseXmmRegToRegMoveAll ? 0x66 : 0xF2);
    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, UseXmmRegToRegMoveAll ? 0x28 : 0x10);
    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3) & 7, opnd_array(4)->reg(ra_,this,idx4) & 7);
  
#line 15109 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovD_regUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 2515 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Invert sense of branch from sense of cmov
    emit_cc(cbuf, 0x70, opnd_array(1)->ccode() ^ 1);
    emit_d8(cbuf, opnd_array(3)->reg(ra_,this,idx3) < 8 && opnd_array(4)->reg(ra_,this,idx4) < 8 ? 4 : 5); // REX

    //  UseXmmRegToRegMoveAll ? movapd(dst, src) : movsd(dst, src)
    emit_opcode(cbuf, UseXmmRegToRegMoveAll ? 0x66 : 0xF2);
    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(4)->reg(ra_,this,idx4) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(4)->reg(ra_,this,idx4) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, UseXmmRegToRegMoveAll ? 0x28 : 0x10);
    emit_rm(cbuf, 0x3, opnd_array(3)->reg(ra_,this,idx3) & 7, opnd_array(4)->reg(ra_,this,idx4) & 7);
  
#line 15145 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 15170 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x03 /*primary()*/));
  
#line 15178 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 15186 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2377 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x00 /*secondary()*/), dstenc);
  
#line 15216 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 15230 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addI_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 15271 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x03 /*primary()*/));
  
#line 15279 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 15295 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addI_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 15336 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x03 /*primary()*/));
  
#line 15344 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 15360 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addI_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 15401 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x01 /*primary()*/));
  
#line 15409 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 15425 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addI_mem_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 15466 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x01 /*primary()*/));
  
#line 15474 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 15490 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 15515 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2365 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 15530 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 15550 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 15564 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void incI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 15581 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 15589 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x00 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 15598 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void incI_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 15623 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 15631 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 15651 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void decI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 15668 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 15676 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x01 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 15685 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void decI_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 15710 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 15718 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x01);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 15738 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void leaI_rReg_immINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x67));
  
#line 15753 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 15771 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 15779 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3108 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int reg_encoding = opnd_array(0)->reg(ra_,this);
    int base         = opnd_array(1)->reg(ra_,this,idx1);      // 0xFFFFFFFF indicates no base
    int index        = 0x04;            // 0x04 indicates no index
    int scale        = 0x00;            // 0x00 indicates no scale
    int displace     = opnd_array(2)->constant(); // 0x00 indicates no displacement
    bool disp_is_oop = false;
    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
                  disp_is_oop);
  
#line 15794 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 15821 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x03 /*primary()*/));
  
#line 15829 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 15837 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2397 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x00 /*secondary()*/), dstenc);
  
#line 15869 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 15883 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addL_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 15926 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x03 /*primary()*/));
  
#line 15934 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 15950 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addL_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 15993 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x03 /*primary()*/));
  
#line 16001 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 16017 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addL_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 16060 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x01 /*primary()*/));
  
#line 16068 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 16084 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addL_mem_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 16127 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x01 /*primary()*/));
  
#line 16135 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 16151 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 16178 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2365 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 16193 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 16213 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 16227 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void incL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 16246 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 16254 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x00 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 16263 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void incL_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 16290 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 16298 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 16318 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void decL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 16337 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 16345 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x01 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 16354 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void decL_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 16381 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 16389 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x01);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 16409 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void leaL_rReg_immLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 16436 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 16444 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3108 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int reg_encoding = opnd_array(0)->reg(ra_,this);
    int base         = opnd_array(1)->reg(ra_,this,idx1);      // 0xFFFFFFFF indicates no base
    int index        = 0x04;            // 0x04 indicates no index
    int scale        = 0x00;            // 0x00 indicates no scale
    int displace     = opnd_array(2)->constantL(); // 0x00 indicates no displacement
    bool disp_is_oop = false;
    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
                  disp_is_oop);
  
#line 16459 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addP_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 16486 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x03 /*primary()*/));
  
#line 16494 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 16502 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addP_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2397 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x00 /*secondary()*/), dstenc);
  
#line 16534 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 16548 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void leaP_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 16575 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8D /*primary()*/));
  
#line 16583 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3108 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int reg_encoding = opnd_array(0)->reg(ra_,this);
    int base         = opnd_array(1)->reg(ra_,this,idx1);      // 0xFFFFFFFF indicates no base
    int index        = 0x04;            // 0x04 indicates no index
    int scale        = 0x00;            // 0x00 indicates no scale
    int displace     = opnd_array(2)->constantL(); // 0x00 indicates no displacement
    bool disp_is_oop = false;
    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
                  disp_is_oop);
  
#line 16598 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void checkCastPPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  // User did not define which encode class to use.
}
uint  checkCastPPNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 0);
}
void castPPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  // User did not define which encode class to use.
}
uint  castPPNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 0);
}
void castIINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  // User did not define which encode class to use.
}
uint  castIINode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 0);
}
void loadPLockedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 16673 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 16681 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 16697 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadLLockedNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 16739 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 16747 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 16763 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storePConditionalNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2869 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 16781 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 16817 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 16825 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 16833 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 16849 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeIConditionalNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2869 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 16867 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 16901 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 16909 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 16917 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 16933 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void storeLConditionalNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2869 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 16951 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 16987 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 16995 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 17003 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 17019 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compareAndSwapPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2869 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 17037 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 17073 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 17081 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 17089 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 17105 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2909 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) >= 4) {
      emit_opcode(cbuf, opnd_array(0)->reg(ra_,this) < 8 ? Assembler::REX : Assembler::REX_B);
    }
  
#line 17115 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 17123 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x94));
  
#line 17131 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2172 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, 0, opnd_array(0)->reg(ra_,this) & 7);
  
#line 17139 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2917 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(0)->reg(ra_,this) >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this) < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 17157 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF));
  
#line 17165 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 17173 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(0)->reg(ra_,this) & 7);
  
#line 17181 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compareAndSwapLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2869 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 17199 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 17235 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 17243 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 17251 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 17267 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2909 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) >= 4) {
      emit_opcode(cbuf, opnd_array(0)->reg(ra_,this) < 8 ? Assembler::REX : Assembler::REX_B);
    }
  
#line 17277 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 17285 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x94));
  
#line 17293 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2172 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, 0, opnd_array(0)->reg(ra_,this) & 7);
  
#line 17301 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2917 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(0)->reg(ra_,this) >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this) < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 17319 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF));
  
#line 17327 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 17335 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(0)->reg(ra_,this) & 7);
  
#line 17343 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compareAndSwapINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2869 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 17361 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 17395 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 17403 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 17411 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 17427 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2909 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) >= 4) {
      emit_opcode(cbuf, opnd_array(0)->reg(ra_,this) < 8 ? Assembler::REX : Assembler::REX_B);
    }
  
#line 17437 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 17445 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x94));
  
#line 17453 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2172 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, 0, opnd_array(0)->reg(ra_,this) & 7);
  
#line 17461 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2917 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(0)->reg(ra_,this) >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this) < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 17479 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF));
  
#line 17487 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 17495 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(0)->reg(ra_,this) & 7);
  
#line 17503 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compareAndSwapNNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2869 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  
#line 17521 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 17555 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 17563 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB1 /*secondary()*/));
  
#line 17571 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(3)->reg(ra_,this,idx3);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 17587 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2909 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) >= 4) {
      emit_opcode(cbuf, opnd_array(0)->reg(ra_,this) < 8 ? Assembler::REX : Assembler::REX_B);
    }
  
#line 17597 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 17605 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x94));
  
#line 17613 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2172 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, 0, opnd_array(0)->reg(ra_,this) & 7);
  
#line 17621 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2917 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(0)->reg(ra_,this) >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this) < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 17639 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF));
  
#line 17647 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 17655 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(0)->reg(ra_,this) & 7);
  
#line 17663 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 17688 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2B /*primary()*/));
  
#line 17696 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 17704 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2377 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x05 /*secondary()*/), dstenc);
  
#line 17734 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 17748 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subI_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 17789 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2B /*primary()*/));
  
#line 17797 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 17813 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subI_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 17854 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x29 /*primary()*/));
  
#line 17862 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 17878 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 17903 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2365 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 17918 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x05);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 17938 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 17952 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 17979 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2B /*primary()*/));
  
#line 17987 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 17995 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2397 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x05 /*secondary()*/), dstenc);
  
#line 18027 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 18041 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subL_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 18084 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2B /*primary()*/));
  
#line 18092 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 18108 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subL_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 18151 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x29 /*primary()*/));
  
#line 18159 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 18175 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 18202 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2365 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 18217 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x05);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 18237 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 18251 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subP_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(3)->reg(ra_,this,idx3) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 18279 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2B /*primary()*/));
  
#line 18287 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(3)->reg(ra_,this,idx3) & 7);
  
#line 18295 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void negI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 18312 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 18320 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x03 /*secondary()*/), opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 18329 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void negI_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 18354 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 18362 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x03 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 18382 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void negL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 18401 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 18409 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x03 /*secondary()*/), opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 18418 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void negL_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 18445 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 18453 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x03 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 18473 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 18498 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 18506 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xAF /*secondary()*/));
  
#line 18514 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 18522 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 18547 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2365 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x69 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x69 /*primary()*/));
    }
  
#line 18562 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 18570 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 18584 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulI_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 18625 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 18633 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xAF /*secondary()*/));
  
#line 18641 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 18657 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulI_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 18698 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 18706 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xAF /*secondary()*/));
  
#line 18714 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 18730 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 18771 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2365 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x69 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x69 /*primary()*/));
    }
  
#line 18786 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 18802 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 18816 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 18843 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 18851 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xAF /*secondary()*/));
  
#line 18859 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 18867 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 18894 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2365 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x69 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x69 /*primary()*/));
    }
  
#line 18909 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 18917 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 18931 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulL_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 18974 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 18982 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xAF /*secondary()*/));
  
#line 18990 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 19006 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulL_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 19049 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 19057 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xAF /*secondary()*/));
  
#line 19065 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 19081 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 19124 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2365 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x69 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x69 /*primary()*/));
    }
  
#line 19139 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 19155 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 19169 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulHiL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 19188 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 19196 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x5 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 19205 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void divI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2229 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Full implementation of Java idiv and irem; checks for
    // special case as described in JVM spec., p.243 & p.271.
    //
    //         normal case                           special case
    //
    // input : rax: dividend                         min_int
    //         reg: divisor                          -1
    //
    // output: rax: quotient  (= rax idiv reg)       min_int
    //         rdx: remainder (= rax irem reg)       0
    //
    //  Code sequnce:
    //
    //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
    //    5:   75 07/08                jne    e <normal>
    //    7:   33 d2                   xor    %edx,%edx
    //  [div >= 8 -> offset + 1]
    //  [REX_B]
    //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
    //    c:   74 03/04                je     11 <done>
    // 000000000000000e <normal>:
    //    e:   99                      cltd
    //  [div >= 8 -> offset + 1]
    //  [REX_B]
    //    f:   f7 f9                   idiv   $div
    // 0000000000000011 <done>:

    // cmp    $0x80000000,%eax
    emit_opcode(cbuf, 0x3d);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x80);

    // jne    e <normal>
    emit_opcode(cbuf, 0x75);
    emit_d8(cbuf, opnd_array(2)->reg(ra_,this,idx2) < 8 ? 0x07 : 0x08);

    // xor    %edx,%edx
    emit_opcode(cbuf, 0x33);
    emit_d8(cbuf, 0xD2);

    // cmp    $0xffffffffffffffff,%ecx
    if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x7, opnd_array(2)->reg(ra_,this,idx2) & 7);
    emit_d8(cbuf, 0xFF);

    // je     11 <done>
    emit_opcode(cbuf, 0x74);
    emit_d8(cbuf, opnd_array(2)->reg(ra_,this,idx2) < 8 ? 0x03 : 0x04);

    // <normal>
    // cltd
    emit_opcode(cbuf, 0x99);

    // idivl (note: must be emitted by the user of this rule)
    // <done>
  
#line 19279 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 19289 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 19297 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 19306 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void divL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2293 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Full implementation of Java ldiv and lrem; checks for
    // special case as described in JVM spec., p.243 & p.271.
    //
    //         normal case                           special case
    //
    // input : rax: dividend                         min_long
    //         reg: divisor                          -1
    //
    // output: rax: quotient  (= rax idiv reg)       min_long
    //         rdx: remainder (= rax irem reg)       0
    //
    //  Code sequnce:
    //
    //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
    //    7:   00 00 80
    //    a:   48 39 d0                cmp    %rdx,%rax
    //    d:   75 08                   jne    17 <normal>
    //    f:   33 d2                   xor    %edx,%edx
    //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
    //   15:   74 05                   je     1c <done>
    // 0000000000000017 <normal>:
    //   17:   48 99                   cqto
    //   19:   48 f7 f9                idiv   $div
    // 000000000000001c <done>:

    // mov    $0x8000000000000000,%rdx
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0xBA);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x80);

    // cmp    %rdx,%rax
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x39);
    emit_d8(cbuf, 0xD0);

    // jne    17 <normal>
    emit_opcode(cbuf, 0x75);
    emit_d8(cbuf, 0x08);

    // xor    %edx,%edx
    emit_opcode(cbuf, 0x33);
    emit_d8(cbuf, 0xD2);

    // cmp    $0xffffffffffffffff,$div
    emit_opcode(cbuf, opnd_array(2)->reg(ra_,this,idx2) < 8 ? Assembler::REX_W : Assembler::REX_WB);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x7, opnd_array(2)->reg(ra_,this,idx2) & 7);
    emit_d8(cbuf, 0xFF);

    // je     1e <done>
    emit_opcode(cbuf, 0x74);
    emit_d8(cbuf, 0x05);

    // <normal>
    // cqto
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x99);

    // idivq (note: must be emitted by the user of this rule)
    // <done>
  
#line 19387 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 19399 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 19407 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 19416 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void divModI_rReg_divmodNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2229 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Full implementation of Java idiv and irem; checks for
    // special case as described in JVM spec., p.243 & p.271.
    //
    //         normal case                           special case
    //
    // input : rax: dividend                         min_int
    //         reg: divisor                          -1
    //
    // output: rax: quotient  (= rax idiv reg)       min_int
    //         rdx: remainder (= rax irem reg)       0
    //
    //  Code sequnce:
    //
    //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
    //    5:   75 07/08                jne    e <normal>
    //    7:   33 d2                   xor    %edx,%edx
    //  [div >= 8 -> offset + 1]
    //  [REX_B]
    //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
    //    c:   74 03/04                je     11 <done>
    // 000000000000000e <normal>:
    //    e:   99                      cltd
    //  [div >= 8 -> offset + 1]
    //  [REX_B]
    //    f:   f7 f9                   idiv   $div
    // 0000000000000011 <done>:

    // cmp    $0x80000000,%eax
    emit_opcode(cbuf, 0x3d);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x80);

    // jne    e <normal>
    emit_opcode(cbuf, 0x75);
    emit_d8(cbuf, opnd_array(2)->reg(ra_,this,idx2) < 8 ? 0x07 : 0x08);

    // xor    %edx,%edx
    emit_opcode(cbuf, 0x33);
    emit_d8(cbuf, 0xD2);

    // cmp    $0xffffffffffffffff,%ecx
    if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x7, opnd_array(2)->reg(ra_,this,idx2) & 7);
    emit_d8(cbuf, 0xFF);

    // je     11 <done>
    emit_opcode(cbuf, 0x74);
    emit_d8(cbuf, opnd_array(2)->reg(ra_,this,idx2) < 8 ? 0x03 : 0x04);

    // <normal>
    // cltd
    emit_opcode(cbuf, 0x99);

    // idivl (note: must be emitted by the user of this rule)
    // <done>
  
#line 19490 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 19500 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 19508 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 19517 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void divModL_rReg_divmodNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2293 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Full implementation of Java ldiv and lrem; checks for
    // special case as described in JVM spec., p.243 & p.271.
    //
    //         normal case                           special case
    //
    // input : rax: dividend                         min_long
    //         reg: divisor                          -1
    //
    // output: rax: quotient  (= rax idiv reg)       min_long
    //         rdx: remainder (= rax irem reg)       0
    //
    //  Code sequnce:
    //
    //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
    //    7:   00 00 80
    //    a:   48 39 d0                cmp    %rdx,%rax
    //    d:   75 08                   jne    17 <normal>
    //    f:   33 d2                   xor    %edx,%edx
    //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
    //   15:   74 05                   je     1c <done>
    // 0000000000000017 <normal>:
    //   17:   48 99                   cqto
    //   19:   48 f7 f9                idiv   $div
    // 000000000000001c <done>:

    // mov    $0x8000000000000000,%rdx
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0xBA);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x80);

    // cmp    %rdx,%rax
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x39);
    emit_d8(cbuf, 0xD0);

    // jne    17 <normal>
    emit_opcode(cbuf, 0x75);
    emit_d8(cbuf, 0x08);

    // xor    %edx,%edx
    emit_opcode(cbuf, 0x33);
    emit_d8(cbuf, 0xD2);

    // cmp    $0xffffffffffffffff,$div
    emit_opcode(cbuf, opnd_array(2)->reg(ra_,this,idx2) < 8 ? Assembler::REX_W : Assembler::REX_WB);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x7, opnd_array(2)->reg(ra_,this,idx2) & 7);
    emit_d8(cbuf, 0xFF);

    // je     1e <done>
    emit_opcode(cbuf, 0x74);
    emit_d8(cbuf, 0x05);

    // <normal>
    // cqto
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x99);

    // idivq (note: must be emitted by the user of this rule)
    // <done>
  
#line 19598 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 19610 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 19618 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 19627 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void loadConL_0x6666666666666667Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2700 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xB8 | dstenc);
    emit_d64(cbuf, (0x6666666666666667));
  
#line 19649 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mul_hiNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 19668 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 19676 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x5 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 19685 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sarL_rReg_63Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2674 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), dstenc);
    emit_d8(cbuf, (0x3F));
  
#line 19709 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sarL_rReg_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2674 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), dstenc);
    emit_d8(cbuf, (0x2));
  
#line 19733 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void modI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2229 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Full implementation of Java idiv and irem; checks for
    // special case as described in JVM spec., p.243 & p.271.
    //
    //         normal case                           special case
    //
    // input : rax: dividend                         min_int
    //         reg: divisor                          -1
    //
    // output: rax: quotient  (= rax idiv reg)       min_int
    //         rdx: remainder (= rax irem reg)       0
    //
    //  Code sequnce:
    //
    //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
    //    5:   75 07/08                jne    e <normal>
    //    7:   33 d2                   xor    %edx,%edx
    //  [div >= 8 -> offset + 1]
    //  [REX_B]
    //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
    //    c:   74 03/04                je     11 <done>
    // 000000000000000e <normal>:
    //    e:   99                      cltd
    //  [div >= 8 -> offset + 1]
    //  [REX_B]
    //    f:   f7 f9                   idiv   $div
    // 0000000000000011 <done>:

    // cmp    $0x80000000,%eax
    emit_opcode(cbuf, 0x3d);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x80);

    // jne    e <normal>
    emit_opcode(cbuf, 0x75);
    emit_d8(cbuf, opnd_array(2)->reg(ra_,this,idx2) < 8 ? 0x07 : 0x08);

    // xor    %edx,%edx
    emit_opcode(cbuf, 0x33);
    emit_d8(cbuf, 0xD2);

    // cmp    $0xffffffffffffffff,%ecx
    if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x7, opnd_array(2)->reg(ra_,this,idx2) & 7);
    emit_d8(cbuf, 0xFF);

    // je     11 <done>
    emit_opcode(cbuf, 0x74);
    emit_d8(cbuf, opnd_array(2)->reg(ra_,this,idx2) < 8 ? 0x03 : 0x04);

    // <normal>
    // cltd
    emit_opcode(cbuf, 0x99);

    // idivl (note: must be emitted by the user of this rule)
    // <done>
  
#line 19807 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 19817 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 19825 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 19834 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void modL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2293 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Full implementation of Java ldiv and lrem; checks for
    // special case as described in JVM spec., p.243 & p.271.
    //
    //         normal case                           special case
    //
    // input : rax: dividend                         min_long
    //         reg: divisor                          -1
    //
    // output: rax: quotient  (= rax idiv reg)       min_long
    //         rdx: remainder (= rax irem reg)       0
    //
    //  Code sequnce:
    //
    //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
    //    7:   00 00 80
    //    a:   48 39 d0                cmp    %rdx,%rax
    //    d:   75 08                   jne    17 <normal>
    //    f:   33 d2                   xor    %edx,%edx
    //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
    //   15:   74 05                   je     1c <done>
    // 0000000000000017 <normal>:
    //   17:   48 99                   cqto
    //   19:   48 f7 f9                idiv   $div
    // 000000000000001c <done>:

    // mov    $0x8000000000000000,%rdx
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0xBA);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x80);

    // cmp    %rdx,%rax
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x39);
    emit_d8(cbuf, 0xD0);

    // jne    17 <normal>
    emit_opcode(cbuf, 0x75);
    emit_d8(cbuf, 0x08);

    // xor    %edx,%edx
    emit_opcode(cbuf, 0x33);
    emit_d8(cbuf, 0xD2);

    // cmp    $0xffffffffffffffff,$div
    emit_opcode(cbuf, opnd_array(2)->reg(ra_,this,idx2) < 8 ? Assembler::REX_W : Assembler::REX_WB);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x7, opnd_array(2)->reg(ra_,this,idx2) & 7);
    emit_d8(cbuf, 0xFF);

    // je     1e <done>
    emit_opcode(cbuf, 0x74);
    emit_d8(cbuf, 0x05);

    // <normal>
    // cqto
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x99);

    // idivq (note: must be emitted by the user of this rule)
    // <done>
  
#line 19915 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 19927 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 19935 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 19944 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void salI_rReg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 19961 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 19969 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x4 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 19978 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void salI_mem_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 20003 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 20011 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x4 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 20031 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void salI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2661 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x4 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 20054 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void salI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 20079 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xC1 /*primary()*/));
  
#line 20087 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x4 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 20107 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 20121 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void salI_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 20138 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 20146 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x4 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 20155 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void salI_mem_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 20180 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 20188 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x4 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 20208 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sarI_rReg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 20225 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 20233 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 20242 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sarI_mem_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 20267 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 20275 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x7 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 20295 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sarI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2661 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 20318 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sarI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 20343 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xC1 /*primary()*/));
  
#line 20351 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x7 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 20371 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 20385 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sarI_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 20402 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 20410 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 20419 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sarI_mem_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 20444 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 20452 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x7 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 20472 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void shrI_rReg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 20489 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 20497 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x5 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 20506 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void shrI_mem_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 20531 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 20539 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x5 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 20559 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void shrI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2661 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x5 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 20582 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void shrI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 20607 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xC1 /*primary()*/));
  
#line 20615 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x5 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 20635 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 20649 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void shrI_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 20666 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 20674 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x5 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 20683 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void shrI_mem_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 20708 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 20716 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x5 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 20736 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void salL_rReg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 20755 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 20763 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x4 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 20772 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void salL_mem_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 20799 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 20807 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x4 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 20827 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void salL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2674 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x4 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 20852 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void salL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 20879 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xC1 /*primary()*/));
  
#line 20887 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x4 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 20907 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 20921 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void salL_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 20940 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 20948 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x4 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 20957 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void salL_mem_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 20984 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 20992 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x4 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 21012 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sarL_rReg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 21031 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 21039 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 21048 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sarL_mem_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 21075 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 21083 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x7 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 21103 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sarL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2674 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 21128 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sarL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 21155 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xC1 /*primary()*/));
  
#line 21163 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x7 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 21183 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 21197 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sarL_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 21216 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 21224 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 21233 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sarL_mem_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 21260 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 21268 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x7 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 21288 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void shrL_rReg_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 21307 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 21315 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x5 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 21324 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void shrL_mem_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 21351 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 21359 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x5 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 21379 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void shrL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2674 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x5 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 21404 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void shrL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 21431 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xC1 /*primary()*/));
  
#line 21439 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x5 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 21459 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 21473 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void shrL_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 21492 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 21500 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x5 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 21509 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void shrL_mem_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 21536 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 21544 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x5 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 21564 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void i2bNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2917 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 4) {
        emit_opcode(cbuf, opnd_array(1)->reg(ra_,this,idx1) < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 21589 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 21597 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xBE /*secondary()*/));
  
#line 21605 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 21613 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void i2sNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 21638 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 21646 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xBF /*secondary()*/));
  
#line 21654 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 21662 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void rolI_rReg_imm1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 21678 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 21686 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x0 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 21695 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void rolI_rReg_imm8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2661 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x0 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 21718 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void rolI_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 21735 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 21743 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x0 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 21752 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void rorI_rReg_imm1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 21768 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 21776 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x1 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 21785 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void rorI_rReg_imm8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2661 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x1 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 21808 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void rorI_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 21825 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 21833 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x1 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 21842 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void rolL_rReg_imm1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 21860 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 21868 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x0 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 21877 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void rolL_rReg_imm8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2674 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x0 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 21902 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void rolL_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 21921 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 21929 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x0 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 21938 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void rorL_rReg_imm1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 21956 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD1 /*primary()*/));
  
#line 21964 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x1 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 21973 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void rorL_rReg_imm8Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2674 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x1 /*secondary()*/), dstenc);
    emit_d8(cbuf, opnd_array(2)->constant());
  
#line 21998 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void rorL_rReg_CLNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 22017 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD3 /*primary()*/));
  
#line 22025 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x1 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 22034 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 22059 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x23 /*primary()*/));
  
#line 22067 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 22075 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andI_rReg_imm255Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2917 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 4) {
        emit_opcode(cbuf, opnd_array(1)->reg(ra_,this,idx1) < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 22100 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 22108 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB6 /*secondary()*/));
  
#line 22116 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 22124 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andI2L_rReg_imm255Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2917 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 4) {
        emit_opcode(cbuf, opnd_array(1)->reg(ra_,this,idx1) < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 22149 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 22157 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB6 /*secondary()*/));
  
#line 22165 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 22173 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andI_rReg_imm65535Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 22198 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 22206 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB7 /*secondary()*/));
  
#line 22214 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 22222 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andI2L_rReg_imm65535Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 22247 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 22255 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB7 /*secondary()*/));
  
#line 22263 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 22271 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2377 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x04 /*secondary()*/), dstenc);
  
#line 22301 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 22315 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andI_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 22356 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x23 /*primary()*/));
  
#line 22364 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 22380 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andI_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 22421 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x23 /*primary()*/));
  
#line 22429 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 22445 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andI_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 22486 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x21 /*primary()*/));
  
#line 22494 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 22510 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andI_mem_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 22551 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x21 /*primary()*/));
  
#line 22559 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 22575 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 22600 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2365 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 22615 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x4 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 22635 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 22649 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void orI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 22674 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0B /*primary()*/));
  
#line 22682 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 22690 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void orI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2377 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x01 /*secondary()*/), dstenc);
  
#line 22720 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 22734 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void orI_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 22775 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0B /*primary()*/));
  
#line 22783 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 22799 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void orI_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 22840 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0B /*primary()*/));
  
#line 22848 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 22864 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void orI_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 22905 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x09 /*primary()*/));
  
#line 22913 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 22929 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void orI_mem_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 22970 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x09 /*primary()*/));
  
#line 22978 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 22994 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void orI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 23019 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2365 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 23034 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x1 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 23054 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 23068 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void xorI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 23093 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 23101 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 23109 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void xorI_rReg_im1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 9794 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

     __ notl(opnd_array(1)->as_Register(ra_,this,idx1));
  
#line 23125 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void xorI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2377 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x06 /*secondary()*/), dstenc);
  
#line 23155 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 23169 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void xorI_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 23210 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 23218 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 23234 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void xorI_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 23275 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 23283 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 23299 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void xorI_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 23340 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x31 /*primary()*/));
  
#line 23348 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 23364 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void xorI_mem_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 23405 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x31 /*primary()*/));
  
#line 23413 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 23429 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void xorI_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2876 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  
#line 23454 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2365 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 23469 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x6 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 23489 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 23503 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 23530 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x23 /*primary()*/));
  
#line 23538 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 23546 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andL_rReg_imm255Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 23573 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 23581 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB6 /*secondary()*/));
  
#line 23589 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 23597 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andL_rReg_imm65535Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 23624 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 23632 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB7 /*secondary()*/));
  
#line 23640 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 23648 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2397 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x04 /*secondary()*/), dstenc);
  
#line 23680 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 23694 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andL_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 23737 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x23 /*primary()*/));
  
#line 23745 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 23761 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andL_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 23804 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x23 /*primary()*/));
  
#line 23812 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 23828 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andL_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 23871 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x21 /*primary()*/));
  
#line 23879 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 23895 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andL_mem_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 23938 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x21 /*primary()*/));
  
#line 23946 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 23962 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void andL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 23989 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2365 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 24004 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x4 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 24024 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 24038 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void orL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 24065 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0B /*primary()*/));
  
#line 24073 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 24081 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void orL_rReg_castP2XNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 24108 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0B /*primary()*/));
  
#line 24116 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 24124 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void orL_rReg_castP2X_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 24151 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0B /*primary()*/));
  
#line 24159 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(2)->reg(ra_,this,idx2) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 24167 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void orL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2397 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x01 /*secondary()*/), dstenc);
  
#line 24199 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 24213 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void orL_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 24256 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0B /*primary()*/));
  
#line 24264 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 24280 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void orL_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 24323 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0B /*primary()*/));
  
#line 24331 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 24347 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void orL_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 24390 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x09 /*primary()*/));
  
#line 24398 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 24414 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void orL_mem_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 24457 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x09 /*primary()*/));
  
#line 24465 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 24481 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void orL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 24508 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2365 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 24523 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x1 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 24543 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 24557 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void xorL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 24584 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 24592 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 24600 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void xorL_rReg_im1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10037 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

     __ notq(opnd_array(1)->as_Register(ra_,this,idx1));
  
#line 24616 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void xorL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2397 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x06 /*secondary()*/), dstenc);
  
#line 24648 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 24662 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void xorL_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 24705 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 24713 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 24729 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void xorL_rReg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 24772 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x33 /*primary()*/));
  
#line 24780 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 24796 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void xorL_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 24839 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x31 /*primary()*/));
  
#line 24847 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 24863 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void xorL_mem_rReg_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 24906 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x31 /*primary()*/));
  
#line 24914 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 24930 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void xorL_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 24957 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2365 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
  
#line 24972 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x6 /*secondary()*/);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 24992 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 25006 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convI2BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 25030 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2182 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x85));
    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 25039 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    } else if (dstenc >= 4) {
      emit_opcode(cbuf, Assembler::REX);
    }
    // SETNZ $dst
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x95);
    emit_rm(cbuf, 0x3, 0x0, dstenc);
  
#line 25057 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2917 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(0)->reg(ra_,this) >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this) < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 25075 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 25083 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 25091 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(0)->reg(ra_,this) & 7);
  
#line 25099 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convP2BNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 25125 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2182 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x85));
    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 25134 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    } else if (dstenc >= 4) {
      emit_opcode(cbuf, Assembler::REX);
    }
    // SETNZ $dst
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x95);
    emit_rm(cbuf, 0x3, 0x0, dstenc);
  
#line 25152 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2917 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(0)->reg(ra_,this) >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this) < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 25170 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 25178 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 25186 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(0)->reg(ra_,this) & 7);
  
#line 25194 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpLTMaskNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 25219 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2182 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x3B));
    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 25228 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3146 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    } else if (dstenc >= 4) {
      emit_opcode(cbuf, Assembler::REX);
    }
    // SETLT $dst
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x9C);
    emit_rm(cbuf, 0x3, 0x0, dstenc);
  
#line 25246 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2917 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(0)->reg(ra_,this) >= 4) {
        emit_opcode(cbuf, opnd_array(0)->reg(ra_,this) < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if (opnd_array(0)->reg(ra_,this) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 25264 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F));
  
#line 25272 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xB6));
  
#line 25280 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(0)->reg(ra_,this) & 7);
  
#line 25288 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3120 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // NEG $dst
    emit_opcode(cbuf, 0xF7);
    emit_rm(cbuf, 0x3, 0x03, dstenc);
  
#line 25303 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpLTMask0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2661 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // SAL, SAR, SHR
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_d8(cbuf, (0xC1 /*primary()*/));
    emit_rm(cbuf, 0x3, (0x7 /*secondary()*/), dstenc);
    emit_d8(cbuf, (0x1F));
  
#line 25326 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cadd_cmpLTMaskNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10168 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register Rp = opnd_array(1)->as_Register(ra_,this,idx1);
    Register Rq = opnd_array(2)->as_Register(ra_,this,idx2);
    Register Ry = opnd_array(3)->as_Register(ra_,this,idx3);
    Register Rt = opnd_array(4)->as_Register(ra_,this,idx4);
    __ subl(Rp, Rq);
    __ sbbl(Rt, Rt);
    __ andl(Rt, Ry);
    __ addl(Rp, Rt);
  
#line 25351 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cadd_cmpLTMask_1Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10168 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register Rp = opnd_array(1)->as_Register(ra_,this,idx1);
    Register Rq = opnd_array(2)->as_Register(ra_,this,idx2);
    Register Ry = opnd_array(3)->as_Register(ra_,this,idx3);
    Register Rt = opnd_array(4)->as_Register(ra_,this,idx4);
    __ subl(Rp, Rq);
    __ sbbl(Rt, Rt);
    __ andl(Rt, Ry);
    __ addl(Rp, Rt);
  
#line 25376 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cadd_cmpLTMask_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10168 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register Rp = opnd_array(2)->as_Register(ra_,this,idx2);
    Register Rq = opnd_array(3)->as_Register(ra_,this,idx3);
    Register Ry = opnd_array(1)->as_Register(ra_,this,idx1);
    Register Rt = opnd_array(4)->as_Register(ra_,this,idx4);
    __ subl(Rp, Rq);
    __ sbbl(Rt, Rt);
    __ andl(Rt, Ry);
    __ addl(Rp, Rt);
  
#line 25401 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cadd_cmpLTMask_2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10168 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register Rp = opnd_array(1)->as_Register(ra_,this,idx1);
    Register Rq = opnd_array(2)->as_Register(ra_,this,idx2);
    Register Ry = opnd_array(3)->as_Register(ra_,this,idx3);
    Register Rt = opnd_array(4)->as_Register(ra_,this,idx4);
    __ subl(Rp, Rq);
    __ sbbl(Rt, Rt);
    __ andl(Rt, Ry);
    __ addl(Rp, Rt);
  
#line 25426 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpF_cc_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 25451 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 25459 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2E /*secondary()*/));
  
#line 25467 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 25475 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2187 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

      MacroAssembler _masm(&cbuf);
      emit_cmpfp_fixup(_masm);
  
#line 25484 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpF_cc_reg_CFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10205 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ ucomiss(opnd_array(1)->as_XMMRegister(ra_,this,idx1), opnd_array(2)->as_XMMRegister(ra_,this,idx2));
  
#line 25500 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpF_cc_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 25541 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 25549 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2E /*secondary()*/));
  
#line 25557 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 25573 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2187 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

      MacroAssembler _masm(&cbuf);
      emit_cmpfp_fixup(_masm);
  
#line 25582 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpF_cc_memCFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 25623 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 25631 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2E /*secondary()*/));
  
#line 25639 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 25655 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpF_cc_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10248 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ ucomiss(opnd_array(1)->as_XMMRegister(ra_,this,idx1), InternalAddress(__ code()->consts()->start() + constant_offset()));
    emit_cmpfp_fixup(_masm);
  
#line 25672 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpF_cc_immNode::eval_constant(Compile* C) {
  {

#line 10249 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(2));
#line 25680 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpF_cc_immCFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10259 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ ucomiss(opnd_array(1)->as_XMMRegister(ra_,this,idx1), InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 25696 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpF_cc_immCFNode::eval_constant(Compile* C) {
  {

#line 10260 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(2));
#line 25704 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpD_cc_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x66 /*primary()*/));
  
#line 25719 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 25737 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 25745 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2E /*tertiary()*/));
  
#line 25753 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 25761 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2187 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

      MacroAssembler _masm(&cbuf);
      emit_cmpfp_fixup(_masm);
  
#line 25770 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpD_cc_reg_CFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10287 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ ucomisd(opnd_array(1)->as_XMMRegister(ra_,this,idx1), opnd_array(2)->as_XMMRegister(ra_,this,idx2));
  
#line 25786 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpD_cc_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x66 /*primary()*/));
  
#line 25801 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 25835 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 25843 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2E /*tertiary()*/));
  
#line 25851 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 25867 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2187 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

      MacroAssembler _masm(&cbuf);
      emit_cmpfp_fixup(_masm);
  
#line 25876 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpD_cc_memCFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x66 /*primary()*/));
  
#line 25891 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 25925 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 25933 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2E /*tertiary()*/));
  
#line 25941 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 25957 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpD_cc_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10330 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ ucomisd(opnd_array(1)->as_XMMRegister(ra_,this,idx1), InternalAddress(__ code()->consts()->start() + constant_offset()));
    emit_cmpfp_fixup(_masm);
  
#line 25974 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpD_cc_immNode::eval_constant(Compile* C) {
  {

#line 10331 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(2));
#line 25982 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpD_cc_immCFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10341 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ ucomisd(opnd_array(1)->as_XMMRegister(ra_,this,idx1), InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 25998 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpD_cc_immCFNode::eval_constant(Compile* C) {
  {

#line 10342 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(2));
#line 26006 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 26031 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 26039 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2E /*secondary()*/));
  
#line 26047 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 26055 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2193 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);

    // movl $dst, -1
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0xB8 | (dstenc & 7));
    emit_d32(cbuf, -1);

    // jp,s done
    emit_opcode(cbuf, 0x7A);
    emit_d8(cbuf, dstenc < 4 ? 0x08 : 0x0A);

    // jb,s done
    emit_opcode(cbuf, 0x72);
    emit_d8(cbuf, dstenc < 4 ? 0x06 : 0x08);

    // setne $dst
    if (dstenc >= 4) {
      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x95);
    emit_opcode(cbuf, 0xC0 | (dstenc & 7));

    // movzbl $dst, $dst
    if (dstenc >= 4) {
      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_RB);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0xB6);
    emit_rm(cbuf, 0x3, dstenc & 7, dstenc & 7);
  
#line 26094 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpF_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 26135 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 26143 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2E /*secondary()*/));
  
#line 26151 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 26167 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2193 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);

    // movl $dst, -1
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0xB8 | (dstenc & 7));
    emit_d32(cbuf, -1);

    // jp,s done
    emit_opcode(cbuf, 0x7A);
    emit_d8(cbuf, dstenc < 4 ? 0x08 : 0x0A);

    // jb,s done
    emit_opcode(cbuf, 0x72);
    emit_d8(cbuf, dstenc < 4 ? 0x06 : 0x08);

    // setne $dst
    if (dstenc >= 4) {
      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x95);
    emit_opcode(cbuf, 0xC0 | (dstenc & 7));

    // movzbl $dst, $dst
    if (dstenc >= 4) {
      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_RB);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0xB6);
    emit_rm(cbuf, 0x3, dstenc & 7, dstenc & 7);
  
#line 26206 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpF_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10402 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Label L_done;
    Register Rdst = opnd_array(0)->as_Register(ra_,this);
    __ ucomiss(opnd_array(1)->as_XMMRegister(ra_,this,idx1), InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ movl(Rdst, -1);
    __ jcc(Assembler::parity, L_done);
    __ jcc(Assembler::below, L_done);
    __ setb(Assembler::notEqual, Rdst);
    __ movzbl(Rdst, Rdst);
    __ bind(L_done);
  
#line 26230 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpF_immNode::eval_constant(Compile* C) {
  {

#line 10405 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(2));
#line 26238 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x66 /*primary()*/));
  
#line 26253 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 26271 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 26279 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2E /*tertiary()*/));
  
#line 26287 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 26295 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2193 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);

    // movl $dst, -1
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0xB8 | (dstenc & 7));
    emit_d32(cbuf, -1);

    // jp,s done
    emit_opcode(cbuf, 0x7A);
    emit_d8(cbuf, dstenc < 4 ? 0x08 : 0x0A);

    // jb,s done
    emit_opcode(cbuf, 0x72);
    emit_d8(cbuf, dstenc < 4 ? 0x06 : 0x08);

    // setne $dst
    if (dstenc >= 4) {
      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x95);
    emit_opcode(cbuf, 0xC0 | (dstenc & 7));

    // movzbl $dst, $dst
    if (dstenc >= 4) {
      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_RB);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0xB6);
    emit_rm(cbuf, 0x3, dstenc & 7, dstenc & 7);
  
#line 26334 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpD_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x66 /*primary()*/));
  
#line 26349 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 26383 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 26391 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2E /*tertiary()*/));
  
#line 26399 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 26415 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2193 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);

    // movl $dst, -1
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0xB8 | (dstenc & 7));
    emit_d32(cbuf, -1);

    // jp,s done
    emit_opcode(cbuf, 0x7A);
    emit_d8(cbuf, dstenc < 4 ? 0x08 : 0x0A);

    // jb,s done
    emit_opcode(cbuf, 0x72);
    emit_d8(cbuf, dstenc < 4 ? 0x06 : 0x08);

    // setne $dst
    if (dstenc >= 4) {
      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x95);
    emit_opcode(cbuf, 0xC0 | (dstenc & 7));

    // movzbl $dst, $dst
    if (dstenc >= 4) {
      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_RB);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0xB6);
    emit_rm(cbuf, 0x3, dstenc & 7, dstenc & 7);
  
#line 26454 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpD_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10471 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register Rdst = opnd_array(0)->as_Register(ra_,this);
    Label L_done;
    __ ucomisd(opnd_array(1)->as_XMMRegister(ra_,this,idx1), InternalAddress(__ code()->consts()->start() + constant_offset()));
    __ movl(Rdst, -1);
    __ jcc(Assembler::parity, L_done);
    __ jcc(Assembler::below, L_done);
    __ setb(Assembler::notEqual, Rdst);
    __ movzbl(Rdst, Rdst);
    __ bind(L_done);
  
#line 26478 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpD_immNode::eval_constant(Compile* C) {
  {

#line 10474 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(2));
#line 26486 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 26501 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 26519 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 26527 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x58 /*tertiary()*/));
  
#line 26535 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 26543 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addF_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 26558 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 26592 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 26600 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x58 /*tertiary()*/));
  
#line 26608 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 26624 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addF_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 26639 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 26673 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 26681 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x58 /*tertiary()*/));
  
#line 26689 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 26705 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addF_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10511 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ addss(opnd_array(1)->as_XMMRegister(ra_,this,idx1), InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 26721 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addF_immNode::eval_constant(Compile* C) {
  {

#line 10512 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(2));
#line 26729 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 26744 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 26762 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 26770 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x58 /*tertiary()*/));
  
#line 26778 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 26786 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addD_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 26801 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 26835 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 26843 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x58 /*tertiary()*/));
  
#line 26851 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 26867 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addD_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 26882 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 26916 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 26924 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x58 /*tertiary()*/));
  
#line 26932 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 26948 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addD_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10543 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ addsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1), InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 26964 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void addD_immNode::eval_constant(Compile* C) {
  {

#line 10544 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(2));
#line 26972 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 26987 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 27005 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 27013 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x5C /*tertiary()*/));
  
#line 27021 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 27029 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subF_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 27044 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 27078 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 27086 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x5C /*tertiary()*/));
  
#line 27094 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 27110 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subF_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10575 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ subss(opnd_array(1)->as_XMMRegister(ra_,this,idx1), InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 27126 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subF_immNode::eval_constant(Compile* C) {
  {

#line 10576 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(2));
#line 27134 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 27149 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 27167 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 27175 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x5C /*tertiary()*/));
  
#line 27183 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 27191 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subD_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 27206 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 27240 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 27248 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x5C /*tertiary()*/));
  
#line 27256 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 27272 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subD_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10607 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ subsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1), InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 27288 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void subD_immNode::eval_constant(Compile* C) {
  {

#line 10608 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(2));
#line 27296 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 27311 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 27329 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 27337 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x59 /*tertiary()*/));
  
#line 27345 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 27353 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulF_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 27368 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 27402 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 27410 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x59 /*tertiary()*/));
  
#line 27418 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 27434 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulF_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 27449 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 27483 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 27491 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x59 /*tertiary()*/));
  
#line 27499 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 27515 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulF_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10639 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ mulss(opnd_array(1)->as_XMMRegister(ra_,this,idx1), InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 27531 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulF_immNode::eval_constant(Compile* C) {
  {

#line 10640 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(2));
#line 27539 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 27554 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 27572 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 27580 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x59 /*tertiary()*/));
  
#line 27588 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 27596 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulD_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 27611 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 27645 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 27653 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x59 /*tertiary()*/));
  
#line 27661 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 27677 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulD_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 27692 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 27726 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 27734 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x59 /*tertiary()*/));
  
#line 27742 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 27758 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulD_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10671 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ mulsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1), InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 27774 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void mulD_immNode::eval_constant(Compile* C) {
  {

#line 10672 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(2));
#line 27782 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void divF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 27797 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 27815 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 27823 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x5E /*tertiary()*/));
  
#line 27831 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 27839 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void divF_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 27854 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 27888 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 27896 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x5E /*tertiary()*/));
  
#line 27904 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 27920 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void divF_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10703 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ divss(opnd_array(1)->as_XMMRegister(ra_,this,idx1), InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 27936 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void divF_immNode::eval_constant(Compile* C) {
  {

#line 10704 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(2));
#line 27944 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void divD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 27959 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 27977 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 27985 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x5E /*tertiary()*/));
  
#line 27993 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 28001 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void divD_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 28016 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 28050 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 28058 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x5E /*tertiary()*/));
  
#line 28066 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 28082 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void divD_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 10735 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ divsd(opnd_array(1)->as_XMMRegister(ra_,this,idx1), InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 28098 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void divD_immNode::eval_constant(Compile* C) {
  {

#line 10736 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(2));
#line 28106 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sqrtF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 28120 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 28138 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 28146 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x51 /*tertiary()*/));
  
#line 28154 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 28162 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sqrtF_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 28176 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 28210 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 28218 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x51 /*tertiary()*/));
  
#line 28226 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 28242 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sqrtF_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 10767 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ sqrtss(opnd_array(0)->as_XMMRegister(ra_,this), InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 28257 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sqrtF_immNode::eval_constant(Compile* C) {
  {

#line 10768 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(1));
#line 28265 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sqrtD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 28279 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 28297 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 28305 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x51 /*tertiary()*/));
  
#line 28313 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 28321 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sqrtD_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 28335 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 28369 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 28377 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x51 /*tertiary()*/));
  
#line 28385 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 28401 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sqrtD_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 10799 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ sqrtsd(opnd_array(0)->as_XMMRegister(ra_,this), InternalAddress(__ code()->consts()->start() + constant_offset()));
  
#line 28416 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sqrtD_immNode::eval_constant(Compile* C) {
  {

#line 10800 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
    _constant = C->constant_table().add(opnd_array(1));
#line 28424 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void absF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3552 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    address signmask_address = (address) StubRoutines::x86::float_sign_mask();

    cbuf.set_insts_mark();
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
      dstenc -= 8;
    }
    // XXX reg_mem doesn't support RIP-relative addressing yet
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x54);
    emit_rm(cbuf, 0x0, dstenc, 0x5);  // 00 reg 101
    emit_d32_reloc(cbuf, signmask_address);
  
#line 28450 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void absD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3569 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    address signmask_address = (address) StubRoutines::x86::double_sign_mask();

    cbuf.set_insts_mark();
    emit_opcode(cbuf, 0x66);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
      dstenc -= 8;
    }
    // XXX reg_mem doesn't support RIP-relative addressing yet
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x54);
    emit_rm(cbuf, 0x0, dstenc, 0x5);  // 00 reg 101
    emit_d32_reloc(cbuf, signmask_address);
  
#line 28477 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void negF_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3587 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    address signflip_address = (address) StubRoutines::x86::float_sign_flip();

    cbuf.set_insts_mark();
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
      dstenc -= 8;
    }
    // XXX reg_mem doesn't support RIP-relative addressing yet
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x57);
    emit_rm(cbuf, 0x0, dstenc, 0x5);  // 00 reg 101
    emit_d32_reloc(cbuf, signflip_address);
  
#line 28503 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void negD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3604 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    address signflip_address = (address) StubRoutines::x86::double_sign_flip();

    cbuf.set_insts_mark();
    emit_opcode(cbuf, 0x66);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
      dstenc -= 8;
    }
    // XXX reg_mem doesn't support RIP-relative addressing yet
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x57);
    emit_rm(cbuf, 0x0, dstenc, 0x5);  // 00 reg 101
    emit_d32_reloc(cbuf, signflip_address);
  
#line 28530 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cosD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3249 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int srcenc = opnd_array(1)->reg(ra_,this,idx1);

    // subq rsp,#8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x5, RSP_enc);
    emit_d8(cbuf, 0x8);

    // movsd [rsp],src
    emit_opcode(cbuf, 0xF2);
    if (srcenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x11);
    encode_RegMem(cbuf, srcenc, RSP_enc, 0x4, 0, 0, false);

    // fldd [rsp]
    emit_opcode(cbuf, 0x66);
    emit_opcode(cbuf, 0xDD);
    encode_RegMem(cbuf, 0x0, RSP_enc, 0x4, 0, 0, false);
  
#line 28564 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD9 /*primary()*/));
  
#line 28572 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*secondary()*/));
  
#line 28580 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3228 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(1)->reg(ra_,this,idx1);

    store_to_stackslot( cbuf, 0xDD, 0x03, 0 ); //FSTP [RSP]

    // UseXmmLoadAndClearUpper ? movsd dst,[rsp] : movlpd dst,[rsp]
    emit_opcode  (cbuf, UseXmmLoadAndClearUpper ? 0xF2 : 0x66);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode  (cbuf, 0x0F );
    emit_opcode  (cbuf, UseXmmLoadAndClearUpper ? 0x10 : 0x12 );
    encode_RegMem(cbuf, dstenc, RSP_enc, 0x4, 0, 0, false);

    // add rsp,8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf,0x83);
    emit_rm(cbuf,0x3, 0x0, RSP_enc);
    emit_d8(cbuf,0x08);
  
#line 28605 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void sinD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3249 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int srcenc = opnd_array(1)->reg(ra_,this,idx1);

    // subq rsp,#8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x5, RSP_enc);
    emit_d8(cbuf, 0x8);

    // movsd [rsp],src
    emit_opcode(cbuf, 0xF2);
    if (srcenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x11);
    encode_RegMem(cbuf, srcenc, RSP_enc, 0x4, 0, 0, false);

    // fldd [rsp]
    emit_opcode(cbuf, 0x66);
    emit_opcode(cbuf, 0xDD);
    encode_RegMem(cbuf, 0x0, RSP_enc, 0x4, 0, 0, false);
  
#line 28639 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD9 /*primary()*/));
  
#line 28647 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xFE /*secondary()*/));
  
#line 28655 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3228 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(1)->reg(ra_,this,idx1);

    store_to_stackslot( cbuf, 0xDD, 0x03, 0 ); //FSTP [RSP]

    // UseXmmLoadAndClearUpper ? movsd dst,[rsp] : movlpd dst,[rsp]
    emit_opcode  (cbuf, UseXmmLoadAndClearUpper ? 0xF2 : 0x66);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode  (cbuf, 0x0F );
    emit_opcode  (cbuf, UseXmmLoadAndClearUpper ? 0x10 : 0x12 );
    encode_RegMem(cbuf, dstenc, RSP_enc, 0x4, 0, 0, false);

    // add rsp,8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf,0x83);
    emit_rm(cbuf,0x3, 0x0, RSP_enc);
    emit_d8(cbuf,0x08);
  
#line 28680 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void tanD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3249 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int srcenc = opnd_array(1)->reg(ra_,this,idx1);

    // subq rsp,#8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x5, RSP_enc);
    emit_d8(cbuf, 0x8);

    // movsd [rsp],src
    emit_opcode(cbuf, 0xF2);
    if (srcenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x11);
    encode_RegMem(cbuf, srcenc, RSP_enc, 0x4, 0, 0, false);

    // fldd [rsp]
    emit_opcode(cbuf, 0x66);
    emit_opcode(cbuf, 0xDD);
    encode_RegMem(cbuf, 0x0, RSP_enc, 0x4, 0, 0, false);
  
#line 28714 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD9));
  
#line 28722 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2));
  
#line 28730 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xDD));
  
#line 28738 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD8));
  
#line 28746 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3228 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(1)->reg(ra_,this,idx1);

    store_to_stackslot( cbuf, 0xDD, 0x03, 0 ); //FSTP [RSP]

    // UseXmmLoadAndClearUpper ? movsd dst,[rsp] : movlpd dst,[rsp]
    emit_opcode  (cbuf, UseXmmLoadAndClearUpper ? 0xF2 : 0x66);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode  (cbuf, 0x0F );
    emit_opcode  (cbuf, UseXmmLoadAndClearUpper ? 0x10 : 0x12 );
    encode_RegMem(cbuf, dstenc, RSP_enc, 0x4, 0, 0, false);

    // add rsp,8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf,0x83);
    emit_rm(cbuf,0x3, 0x0, RSP_enc);
    emit_d8(cbuf,0x08);
  
#line 28771 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void log10D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD9));
  
#line 28785 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xEC));
  
#line 28793 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3249 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int srcenc = opnd_array(1)->reg(ra_,this,idx1);

    // subq rsp,#8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x5, RSP_enc);
    emit_d8(cbuf, 0x8);

    // movsd [rsp],src
    emit_opcode(cbuf, 0xF2);
    if (srcenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x11);
    encode_RegMem(cbuf, srcenc, RSP_enc, 0x4, 0, 0, false);

    // fldd [rsp]
    emit_opcode(cbuf, 0x66);
    emit_opcode(cbuf, 0xDD);
    encode_RegMem(cbuf, 0x0, RSP_enc, 0x4, 0, 0, false);
  
#line 28821 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD9));
  
#line 28829 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF1));
  
#line 28837 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3228 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(1)->reg(ra_,this,idx1);

    store_to_stackslot( cbuf, 0xDD, 0x03, 0 ); //FSTP [RSP]

    // UseXmmLoadAndClearUpper ? movsd dst,[rsp] : movlpd dst,[rsp]
    emit_opcode  (cbuf, UseXmmLoadAndClearUpper ? 0xF2 : 0x66);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode  (cbuf, 0x0F );
    emit_opcode  (cbuf, UseXmmLoadAndClearUpper ? 0x10 : 0x12 );
    encode_RegMem(cbuf, dstenc, RSP_enc, 0x4, 0, 0, false);

    // add rsp,8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf,0x83);
    emit_rm(cbuf,0x3, 0x0, RSP_enc);
    emit_d8(cbuf,0x08);
  
#line 28862 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void logD_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD9));
  
#line 28876 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xED));
  
#line 28884 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3249 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int srcenc = opnd_array(1)->reg(ra_,this,idx1);

    // subq rsp,#8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x5, RSP_enc);
    emit_d8(cbuf, 0x8);

    // movsd [rsp],src
    emit_opcode(cbuf, 0xF2);
    if (srcenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x11);
    encode_RegMem(cbuf, srcenc, RSP_enc, 0x4, 0, 0, false);

    // fldd [rsp]
    emit_opcode(cbuf, 0x66);
    emit_opcode(cbuf, 0xDD);
    encode_RegMem(cbuf, 0x0, RSP_enc, 0x4, 0, 0, false);
  
#line 28912 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xD9));
  
#line 28920 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF1));
  
#line 28928 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3228 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(1)->reg(ra_,this,idx1);

    store_to_stackslot( cbuf, 0xDD, 0x03, 0 ); //FSTP [RSP]

    // UseXmmLoadAndClearUpper ? movsd dst,[rsp] : movlpd dst,[rsp]
    emit_opcode  (cbuf, UseXmmLoadAndClearUpper ? 0xF2 : 0x66);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode  (cbuf, 0x0F );
    emit_opcode  (cbuf, UseXmmLoadAndClearUpper ? 0x10 : 0x12 );
    encode_RegMem(cbuf, dstenc, RSP_enc, 0x4, 0, 0, false);

    // add rsp,8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf,0x83);
    emit_rm(cbuf,0x3, 0x0, RSP_enc);
    emit_d8(cbuf,0x08);
  
#line 28953 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void roundFloat_nopNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  // User did not define which encode class to use.
}
void roundDouble_nopNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  // User did not define which encode class to use.
}
void convF2D_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 28981 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 28999 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 29007 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x5A /*tertiary()*/));
  
#line 29015 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 29023 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convF2D_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 29037 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 29071 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 29079 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x5A /*tertiary()*/));
  
#line 29087 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 29103 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convD2F_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 29117 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 29135 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 29143 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x5A /*tertiary()*/));
  
#line 29151 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 29159 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convD2F_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 29173 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 29207 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 29215 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x5A /*tertiary()*/));
  
#line 29223 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 29239 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convF2I_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 29253 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 29271 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 29279 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2C /*tertiary()*/));
  
#line 29287 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 29295 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3622 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);
    int srcenc = opnd_array(1)->reg(ra_,this,idx1);

    // cmpl $dst, #0x80000000
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x81);
    emit_rm(cbuf, 0x3, 0x7, dstenc & 7);
    emit_d32(cbuf, 0x80000000);

    // jne,s done
    emit_opcode(cbuf, 0x75);
    if (srcenc < 8 && dstenc < 8) {
      emit_d8(cbuf, 0xF);
    } else if (srcenc >= 8 && dstenc >= 8) {
      emit_d8(cbuf, 0x11);
    } else {
      emit_d8(cbuf, 0x10);
    }

    // subq rsp, #8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x5, RSP_enc);
    emit_d8(cbuf, 8);

    // movss [rsp], $src
    emit_opcode(cbuf, 0xF3);
    if (srcenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x11);
    encode_RegMem(cbuf, srcenc, RSP_enc, 0x4, 0, 0, false); // 2 bytes

    // call f2i_fixup
    cbuf.set_insts_mark();
    emit_opcode(cbuf, 0xE8);
    emit_d32_reloc(cbuf,
                   (int)
                   (StubRoutines::x86::f2i_fixup() - cbuf.insts_end() - 4),
                   runtime_call_Relocation::spec(),
                   RELOC_DISP32);

    // popq $dst
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x58 | (dstenc & 7));

    // done:
  
#line 29354 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convF2L_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 29368 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 29388 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 29396 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2C /*tertiary()*/));
  
#line 29404 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 29412 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3678 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);
    int srcenc = opnd_array(1)->reg(ra_,this,idx1);
    address const_address = (address) StubRoutines::x86::double_sign_flip();

    // cmpq $dst, [0x8000000000000000]
    cbuf.set_insts_mark();
    emit_opcode(cbuf, dstenc < 8 ? Assembler::REX_W : Assembler::REX_WR);
    emit_opcode(cbuf, 0x39);
    // XXX reg_mem doesn't support RIP-relative addressing yet
    emit_rm(cbuf, 0x0, dstenc & 7, 0x5); // 00 reg 101
    emit_d32_reloc(cbuf, const_address);


    // jne,s done
    emit_opcode(cbuf, 0x75);
    if (srcenc < 8 && dstenc < 8) {
      emit_d8(cbuf, 0xF);
    } else if (srcenc >= 8 && dstenc >= 8) {
      emit_d8(cbuf, 0x11);
    } else {
      emit_d8(cbuf, 0x10);
    }

    // subq rsp, #8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x5, RSP_enc);
    emit_d8(cbuf, 8);

    // movss [rsp], $src
    emit_opcode(cbuf, 0xF3);
    if (srcenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x11);
    encode_RegMem(cbuf, srcenc, RSP_enc, 0x4, 0, 0, false); // 2 bytes

    // call f2l_fixup
    cbuf.set_insts_mark();
    emit_opcode(cbuf, 0xE8);
    emit_d32_reloc(cbuf,
                   (int)
                   (StubRoutines::x86::f2l_fixup() - cbuf.insts_end() - 4),
                   runtime_call_Relocation::spec(),
                   RELOC_DISP32);

    // popq $dst
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x58 | (dstenc & 7));

    // done:
  
#line 29473 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convD2I_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 29487 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 29505 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 29513 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2C /*tertiary()*/));
  
#line 29521 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 29529 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3736 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);
    int srcenc = opnd_array(1)->reg(ra_,this,idx1);

    // cmpl $dst, #0x80000000
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x81);
    emit_rm(cbuf, 0x3, 0x7, dstenc & 7);
    emit_d32(cbuf, 0x80000000);

    // jne,s done
    emit_opcode(cbuf, 0x75);
    if (srcenc < 8 && dstenc < 8) {
      emit_d8(cbuf, 0xF);
    } else if (srcenc >= 8 && dstenc >= 8) {
      emit_d8(cbuf, 0x11);
    } else {
      emit_d8(cbuf, 0x10);
    }

    // subq rsp, #8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x5, RSP_enc);
    emit_d8(cbuf, 8);

    // movsd [rsp], $src
    emit_opcode(cbuf, 0xF2);
    if (srcenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x11);
    encode_RegMem(cbuf, srcenc, RSP_enc, 0x4, 0, 0, false); // 2 bytes

    // call d2i_fixup
    cbuf.set_insts_mark();
    emit_opcode(cbuf, 0xE8);
    emit_d32_reloc(cbuf,
                   (int)
                   (StubRoutines::x86::d2i_fixup() - cbuf.insts_end() - 4),
                   runtime_call_Relocation::spec(),
                   RELOC_DISP32);

    // popq $dst
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x58 | (dstenc & 7));

    // done:
  
#line 29588 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convD2L_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 29602 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 29622 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 29630 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2C /*tertiary()*/));
  
#line 29638 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 29646 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3792 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int dstenc = opnd_array(0)->reg(ra_,this);
    int srcenc = opnd_array(1)->reg(ra_,this,idx1);
    address const_address = (address) StubRoutines::x86::double_sign_flip();

    // cmpq $dst, [0x8000000000000000]
    cbuf.set_insts_mark();
    emit_opcode(cbuf, dstenc < 8 ? Assembler::REX_W : Assembler::REX_WR);
    emit_opcode(cbuf, 0x39);
    // XXX reg_mem doesn't support RIP-relative addressing yet
    emit_rm(cbuf, 0x0, dstenc & 7, 0x5); // 00 reg 101
    emit_d32_reloc(cbuf, const_address);


    // jne,s done
    emit_opcode(cbuf, 0x75);
    if (srcenc < 8 && dstenc < 8) {
      emit_d8(cbuf, 0xF);
    } else if (srcenc >= 8 && dstenc >= 8) {
      emit_d8(cbuf, 0x11);
    } else {
      emit_d8(cbuf, 0x10);
    }

    // subq rsp, #8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x5, RSP_enc);
    emit_d8(cbuf, 8);

    // movsd [rsp], $src
    emit_opcode(cbuf, 0xF2);
    if (srcenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x11);
    encode_RegMem(cbuf, srcenc, RSP_enc, 0x4, 0, 0, false); // 2 bytes

    // call d2l_fixup
    cbuf.set_insts_mark();
    emit_opcode(cbuf, 0xE8);
    emit_d32_reloc(cbuf,
                   (int)
                   (StubRoutines::x86::d2l_fixup() - cbuf.insts_end() - 4),
                   runtime_call_Relocation::spec(),
                   RELOC_DISP32);

    // popq $dst
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x58 | (dstenc & 7));

    // done:
  
#line 29707 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convI2F_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 29721 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 29739 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 29747 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2A /*tertiary()*/));
  
#line 29755 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 29763 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convI2F_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 29777 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 29811 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 29819 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2A /*tertiary()*/));
  
#line 29827 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 29843 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convI2D_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 29857 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 29875 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 29883 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2A /*tertiary()*/));
  
#line 29891 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 29899 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convI2D_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 29913 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 29947 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 29955 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2A /*tertiary()*/));
  
#line 29963 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 29979 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convXI2F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 11092 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this), opnd_array(1)->as_Register(ra_,this,idx1));
    __ cvtdq2ps(opnd_array(0)->as_XMMRegister(ra_,this), opnd_array(0)->as_XMMRegister(ra_,this));
  
#line 29995 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convXI2D_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 11106 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movdl(opnd_array(0)->as_XMMRegister(ra_,this), opnd_array(1)->as_Register(ra_,this,idx1));
    __ cvtdq2pd(opnd_array(0)->as_XMMRegister(ra_,this), opnd_array(0)->as_XMMRegister(ra_,this));
  
#line 30011 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convL2F_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 30025 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 30045 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 30053 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2A /*tertiary()*/));
  
#line 30061 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 30069 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convL2F_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 30083 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 30119 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 30127 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2A /*tertiary()*/));
  
#line 30135 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 30151 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convL2D_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 30165 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 30185 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 30193 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2A /*tertiary()*/));
  
#line 30201 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(0)->reg(ra_,this) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 30209 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convL2D_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 30223 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 30259 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 30267 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x2A /*tertiary()*/));
  
#line 30275 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 30291 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convI2L_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 11159 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ movslq(opnd_array(0)->as_Register(ra_,this), opnd_array(1)->as_Register(ra_,this,idx1));
  
#line 30306 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convI2L_reg_reg_zexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2770 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    encode_copy(cbuf, opnd_array(0)->reg(ra_,this), opnd_array(1)->reg(ra_,this,idx1));
  
#line 30321 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convI2L_reg_mem_zexNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 30362 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 30370 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 30386 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void zerox_long_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2780 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int srcenc = opnd_array(1)->reg(ra_,this,idx1);
    int dstenc = opnd_array(0)->reg(ra_,this);

    if (dstenc < 8) {
      if (srcenc >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
        srcenc -= 8;
      }
    } else {
      if (srcenc < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
        srcenc -= 8;
      }
      dstenc -= 8;
    }

    emit_opcode(cbuf, 0x8B);
    emit_rm(cbuf, 0x3, dstenc, srcenc);
  
#line 30420 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void convL2I_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2780 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int srcenc = opnd_array(1)->reg(ra_,this,idx1);
    int dstenc = opnd_array(0)->reg(ra_,this);

    if (dstenc < 8) {
      if (srcenc >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
        srcenc -= 8;
      }
    } else {
      if (srcenc < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
        srcenc -= 8;
      }
      dstenc -= 8;
    }

    emit_opcode(cbuf, 0x8B);
    emit_rm(cbuf, 0x3, dstenc, srcenc);
  
#line 30453 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void MoveF2I_stack_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 30493 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 30501 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 30517 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void MoveI2F_stack_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 30531 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 30565 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 30573 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x10 /*tertiary()*/));
  
#line 30581 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 30597 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void MoveD2L_stack_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 30639 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x8B /*primary()*/));
  
#line 30647 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 30663 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void MoveL2D_stack_reg_partialNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x66 /*primary()*/));
  
#line 30677 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 30711 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 30719 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x12 /*tertiary()*/));
  
#line 30727 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 30743 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void MoveL2D_stack_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 30757 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(0)->reg(ra_,this) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 30791 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 30799 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x10 /*tertiary()*/));
  
#line 30807 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(0)->reg(ra_,this);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 30823 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void MoveF2I_reg_stackNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3 /*primary()*/));
  
#line 30837 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 30871 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 30879 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x11 /*tertiary()*/));
  
#line 30887 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(0)->base(ra_,this,idx0);
    int index = opnd_array(0)->index(ra_,this,idx0);
    int scale = opnd_array(0)->scale();
    int disp = opnd_array(0)->disp(ra_,this,0);
    bool disp_is_oop = opnd_array(0)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 30903 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void MoveI2F_reg_stackNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 30943 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x89 /*primary()*/));
  
#line 30951 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(0)->base(ra_,this,idx0);
    int index = opnd_array(0)->index(ra_,this,idx0);
    int scale = opnd_array(0)->scale();
    int disp = opnd_array(0)->disp(ra_,this,0);
    bool disp_is_oop = opnd_array(0)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 30967 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void MoveD2L_reg_stackNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF2 /*primary()*/));
  
#line 30981 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 31015 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*secondary()*/));
  
#line 31023 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2155 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x11 /*tertiary()*/));
  
#line 31031 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(0)->base(ra_,this,idx0);
    int index = opnd_array(0)->index(ra_,this,idx0);
    int scale = opnd_array(0)->scale();
    int disp = opnd_array(0)->disp(ra_,this,0);
    bool disp_is_oop = opnd_array(0)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 31047 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void MoveL2D_reg_stackNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(0)->base(ra_,this,idx0) < 8) {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(0)->index(ra_,this,idx0) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 31089 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x89 /*primary()*/));
  
#line 31097 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(0)->base(ra_,this,idx0);
    int index = opnd_array(0)->index(ra_,this,idx0);
    int scale = opnd_array(0)->scale();
    int disp = opnd_array(0)->disp(ra_,this,0);
    bool disp_is_oop = opnd_array(0)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 31113 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void MoveF2I_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 11329 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
__ movdl(opnd_array(0)->as_Register(ra_,this), opnd_array(1)->as_XMMRegister(ra_,this,idx1)); 
#line 31126 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void MoveD2L_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 11338 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
__ movdq(opnd_array(0)->as_Register(ra_,this), opnd_array(1)->as_XMMRegister(ra_,this,idx1)); 
#line 31139 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void MoveI2F_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 11348 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
__ movdl(opnd_array(0)->as_XMMRegister(ra_,this), opnd_array(1)->as_Register(ra_,this,idx1)); 
#line 31152 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void MoveL2D_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {
    MacroAssembler _masm(&cbuf);

#line 11357 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
__ movdq(opnd_array(0)->as_XMMRegister(ra_,this), opnd_array(1)->as_Register(ra_,this,idx1)); 
#line 31165 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void Repl8B_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3284 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    encode_CopyXD(cbuf, opnd_array(0)->reg(ra_,this), opnd_array(1)->reg(ra_,this,idx1));
    __ punpcklbw(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(0)->reg(ra_,this)));
    __ pshuflw(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(0)->reg(ra_,this)), 0x00);
  
#line 31183 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void Repl8B_rRegINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3310 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ movdl(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_Register(opnd_array(1)->reg(ra_,this,idx1)));
  
#line 31199 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3284 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    encode_CopyXD(cbuf, opnd_array(0)->reg(ra_,this), opnd_array(0)->reg(ra_,this));
    __ punpcklbw(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(0)->reg(ra_,this)));
    __ pshuflw(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(0)->reg(ra_,this)), 0x00);
  
#line 31211 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void Repl8B_immI0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3304 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ pxor(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(0)->reg(ra_,this)));
  
#line 31227 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void Repl4S_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3292 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ pshuflw(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(1)->reg(ra_,this,idx1)), 0x00);
  
#line 31243 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void Repl4S_rRegINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3310 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ movdl(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_Register(opnd_array(1)->reg(ra_,this,idx1)));
  
#line 31259 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3292 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ pshuflw(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(0)->reg(ra_,this)), 0x00);
  
#line 31269 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void Repl4S_immI0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3304 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ pxor(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(0)->reg(ra_,this)));
  
#line 31285 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void Repl4C_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3292 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ pshuflw(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(1)->reg(ra_,this,idx1)), 0x00);
  
#line 31301 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void Repl4C_rRegINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3310 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ movdl(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_Register(opnd_array(1)->reg(ra_,this,idx1)));
  
#line 31317 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3292 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ pshuflw(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(0)->reg(ra_,this)), 0x00);
  
#line 31327 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void Repl4C_immI0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3304 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ pxor(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(0)->reg(ra_,this)));
  
#line 31343 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void Repl2I_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3298 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ pshufd(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(1)->reg(ra_,this,idx1)), (0x00));
  
#line 31359 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void Repl2I_rRegINode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3310 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ movdl(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_Register(opnd_array(1)->reg(ra_,this,idx1)));
  
#line 31375 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3298 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ pshufd(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(0)->reg(ra_,this)), (0x00));
  
#line 31385 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void Repl2I_immI0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3304 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ pxor(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(0)->reg(ra_,this)));
  
#line 31401 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void Repl2F_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3298 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ pshufd(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(1)->reg(ra_,this,idx1)), (0xe0));
  
#line 31417 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void Repl2F_regFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3298 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ pshufd(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(1)->reg(ra_,this,idx1)), (0xe0));
  
#line 31433 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void Repl2F_immF0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 3304 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);

    __ pxor(as_XMMRegister(opnd_array(0)->reg(ra_,this)), as_XMMRegister(opnd_array(0)->reg(ra_,this)));
  
#line 31449 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void rep_stosNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2182 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x33));
    emit_rm(cbuf, 0x3, (RAX_enc) & 7, (RAX_enc) & 7);
  
#line 31465 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF3));
  
#line 31473 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x48));
  
#line 31481 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xAB));
  
#line 31489 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void string_compareNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
    unsigned idx5 = idx4 + opnd_array(4)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 11511 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ string_compare(opnd_array(1)->as_Register(ra_,this,idx1), opnd_array(3)->as_Register(ra_,this,idx3),
                      opnd_array(2)->as_Register(ra_,this,idx2), opnd_array(4)->as_Register(ra_,this,idx4), opnd_array(0)->as_Register(ra_,this),
                      opnd_array(5)->as_XMMRegister(ra_,this,idx5));
  
#line 31510 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void string_indexof_conNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
    unsigned idx5 = idx4 + opnd_array(4)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 11528 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int icnt2 = (int)opnd_array(4)->constant();
    if (icnt2 >= 8) {
      // IndexOf for constant substrings with size >= 8 elements
      // which don't need to be loaded through stack.
      __ string_indexofC8(opnd_array(1)->as_Register(ra_,this,idx1), opnd_array(3)->as_Register(ra_,this,idx3),
                          opnd_array(2)->as_Register(ra_,this,idx2), as_Register(RAX_enc),
                          icnt2, opnd_array(0)->as_Register(ra_,this),
                          opnd_array(5)->as_XMMRegister(ra_,this,idx5), as_Register(RCX_enc));
    } else {
      // Small strings are loaded through stack if they cross page boundary.
      __ string_indexof(opnd_array(1)->as_Register(ra_,this,idx1), opnd_array(3)->as_Register(ra_,this,idx3),
                        opnd_array(2)->as_Register(ra_,this,idx2), as_Register(RAX_enc),
                        icnt2, opnd_array(0)->as_Register(ra_,this),
                        opnd_array(5)->as_XMMRegister(ra_,this,idx5), as_Register(RCX_enc));
    }
  
#line 31543 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void string_indexofNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
    unsigned idx5 = idx4 + opnd_array(4)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 11556 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ string_indexof(opnd_array(1)->as_Register(ra_,this,idx1), opnd_array(3)->as_Register(ra_,this,idx3),
                      opnd_array(2)->as_Register(ra_,this,idx2), opnd_array(4)->as_Register(ra_,this,idx4),
                      (-1), opnd_array(0)->as_Register(ra_,this),
                      opnd_array(5)->as_XMMRegister(ra_,this,idx5), as_Register(RCX_enc));
  
#line 31565 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void string_equalsNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
    unsigned idx5 = idx4 + opnd_array(4)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 11573 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ char_arrays_equals(false, opnd_array(1)->as_Register(ra_,this,idx1), opnd_array(2)->as_Register(ra_,this,idx2),
                          opnd_array(3)->as_Register(ra_,this,idx3), opnd_array(0)->as_Register(ra_,this), as_Register(RBX_enc),
                          opnd_array(4)->as_XMMRegister(ra_,this,idx4), opnd_array(5)->as_XMMRegister(ra_,this,idx5));
  
#line 31586 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void array_equalsNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 11590 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ char_arrays_equals(true, opnd_array(1)->as_Register(ra_,this,idx1), opnd_array(2)->as_Register(ra_,this,idx2),
                          as_Register(RCX_enc), opnd_array(0)->as_Register(ra_,this), as_Register(RBX_enc),
                          opnd_array(3)->as_XMMRegister(ra_,this,idx3), opnd_array(4)->as_XMMRegister(ra_,this,idx4));
  
#line 31606 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compI_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 31631 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 31639 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 31647 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compI_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2377 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x07 /*secondary()*/), dstenc);
  
#line 31677 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 31691 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compI_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 31732 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 31740 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 31756 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void testI_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 31781 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 31789 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 31797 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void testI_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 31815 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 31823 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x00 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 31832 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2831 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Output immediate
    emit_d32(cbuf, opnd_array(2)->constant());
  
#line 31841 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void testI_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 31883 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 31891 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 31907 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void testI_reg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 31949 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 31957 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 31973 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compU_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 31998 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 32006 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 32014 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compU_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2377 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x07 /*secondary()*/), dstenc);
  
#line 32044 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constant() && opnd_array(2)->constant() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constant());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constant());
    }
  
#line 32058 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compU_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3014 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  
#line 32099 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 32107 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 32123 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void testU_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 32148 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 32156 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 32164 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compP_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 32191 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 32199 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 32207 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compP_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 32250 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 32258 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 32274 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compP_mem_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 32317 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 32325 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 32341 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void testP_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 32368 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 32376 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 32384 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void testP_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2891 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->base(ra_,this,idx1) >= 8) {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if (opnd_array(1)->index(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  
#line 32411 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 32419 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3091 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int rm_byte_opcode = (0x00);

    // High registers handle in encode_RegMem
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int displace = opnd_array(1)->disp(ra_,this,idx1);

    bool disp_is_oop = opnd_array(1)->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  
#line 32439 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2858 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_d32(cbuf,(0xFFFFFFFF));
  
#line 32447 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void testP_mem_reg0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 11798 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ cmpq(r12, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 32463 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compN_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 11809 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
__ cmpl(opnd_array(1)->as_Register(ra_,this,idx1), opnd_array(2)->as_Register(ra_,this,idx2)); 
#line 32477 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compN_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 11818 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ cmpl(opnd_array(1)->as_Register(ra_,this,idx1), Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_is_oop()));
  
#line 32493 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compN_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 11828 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ cmp_narrow_oop(opnd_array(1)->as_Register(ra_,this,idx1), (jobject)opnd_array(2)->constant());
  
#line 32509 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compN_mem_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 11839 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ cmp_narrow_oop(Address::make_raw(opnd_array(2)->base(ra_,this,idx2), opnd_array(2)->index(ra_,this,idx2), opnd_array(2)->scale(), opnd_array(2)->disp(ra_,this,idx2), opnd_array(2)->disp_is_oop()), (jobject)opnd_array(1)->constant());
  
#line 32525 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void testN_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 11849 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"
__ testl(opnd_array(1)->as_Register(ra_,this,idx1), opnd_array(1)->as_Register(ra_,this,idx1)); 
#line 32539 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void testN_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 11860 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ cmpl(Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()), (int)0xFFFFFFFF);
  
#line 32555 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void testN_mem_reg0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 11872 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ cmpl(r12, Address::make_raw(opnd_array(1)->base(ra_,this,idx1), opnd_array(1)->index(ra_,this,idx1), opnd_array(1)->scale(), opnd_array(1)->disp(ra_,this,idx1), opnd_array(1)->disp_is_oop()));
  
#line 32571 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compL_rRegNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 32598 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 32606 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 32614 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compL_rReg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2397 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // OpcSEr/m
    int dstenc = opnd_array(1)->reg(ra_,this,idx1);
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_opcode(cbuf, (0x81 /*primary()*/) | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, (0x81 /*primary()*/));
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, (0x07 /*secondary()*/), dstenc);
  
#line 32646 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2419 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= opnd_array(2)->constantL() && opnd_array(2)->constantL() < 0x80) {
      emit_d8(cbuf, opnd_array(2)->constantL());
    } else {
      // 32-bit immediate
      emit_d32(cbuf, opnd_array(2)->constantL());
    }
  
#line 32660 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void compL_rReg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 32703 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x3B /*primary()*/));
  
#line 32711 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 32727 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void testL_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2997 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  
#line 32754 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 32762 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 32770 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void testL_reg_immNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  
#line 32790 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xF7 /*primary()*/));
  
#line 32798 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x00 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 32807 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2831 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // Output immediate
    emit_d32(cbuf, opnd_array(2)->constantL());
  
#line 32816 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void testL_reg_memNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(2)->base(ra_,this,idx2) < 8) {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(2)->index(ra_,this,idx2) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 32860 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 32868 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(1)->reg(ra_,this,idx1);
    int base = opnd_array(2)->base(ra_,this,idx2);
    int index = opnd_array(2)->index(ra_,this,idx2);
    int scale = opnd_array(2)->scale();
    int disp = opnd_array(2)->disp(ra_,this,idx2);
    bool disp_is_oop = opnd_array(2)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 32884 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void testL_reg_mem_0Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 2;
    unsigned idx1 = 2;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 3045 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if (opnd_array(1)->base(ra_,this,idx1) < 8) {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if (opnd_array(1)->index(ra_,this,idx1) < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  
#line 32928 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x85 /*primary()*/));
  
#line 32936 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 3078 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // High registers handle in encode_RegMem
    int reg = opnd_array(2)->reg(ra_,this,idx2);
    int base = opnd_array(1)->base(ra_,this,idx1);
    int index = opnd_array(1)->index(ra_,this,idx1);
    int scale = opnd_array(1)->scale();
    int disp = opnd_array(1)->disp(ra_,this,idx1);
    bool disp_is_oop = opnd_array(1)->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  
#line 32952 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpL3_reg_regNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 3178 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    int src1enc = opnd_array(1)->reg(ra_,this,idx1);
    int src2enc = opnd_array(2)->reg(ra_,this,idx2);
    int dstenc = opnd_array(0)->reg(ra_,this);

    // cmpq $src1, $src2
    if (src1enc < 8) {
      if (src2enc < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (src2enc < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
    emit_opcode(cbuf, 0x3B);
    emit_rm(cbuf, 0x3, src1enc & 7, src2enc & 7);

    // movl $dst, -1
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0xB8 | (dstenc & 7));
    emit_d32(cbuf, -1);

    // jl,s done
    emit_opcode(cbuf, 0x7C);
    emit_d8(cbuf, dstenc < 4 ? 0x06 : 0x08);

    // setne $dst
    if (dstenc >= 4) {
      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x95);
    emit_opcode(cbuf, 0xC0 | (dstenc & 7));

    // movzbl $dst, $dst
    if (dstenc >= 4) {
      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_RB);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0xB6);
    emit_rm(cbuf, 0x3, dstenc & 7, dstenc & 7);
  
#line 33013 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovI_reg_gNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 33039 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 33047 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x4F /*secondary()*/));
  
#line 33055 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 33063 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmovI_reg_lNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2982 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) < 8) {
      if (opnd_array(2)->reg(ra_,this,idx2) >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (opnd_array(2)->reg(ra_,this,idx2) < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  
#line 33089 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x0F /*primary()*/));
  
#line 33097 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2149 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x4C /*secondary()*/));
  
#line 33105 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2177 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_rm(cbuf, 0x3, opnd_array(1)->reg(ra_,this,idx1) & 7, opnd_array(2)->reg(ra_,this,idx2) & 7);
  
#line 33113 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void jmpDirNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xE9 /*primary()*/));
  
#line 33127 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2430 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // JMP, CALL
    Label* l = opnd_array(1)->label();
    emit_d32(cbuf, l ? (l->loc_pos() - (cbuf.insts_size() + 4)) : 0);
  
#line 33137 "../generated/adfiles/ad_x86_64.cpp"
  }
}
uint  jmpDirNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 5, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 5);
}
void jmpConNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2464 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // JCC
    Label* l = opnd_array(3)->label();
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x80 /*secondary()*/), opnd_array(1)->ccode());
    emit_d32(cbuf, l ? (l->loc_pos() - (cbuf.insts_size() + 4)) : 0);
  
#line 33161 "../generated/adfiles/ad_x86_64.cpp"
  }
}
uint  jmpConNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 6, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 6);
}
void jmpLoopEndNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2464 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // JCC
    Label* l = opnd_array(3)->label();
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x80 /*secondary()*/), opnd_array(1)->ccode());
    emit_d32(cbuf, l ? (l->loc_pos() - (cbuf.insts_size() + 4)) : 0);
  
#line 33185 "../generated/adfiles/ad_x86_64.cpp"
  }
}
uint  jmpLoopEndNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 6, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 6);
}
void jmpLoopEndUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2464 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // JCC
    Label* l = opnd_array(3)->label();
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x80 /*secondary()*/), opnd_array(1)->ccode());
    emit_d32(cbuf, l ? (l->loc_pos() - (cbuf.insts_size() + 4)) : 0);
  
#line 33209 "../generated/adfiles/ad_x86_64.cpp"
  }
}
uint  jmpLoopEndUNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 6, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 6);
}
void jmpLoopEndUCFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2464 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // JCC
    Label* l = opnd_array(3)->label();
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x80 /*secondary()*/), opnd_array(1)->ccode());
    emit_d32(cbuf, l ? (l->loc_pos() - (cbuf.insts_size() + 4)) : 0);
  
#line 33233 "../generated/adfiles/ad_x86_64.cpp"
  }
}
uint  jmpLoopEndUCFNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 6, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 6);
}
void jmpConUNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2464 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // JCC
    Label* l = opnd_array(3)->label();
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x80 /*secondary()*/), opnd_array(1)->ccode());
    emit_d32(cbuf, l ? (l->loc_pos() - (cbuf.insts_size() + 4)) : 0);
  
#line 33257 "../generated/adfiles/ad_x86_64.cpp"
  }
}
uint  jmpConUNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 6, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 6);
}
void jmpConUCFNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2464 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // JCC
    Label* l = opnd_array(3)->label();
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x80 /*secondary()*/), opnd_array(1)->ccode());
    emit_d32(cbuf, l ? (l->loc_pos() - (cbuf.insts_size() + 4)) : 0);
  
#line 33281 "../generated/adfiles/ad_x86_64.cpp"
  }
}
uint  jmpConUCFNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 6, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 6);
}
void jmpConUCF2Node::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 12127 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Label* l = opnd_array(3)->label();
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x80 /*secondary()*/), Assembler::parity);
    int parity_disp = -1;
    if (opnd_array(1)->ccode()== Assembler::notEqual) {
       // the two jumps 6 bytes apart so the jump distances are too
       parity_disp = l ? (l->loc_pos() - (cbuf.insts_size() + 4)) : 0;
    } else if (opnd_array(1)->ccode()== Assembler::equal) {
       parity_disp = 6;
    } else {
       ShouldNotReachHere();
    }
    emit_d32(cbuf, parity_disp);
    emit_d8(cbuf, (0x0F /*primary()*/));
    emit_cc(cbuf, (0x80 /*secondary()*/), opnd_array(1)->ccode());
    int disp = l ? (l->loc_pos() - (cbuf.insts_size() + 4)) : 0;
    emit_d32(cbuf, disp);
  
#line 33318 "../generated/adfiles/ad_x86_64.cpp"
  }
}
uint  jmpConUCF2Node::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 12, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 12);
}
void partialSubtypeCheckNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2539 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register Rrdi = as_Register(RDI_enc); // result register
    Register Rrax = as_Register(RAX_enc); // super class
    Register Rrcx = as_Register(RCX_enc); // killed
    Register Rrsi = as_Register(RSI_enc); // sub class
    Label miss;
    const bool set_cond_codes = true;

    MacroAssembler _masm(&cbuf);
    __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
                                     NULL, &miss,
                                     /*set_cond_codes:*/ true);
    if ((0x1 /*primary()*/)) {
      __ xorptr(Rrdi, Rrdi);
    }
    __ bind(miss);
  
#line 33351 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void partialSubtypeCheck_vs_ZeroNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2539 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register Rrdi = as_Register(RDI_enc); // result register
    Register Rrax = as_Register(RAX_enc); // super class
    Register Rrcx = as_Register(RCX_enc); // killed
    Register Rrsi = as_Register(RSI_enc); // sub class
    Label miss;
    const bool set_cond_codes = true;

    MacroAssembler _masm(&cbuf);
    __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
                                     NULL, &miss,
                                     /*set_cond_codes:*/ true);
    if ((0x0 /*primary()*/)) {
      __ xorptr(Rrdi, Rrdi);
    }
    __ bind(miss);
  
#line 33381 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void jmpDir_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xEB /*primary()*/));
  
#line 33395 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2437 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // JMP, CALL
    Label* l = opnd_array(1)->label();
    int disp = l ? (l->loc_pos() - (cbuf.insts_size() + 1)) : 0;
    assert(-128 <= disp && disp <= 127, "Displacement too large for short jmp");
    emit_d8(cbuf, disp);
  
#line 33407 "../generated/adfiles/ad_x86_64.cpp"
  }
}
uint  jmpDir_shortNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 2, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 2);
}
void jmpCon_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2473 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

  // JCC
    Label *l = opnd_array(3)->label();
    emit_cc(cbuf, (0x70 /*primary()*/), opnd_array(1)->ccode());
    int disp = l ? (l->loc_pos() - (cbuf.insts_size() + 1)) : 0;
    assert(-128 <= disp && disp <= 127, "Displacement too large for short jmp");
    emit_d8(cbuf, disp);
  
#line 33432 "../generated/adfiles/ad_x86_64.cpp"
  }
}
uint  jmpCon_shortNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 2, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 2);
}
void jmpLoopEnd_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2473 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

  // JCC
    Label *l = opnd_array(3)->label();
    emit_cc(cbuf, (0x70 /*primary()*/), opnd_array(1)->ccode());
    int disp = l ? (l->loc_pos() - (cbuf.insts_size() + 1)) : 0;
    assert(-128 <= disp && disp <= 127, "Displacement too large for short jmp");
    emit_d8(cbuf, disp);
  
#line 33457 "../generated/adfiles/ad_x86_64.cpp"
  }
}
uint  jmpLoopEnd_shortNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 2, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 2);
}
void jmpLoopEndU_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2473 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

  // JCC
    Label *l = opnd_array(3)->label();
    emit_cc(cbuf, (0x70 /*primary()*/), opnd_array(1)->ccode());
    int disp = l ? (l->loc_pos() - (cbuf.insts_size() + 1)) : 0;
    assert(-128 <= disp && disp <= 127, "Displacement too large for short jmp");
    emit_d8(cbuf, disp);
  
#line 33482 "../generated/adfiles/ad_x86_64.cpp"
  }
}
uint  jmpLoopEndU_shortNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 2, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 2);
}
void jmpLoopEndUCF_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2473 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

  // JCC
    Label *l = opnd_array(3)->label();
    emit_cc(cbuf, (0x70 /*primary()*/), opnd_array(1)->ccode());
    int disp = l ? (l->loc_pos() - (cbuf.insts_size() + 1)) : 0;
    assert(-128 <= disp && disp <= 127, "Displacement too large for short jmp");
    emit_d8(cbuf, disp);
  
#line 33507 "../generated/adfiles/ad_x86_64.cpp"
  }
}
uint  jmpLoopEndUCF_shortNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 2, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 2);
}
void jmpConU_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2473 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

  // JCC
    Label *l = opnd_array(3)->label();
    emit_cc(cbuf, (0x70 /*primary()*/), opnd_array(1)->ccode());
    int disp = l ? (l->loc_pos() - (cbuf.insts_size() + 1)) : 0;
    assert(-128 <= disp && disp <= 127, "Displacement too large for short jmp");
    emit_d8(cbuf, disp);
  
#line 33532 "../generated/adfiles/ad_x86_64.cpp"
  }
}
uint  jmpConU_shortNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 2, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 2);
}
void jmpConUCF_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 2473 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

  // JCC
    Label *l = opnd_array(3)->label();
    emit_cc(cbuf, (0x70 /*primary()*/), opnd_array(1)->ccode());
    int disp = l ? (l->loc_pos() - (cbuf.insts_size() + 1)) : 0;
    assert(-128 <= disp && disp <= 127, "Displacement too large for short jmp");
    emit_d8(cbuf, disp);
  
#line 33557 "../generated/adfiles/ad_x86_64.cpp"
  }
}
uint  jmpConUCF_shortNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 2, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 2);
}
void jmpConUCF2_shortNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {
    MacroAssembler _masm(&cbuf);

#line 12333 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Label* l = opnd_array(3)->label();
    emit_cc(cbuf, (0x70 /*primary()*/), Assembler::parity);
    int parity_disp = -1;
    if (opnd_array(1)->ccode()== Assembler::notEqual) {
      parity_disp = l ? (l->loc_pos() - (cbuf.insts_size() + 1)) : 0;
    } else if (opnd_array(1)->ccode()== Assembler::equal) {
      parity_disp = 2;
    } else {
      ShouldNotReachHere();
    }
    emit_d8(cbuf, parity_disp);
    emit_cc(cbuf, (0x70 /*primary()*/), opnd_array(1)->ccode());
    int disp = l ? (l->loc_pos() - (cbuf.insts_size() + 1)) : 0;
    emit_d8(cbuf, disp);
    assert(-128 <= disp && disp <= 127, "Displacement too large for short jmp");
    assert(-128 <= parity_disp && parity_disp <= 127, "Displacement too large for short jmp");
  
#line 33593 "../generated/adfiles/ad_x86_64.cpp"
  }
}
uint  jmpConUCF2_shortNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 4, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 4);
}
void cmpFastLockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
    unsigned idx4 = idx3 + opnd_array(3)->num_edges();
  {

#line 3328 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    Register objReg = as_Register((int)opnd_array(1)->reg(ra_,this,idx1));
    Register boxReg = as_Register((int)opnd_array(2)->reg(ra_,this,idx2));
    Register tmpReg = as_Register(opnd_array(3)->reg(ra_,this,idx3));
    Register scrReg = as_Register(opnd_array(4)->reg(ra_,this,idx4));
    MacroAssembler masm(&cbuf);

    // Verify uniqueness of register assignments -- necessary but not sufficient
    assert (objReg != boxReg && objReg != tmpReg &&
            objReg != scrReg && tmpReg != scrReg, "invariant") ;

    if (_counters != NULL) {
      masm.atomic_incl(ExternalAddress((address) _counters->total_entry_count_addr()));
    }
    if (EmitSync & 1) {
        // Without cast to int32_t a movptr will destroy r10 which is typically obj
        masm.movptr (Address(boxReg, 0), (int32_t)intptr_t(markOopDesc::unused_mark())) ;
        masm.cmpptr(rsp, (int32_t)NULL_WORD) ;
    } else
    if (EmitSync & 2) {
        Label DONE_LABEL;
        if (UseBiasedLocking) {
           // Note: tmpReg maps to the swap_reg argument and scrReg to the tmp_reg argument.
          masm.biased_locking_enter(boxReg, objReg, tmpReg, scrReg, false, DONE_LABEL, NULL, _counters);
        }
        // QQQ was movl...
        masm.movptr(tmpReg, 0x1);
        masm.orptr(tmpReg, Address(objReg, 0));
        masm.movptr(Address(boxReg, 0), tmpReg);
        if (os::is_MP()) {
          masm.lock();
        }
        masm.cmpxchgptr(boxReg, Address(objReg, 0)); // Updates tmpReg
        masm.jcc(Assembler::equal, DONE_LABEL);

        // Recursive locking
        masm.subptr(tmpReg, rsp);
        masm.andptr(tmpReg, 7 - os::vm_page_size());
        masm.movptr(Address(boxReg, 0), tmpReg);

        masm.bind(DONE_LABEL);
        masm.nop(); // avoid branch to branch
    } else {
        Label DONE_LABEL, IsInflated, Egress;

        masm.movptr(tmpReg, Address(objReg, 0)) ;
        masm.testl (tmpReg, 0x02) ;         // inflated vs stack-locked|neutral|biased
        masm.jcc   (Assembler::notZero, IsInflated) ;

        // it's stack-locked, biased or neutral
        // TODO: optimize markword triage order to reduce the number of
        // conditional branches in the most common cases.
        // Beware -- there's a subtle invariant that fetch of the markword
        // at [FETCH], below, will never observe a biased encoding (*101b).
        // If this invariant is not held we'll suffer exclusion (safety) failure.

        if (UseBiasedLocking && !UseOptoBiasInlining) {
          masm.biased_locking_enter(boxReg, objReg, tmpReg, scrReg, true, DONE_LABEL, NULL, _counters);
          masm.movptr(tmpReg, Address(objReg, 0)) ;        // [FETCH]
        }

        // was q will it destroy high?
        masm.orl   (tmpReg, 1) ;
        masm.movptr(Address(boxReg, 0), tmpReg) ;
        if (os::is_MP()) { masm.lock(); }
        masm.cmpxchgptr(boxReg, Address(objReg, 0)); // Updates tmpReg
        if (_counters != NULL) {
           masm.cond_inc32(Assembler::equal,
                           ExternalAddress((address) _counters->fast_path_entry_count_addr()));
        }
        masm.jcc   (Assembler::equal, DONE_LABEL);

        // Recursive locking
        masm.subptr(tmpReg, rsp);
        masm.andptr(tmpReg, 7 - os::vm_page_size());
        masm.movptr(Address(boxReg, 0), tmpReg);
        if (_counters != NULL) {
           masm.cond_inc32(Assembler::equal,
                           ExternalAddress((address) _counters->fast_path_entry_count_addr()));
        }
        masm.jmp   (DONE_LABEL) ;

        masm.bind  (IsInflated) ;
        // It's inflated

        // TODO: someday avoid the ST-before-CAS penalty by
        // relocating (deferring) the following ST.
        // We should also think about trying a CAS without having
        // fetched _owner.  If the CAS is successful we may
        // avoid an RTO->RTS upgrade on the $line.
        // Without cast to int32_t a movptr will destroy r10 which is typically obj
        masm.movptr(Address(boxReg, 0), (int32_t)intptr_t(markOopDesc::unused_mark())) ;

        masm.mov    (boxReg, tmpReg) ;
        masm.movptr (tmpReg, Address(tmpReg, ObjectMonitor::owner_offset_in_bytes()-2)) ;
        masm.testptr(tmpReg, tmpReg) ;
        masm.jcc    (Assembler::notZero, DONE_LABEL) ;

        // It's inflated and appears unlocked
        if (os::is_MP()) { masm.lock(); }
        masm.cmpxchgptr(r15_thread, Address(boxReg, ObjectMonitor::owner_offset_in_bytes()-2)) ;
        // Intentional fall-through into DONE_LABEL ...

        masm.bind  (DONE_LABEL) ;
        masm.nop   () ;                 // avoid jmp to jmp
    }
  
#line 33718 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void cmpFastUnlockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
    unsigned idx3 = idx2 + opnd_array(2)->num_edges();
  {

#line 3440 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"


    Register objReg = as_Register(opnd_array(1)->reg(ra_,this,idx1));
    Register boxReg = as_Register(opnd_array(2)->reg(ra_,this,idx2));
    Register tmpReg = as_Register(opnd_array(3)->reg(ra_,this,idx3));
    MacroAssembler masm(&cbuf);

    if (EmitSync & 4) {
       masm.cmpptr(rsp, 0) ;
    } else
    if (EmitSync & 8) {
       Label DONE_LABEL;
       if (UseBiasedLocking) {
         masm.biased_locking_exit(objReg, tmpReg, DONE_LABEL);
       }

       // Check whether the displaced header is 0
       //(=> recursive unlock)
       masm.movptr(tmpReg, Address(boxReg, 0));
       masm.testptr(tmpReg, tmpReg);
       masm.jcc(Assembler::zero, DONE_LABEL);

       // If not recursive lock, reset the header to displaced header
       if (os::is_MP()) {
         masm.lock();
       }
       masm.cmpxchgptr(tmpReg, Address(objReg, 0)); // Uses RAX which is box
       masm.bind(DONE_LABEL);
       masm.nop(); // avoid branch to branch
    } else {
       Label DONE_LABEL, Stacked, CheckSucc ;

       if (UseBiasedLocking && !UseOptoBiasInlining) {
         masm.biased_locking_exit(objReg, tmpReg, DONE_LABEL);
       }

       masm.movptr(tmpReg, Address(objReg, 0)) ;
       masm.cmpptr(Address(boxReg, 0), (int32_t)NULL_WORD) ;
       masm.jcc   (Assembler::zero, DONE_LABEL) ;
       masm.testl (tmpReg, 0x02) ;
       masm.jcc   (Assembler::zero, Stacked) ;

       // It's inflated
       masm.movptr(boxReg, Address (tmpReg, ObjectMonitor::owner_offset_in_bytes()-2)) ;
       masm.xorptr(boxReg, r15_thread) ;
       masm.orptr (boxReg, Address (tmpReg, ObjectMonitor::recursions_offset_in_bytes()-2)) ;
       masm.jcc   (Assembler::notZero, DONE_LABEL) ;
       masm.movptr(boxReg, Address (tmpReg, ObjectMonitor::cxq_offset_in_bytes()-2)) ;
       masm.orptr (boxReg, Address (tmpReg, ObjectMonitor::EntryList_offset_in_bytes()-2)) ;
       masm.jcc   (Assembler::notZero, CheckSucc) ;
       masm.movptr(Address (tmpReg, ObjectMonitor::owner_offset_in_bytes()-2), (int32_t)NULL_WORD) ;
       masm.jmp   (DONE_LABEL) ;

       if ((EmitSync & 65536) == 0) {
         Label LSuccess, LGoSlowPath ;
         masm.bind  (CheckSucc) ;
         masm.cmpptr(Address (tmpReg, ObjectMonitor::succ_offset_in_bytes()-2), (int32_t)NULL_WORD) ;
         masm.jcc   (Assembler::zero, LGoSlowPath) ;

         // I'd much rather use lock:andl m->_owner, 0 as it's faster than the
         // the explicit ST;MEMBAR combination, but masm doesn't currently support
         // "ANDQ M,IMM".  Don't use MFENCE here.  lock:add to TOS, xchg, etc
         // are all faster when the write buffer is populated.
         masm.movptr (Address (tmpReg, ObjectMonitor::owner_offset_in_bytes()-2), (int32_t)NULL_WORD) ;
         if (os::is_MP()) {
            masm.lock () ; masm.addl (Address(rsp, 0), 0) ;
         }
         masm.cmpptr(Address (tmpReg, ObjectMonitor::succ_offset_in_bytes()-2), (int32_t)NULL_WORD) ;
         masm.jcc   (Assembler::notZero, LSuccess) ;

         masm.movptr (boxReg, (int32_t)NULL_WORD) ;                   // box is really EAX
         if (os::is_MP()) { masm.lock(); }
         masm.cmpxchgptr(r15_thread, Address(tmpReg, ObjectMonitor::owner_offset_in_bytes()-2));
         masm.jcc   (Assembler::notEqual, LSuccess) ;
         // Intentional fall-through into slow-path

         masm.bind  (LGoSlowPath) ;
         masm.orl   (boxReg, 1) ;                      // set ICC.ZF=0 to indicate failure
         masm.jmp   (DONE_LABEL) ;

         masm.bind  (LSuccess) ;
         masm.testl (boxReg, 0) ;                      // set ICC.ZF=1 to indicate success
         masm.jmp   (DONE_LABEL) ;
       }

       masm.bind  (Stacked) ;
       masm.movptr(tmpReg, Address (boxReg, 0)) ;      // re-fetch
       if (os::is_MP()) { masm.lock(); }
       masm.cmpxchgptr(tmpReg, Address(objReg, 0)); // Uses RAX which is box

       if (EmitSync & 65536) {
          masm.bind (CheckSucc) ;
       }
       masm.bind(DONE_LABEL);
       if (EmitSync & 32768) {
          masm.nop();                      // avoid branch to branch
       }
    }
  
#line 33830 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void safePoint_pollNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 5;
    unsigned idx1 = 5;
  {
    MacroAssembler _masm(&cbuf);

#line 12397 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);
    __ testl(rax, addr);
  
#line 33846 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void safePoint_poll_farNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 5;
    unsigned idx1 = 5;
  {
    MacroAssembler _masm(&cbuf);

#line 12413 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    __ relocate(relocInfo::poll_type);
    __ testl(rax, Address(opnd_array(1)->as_Register(ra_,this,idx1), 0));
  
#line 33862 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void CallStaticJavaDirectNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2586 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // JAVA STATIC CALL
    // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
    // determine who we intended to call.
    cbuf.set_insts_mark();
    emit_d8(cbuf, (0xE8 /*primary()*/));

    if (!_method) {
      emit_d32_reloc(cbuf,
                     (int) (opnd_array(1)->method() - ((intptr_t) cbuf.insts_end()) - 4),
                     runtime_call_Relocation::spec(),
                     RELOC_DISP32);
    } else if (_optimized_virtual) {
      emit_d32_reloc(cbuf,
                     (int) (opnd_array(1)->method() - ((intptr_t) cbuf.insts_end()) - 4),
                     opt_virtual_call_Relocation::spec(),
                     RELOC_DISP32);
    } else {
      emit_d32_reloc(cbuf,
                     (int) (opnd_array(1)->method() - ((intptr_t) cbuf.insts_end()) - 4),
                     static_call_Relocation::spec(),
                     RELOC_DISP32);
    }
    if (_method) {
      // Emit stub for static call
      emit_java_to_interp(cbuf);
    }
  
#line 33901 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 80 "/home/top/workspace/openjdk7/hotspot/src/os_cpu/linux_x86/vm/linux_x86_64.ad"

    if (VerifyStackAtCalls) {
      // Check that stack depth is unchanged: find majik cookie on stack
      int framesize =
        ra_->reg2offset_unchecked(OptoReg::add(ra_->_matcher._old_SP, -3*VMRegImpl::slots_per_word));
      if (framesize) {
        if (framesize < 0x80) {
          emit_opcode(cbuf, Assembler::REX_W);
          emit_opcode(cbuf, 0x81); // cmpq [rsp+0],0xbadb1ood
          emit_d8(cbuf, 0x7C);
          emit_d8(cbuf, 0x24);
          emit_d8(cbuf, framesize); // Find majik cookie from ESP
          emit_d32(cbuf, 0xbadb100d);
        } else {
          emit_opcode(cbuf, Assembler::REX_W);
          emit_opcode(cbuf, 0x81); // cmpq [rsp+0],0xbadb1ood
          emit_d8(cbuf, 0xBC);
          emit_d8(cbuf, 0x24);
          emit_d32(cbuf, framesize); // Find majik cookie from ESP
          emit_d32(cbuf, 0xbadb100d);
        }
      }
      // jmp EQ around INT3
      // QQQ TODO
      const int jump_around = 5; // size of call to breakpoint, 1 for CC
      emit_opcode(cbuf, 0x74);
      emit_d8(cbuf, jump_around);
      // QQQ temporary
      emit_break(cbuf);
      // Die if stack mismatch
      // emit_opcode(cbuf,0xCC);
    }
  
#line 33939 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void CallStaticJavaHandleNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2570 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    debug_only(int off0 = cbuf.insts_size());
    MacroAssembler _masm(&cbuf);
    // RBP is preserved across all calls, even compiled calls.
    // Use it to preserve RSP in places where the callee might change the SP.
    __ movptr(rbp_mh_SP_save, rsp);
    debug_only(int off1 = cbuf.insts_size());
    assert(off1 - off0 == preserve_SP_size(), "correct size prediction");
  
#line 33959 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2586 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // JAVA STATIC CALL
    // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
    // determine who we intended to call.
    cbuf.set_insts_mark();
    emit_d8(cbuf, (0xE8 /*primary()*/));

    if (!_method) {
      emit_d32_reloc(cbuf,
                     (int) (opnd_array(1)->method() - ((intptr_t) cbuf.insts_end()) - 4),
                     runtime_call_Relocation::spec(),
                     RELOC_DISP32);
    } else if (_optimized_virtual) {
      emit_d32_reloc(cbuf,
                     (int) (opnd_array(1)->method() - ((intptr_t) cbuf.insts_end()) - 4),
                     opt_virtual_call_Relocation::spec(),
                     RELOC_DISP32);
    } else {
      emit_d32_reloc(cbuf,
                     (int) (opnd_array(1)->method() - ((intptr_t) cbuf.insts_end()) - 4),
                     static_call_Relocation::spec(),
                     RELOC_DISP32);
    }
    if (_method) {
      // Emit stub for static call
      emit_java_to_interp(cbuf);
    }
  
#line 33992 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2580 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    MacroAssembler _masm(&cbuf);
    __ movptr(rsp, rbp_mh_SP_save);
  
#line 34001 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 80 "/home/top/workspace/openjdk7/hotspot/src/os_cpu/linux_x86/vm/linux_x86_64.ad"

    if (VerifyStackAtCalls) {
      // Check that stack depth is unchanged: find majik cookie on stack
      int framesize =
        ra_->reg2offset_unchecked(OptoReg::add(ra_->_matcher._old_SP, -3*VMRegImpl::slots_per_word));
      if (framesize) {
        if (framesize < 0x80) {
          emit_opcode(cbuf, Assembler::REX_W);
          emit_opcode(cbuf, 0x81); // cmpq [rsp+0],0xbadb1ood
          emit_d8(cbuf, 0x7C);
          emit_d8(cbuf, 0x24);
          emit_d8(cbuf, framesize); // Find majik cookie from ESP
          emit_d32(cbuf, 0xbadb100d);
        } else {
          emit_opcode(cbuf, Assembler::REX_W);
          emit_opcode(cbuf, 0x81); // cmpq [rsp+0],0xbadb1ood
          emit_d8(cbuf, 0xBC);
          emit_d8(cbuf, 0x24);
          emit_d32(cbuf, framesize); // Find majik cookie from ESP
          emit_d32(cbuf, 0xbadb100d);
        }
      }
      // jmp EQ around INT3
      // QQQ TODO
      const int jump_around = 5; // size of call to breakpoint, 1 for CC
      emit_opcode(cbuf, 0x74);
      emit_d8(cbuf, jump_around);
      // QQQ temporary
      emit_break(cbuf);
      // Die if stack mismatch
      // emit_opcode(cbuf,0xCC);
    }
  
#line 34039 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void CallDynamicJavaDirectNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 2616 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // JAVA DYNAMIC CALL
    // !!!!!
    // Generate  "movq rax, -1", placeholder instruction to load oop-info
    // emit_call_dynamic_prologue( cbuf );
    cbuf.set_insts_mark();

    // movq rax, -1
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0xB8 | RAX_enc);
    emit_d64_reloc(cbuf,
                   (int64_t) Universe::non_oop_word(),
                   oop_Relocation::spec_for_immediate(), RELOC_IMM64);
    address virtual_call_oop_addr = cbuf.insts_mark();
    // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
    // who we intended to call.
    cbuf.set_insts_mark();
    emit_d8(cbuf, (0xE8 /*primary()*/));
    emit_d32_reloc(cbuf,
                   (int) (opnd_array(1)->method() - ((intptr_t) cbuf.insts_end()) - 4),
                   virtual_call_Relocation::spec(virtual_call_oop_addr),
                   RELOC_DISP32);
  
#line 34073 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 80 "/home/top/workspace/openjdk7/hotspot/src/os_cpu/linux_x86/vm/linux_x86_64.ad"

    if (VerifyStackAtCalls) {
      // Check that stack depth is unchanged: find majik cookie on stack
      int framesize =
        ra_->reg2offset_unchecked(OptoReg::add(ra_->_matcher._old_SP, -3*VMRegImpl::slots_per_word));
      if (framesize) {
        if (framesize < 0x80) {
          emit_opcode(cbuf, Assembler::REX_W);
          emit_opcode(cbuf, 0x81); // cmpq [rsp+0],0xbadb1ood
          emit_d8(cbuf, 0x7C);
          emit_d8(cbuf, 0x24);
          emit_d8(cbuf, framesize); // Find majik cookie from ESP
          emit_d32(cbuf, 0xbadb100d);
        } else {
          emit_opcode(cbuf, Assembler::REX_W);
          emit_opcode(cbuf, 0x81); // cmpq [rsp+0],0xbadb1ood
          emit_d8(cbuf, 0xBC);
          emit_d8(cbuf, 0x24);
          emit_d32(cbuf, framesize); // Find majik cookie from ESP
          emit_d32(cbuf, 0xbadb100d);
        }
      }
      // jmp EQ around INT3
      // QQQ TODO
      const int jump_around = 5; // size of call to breakpoint, 1 for CC
      emit_opcode(cbuf, 0x74);
      emit_d8(cbuf, jump_around);
      // QQQ temporary
      emit_break(cbuf);
      // Die if stack mismatch
      // emit_opcode(cbuf,0xCC);
    }
  
#line 34111 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void CallRuntimeDirectNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 59 "/home/top/workspace/openjdk7/hotspot/src/os_cpu/linux_x86/vm/linux_x86_64.ad"

    // No relocation needed

    // movq r10, <meth>
    emit_opcode(cbuf, Assembler::REX_WB);
    emit_opcode(cbuf, 0xB8 | (R10_enc - 8));
    emit_d64(cbuf, (int64_t) opnd_array(1)->method());

    // call (r10)
    emit_opcode(cbuf, Assembler::REX_B);
    emit_opcode(cbuf, 0xFF);
    emit_opcode(cbuf, 0xD0 | (R10_enc - 8));
  
#line 34135 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void CallLeafDirectNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 59 "/home/top/workspace/openjdk7/hotspot/src/os_cpu/linux_x86/vm/linux_x86_64.ad"

    // No relocation needed

    // movq r10, <meth>
    emit_opcode(cbuf, Assembler::REX_WB);
    emit_opcode(cbuf, 0xB8 | (R10_enc - 8));
    emit_d64(cbuf, (int64_t) opnd_array(1)->method());

    // call (r10)
    emit_opcode(cbuf, Assembler::REX_B);
    emit_opcode(cbuf, 0xFF);
    emit_opcode(cbuf, 0xD0 | (R10_enc - 8));
  
#line 34159 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void CallLeafNoFPDirectNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  {

#line 59 "/home/top/workspace/openjdk7/hotspot/src/os_cpu/linux_x86/vm/linux_x86_64.ad"

    // No relocation needed

    // movq r10, <meth>
    emit_opcode(cbuf, Assembler::REX_WB);
    emit_opcode(cbuf, 0xB8 | (R10_enc - 8));
    emit_d64(cbuf, (int64_t) opnd_array(1)->method());

    // call (r10)
    emit_opcode(cbuf, Assembler::REX_B);
    emit_opcode(cbuf, 0xFF);
    emit_opcode(cbuf, 0xD0 | (R10_enc - 8));
  
#line 34183 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void RetNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 5;
    unsigned idx1 = 5;
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xC3 /*primary()*/));
  
#line 34197 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void TailCalljmpIndNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 5;
    unsigned idx1 = 5;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 34214 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 34222 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x4 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 34231 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void tailjmpIndNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 5;
    unsigned idx1 = 5;
    unsigned idx2 = idx1 + opnd_array(1)->num_edges();
  {

#line 2161 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0x5a));
  
#line 34246 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2966 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    if (opnd_array(1)->reg(ra_,this,idx1) >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  
#line 34256 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2143 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    emit_opcode(cbuf, (0xFF /*primary()*/));
  
#line 34264 "../generated/adfiles/ad_x86_64.cpp"
  }
  {

#line 2458 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, (0x4 /*secondary()*/), opnd_array(1)->reg(ra_,this,idx1) & 7);
  
#line 34273 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void CreateExceptionNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  // User did not define which encode class to use.
}
uint  CreateExceptionNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 0);
}
void RethrowExceptionNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 5;
    unsigned idx1 = 5;
  {

#line 3542 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    cbuf.set_insts_mark();
    emit_opcode(cbuf, 0xE9); // jmp entry
    emit_d32_reloc(cbuf,
                   (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
                   runtime_call_Relocation::spec(),
                   RELOC_DISP32);
  
#line 34303 "../generated/adfiles/ad_x86_64.cpp"
  }
}
void tlsLoadPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 1;
    unsigned idx1 = 1;
  // User did not define which encode class to use.
}
uint  tlsLoadPNode::size(PhaseRegAlloc *ra_) const {
 assert(VerifyOops || MachNode::size(ra_) <= 0, "bad fixed size");
 return (VerifyOops ? MachNode::size(ra_) : 0);
}
void ShouldNotReachHereNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  cbuf.set_insts_mark();
    // Start at oper_input_base() and count operands
    unsigned idx0 = 5;
    unsigned idx1 = 5;
  {

#line 74 "/home/top/workspace/openjdk7/hotspot/src/os_cpu/linux_x86/vm/linux_x86_64.ad"

    MacroAssembler* masm = new MacroAssembler(&cbuf);
    masm->call(RuntimeAddress(CAST_FROM_FN_PTR(address, os::breakpoint)));
  
#line 34329 "../generated/adfiles/ad_x86_64.cpp"
  }
}
const MachOper* loadBNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadB2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUBNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUB2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUB2L_immI8Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadSNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadS2BNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadS2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUSNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUS2BNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUS2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUS2L_immI_255Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadUS2L_immI16Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadINode::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2BNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2UBNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2SNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2USNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2L_immI_255Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2L_immI_65535Node::memory_operand() const { return _opnds[1]; }
const MachOper* loadI2L_immINode::memory_operand() const { return _opnds[1]; }
const MachOper* loadUI2LNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadLNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadRangeNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadPNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadNNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadKlassNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadNKlassNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadFNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadD_partialNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadDNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadA8BNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadA4SNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadA4CNode::memory_operand() const { return _opnds[1]; }
const MachOper* load2IUNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadA2FNode::memory_operand() const { return _opnds[1]; }
const MachOper* prefetchrNode::memory_operand() const { return _opnds[1]; }
const MachOper* prefetchrNTANode::memory_operand() const { return _opnds[1]; }
const MachOper* prefetchrT0Node::memory_operand() const { return _opnds[1]; }
const MachOper* prefetchrT2Node::memory_operand() const { return _opnds[1]; }
const MachOper* prefetchwNode::memory_operand() const { return _opnds[1]; }
const MachOper* prefetchwNTANode::memory_operand() const { return _opnds[1]; }
const MachOper* prefetchwT0Node::memory_operand() const { return _opnds[1]; }
const MachOper* prefetchwT2Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeBNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeCNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeINode::memory_operand() const { return _opnds[1]; }
const MachOper* storeLNode::memory_operand() const { return _opnds[1]; }
const MachOper* storePNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmP0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmPNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeNNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmN0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmNNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmI0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmINode::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmL0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmLNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmC0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmI16Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmB0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmBNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeA8BNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeA4CNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeA2INode::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmCM0_regNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeImmCM0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeA2FNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeFNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeF0Node::memory_operand() const { return _opnds[1]; }
const MachOper* storeF_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeDNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeD0_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeD0Node::memory_operand() const { return _opnds[1]; }
const MachOper* popCountI_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* popCountL_memNode::memory_operand() const { return _opnds[1]; }
const TypePtr *membar_acquireNode::adr_type() const { return TypePtr::BOTTOM; }
const MachOper* membar_acquireNode::memory_operand() const { return (MachOper*)-1; }
const TypePtr *membar_acquire_lockNode::adr_type() const { return TypePtr::BOTTOM; }
const MachOper* membar_acquire_lockNode::memory_operand() const { return (MachOper*)-1; }
const TypePtr *membar_releaseNode::adr_type() const { return TypePtr::BOTTOM; }
const MachOper* membar_releaseNode::memory_operand() const { return (MachOper*)-1; }
const TypePtr *membar_release_lockNode::adr_type() const { return TypePtr::BOTTOM; }
const MachOper* membar_release_lockNode::memory_operand() const { return (MachOper*)-1; }
const MachOper* cmovI_memNode::memory_operand() const { return _opnds[4]; }
const MachOper* cmovI_memUNode::memory_operand() const { return _opnds[4]; }
const MachOper* cmovI_memUCFNode::memory_operand() const { return _opnds[4]; }
const MachOper* cmovL_memNode::memory_operand() const { return _opnds[4]; }
const MachOper* cmovL_memUNode::memory_operand() const { return _opnds[4]; }
const MachOper* cmovL_memUCFNode::memory_operand() const { return _opnds[4]; }
const MachOper* addI_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* addI_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* addI_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* addI_mem_rReg_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* addI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* incI_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* decI_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* addL_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* addL_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* addL_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* addL_mem_rReg_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* addL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* incL_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* decL_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadPLockedNode::memory_operand() const { return _opnds[1]; }
const MachOper* loadLLockedNode::memory_operand() const { return _opnds[1]; }
const MachOper* storePConditionalNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeIConditionalNode::memory_operand() const { return _opnds[1]; }
const MachOper* storeLConditionalNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapPNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapLNode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapINode::memory_operand() const { return _opnds[1]; }
const MachOper* compareAndSwapNNode::memory_operand() const { return _opnds[1]; }
const MachOper* subI_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* subI_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* subI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* subL_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* subL_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* subL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* negI_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* negL_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* mulI_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* mulI_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* mulI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* mulL_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* mulL_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* mulL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* salI_mem_1Node::memory_operand() const { return _opnds[1]; }
const MachOper* salI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* salI_mem_CLNode::memory_operand() const { return _opnds[1]; }
const MachOper* sarI_mem_1Node::memory_operand() const { return _opnds[1]; }
const MachOper* sarI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* sarI_mem_CLNode::memory_operand() const { return _opnds[1]; }
const MachOper* shrI_mem_1Node::memory_operand() const { return _opnds[1]; }
const MachOper* shrI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* shrI_mem_CLNode::memory_operand() const { return _opnds[1]; }
const MachOper* salL_mem_1Node::memory_operand() const { return _opnds[1]; }
const MachOper* salL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* salL_mem_CLNode::memory_operand() const { return _opnds[1]; }
const MachOper* sarL_mem_1Node::memory_operand() const { return _opnds[1]; }
const MachOper* sarL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* sarL_mem_CLNode::memory_operand() const { return _opnds[1]; }
const MachOper* shrL_mem_1Node::memory_operand() const { return _opnds[1]; }
const MachOper* shrL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* shrL_mem_CLNode::memory_operand() const { return _opnds[1]; }
const MachOper* andI_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* andI_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* andI_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* andI_mem_rReg_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* andI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* orI_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* orI_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* orI_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* orI_mem_rReg_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* orI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* xorI_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* xorI_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* xorI_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* xorI_mem_rReg_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* xorI_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* andL_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* andL_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* andL_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* andL_mem_rReg_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* andL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* orL_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* orL_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* orL_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* orL_mem_rReg_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* orL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* xorL_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* xorL_rReg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* xorL_mem_rRegNode::memory_operand() const { return _opnds[1]; }
const MachOper* xorL_mem_rReg_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* xorL_mem_immNode::memory_operand() const { return _opnds[1]; }
const MachOper* cmpF_cc_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* cmpF_cc_memCFNode::memory_operand() const { return _opnds[2]; }
const MachOper* cmpD_cc_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* cmpD_cc_memCFNode::memory_operand() const { return _opnds[2]; }
const MachOper* cmpF_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* cmpD_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* addF_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* addF_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* addD_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* addD_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* subF_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* subD_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* mulF_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* mulF_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* mulD_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* mulD_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* divF_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* divD_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* sqrtF_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* sqrtD_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* convF2D_reg_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* convD2F_reg_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* convI2F_reg_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* convI2D_reg_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* convL2F_reg_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* convL2D_reg_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* convI2L_reg_mem_zexNode::memory_operand() const { return _opnds[1]; }
const MachOper* compI_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* testI_reg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* testI_reg_mem_0Node::memory_operand() const { return _opnds[1]; }
const MachOper* compU_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* compP_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* compP_mem_rRegNode::memory_operand() const { return _opnds[2]; }
const MachOper* testP_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* testP_mem_reg0Node::memory_operand() const { return _opnds[1]; }
const MachOper* compN_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* compN_mem_immNode::memory_operand() const { return _opnds[2]; }
const MachOper* testN_memNode::memory_operand() const { return _opnds[1]; }
const MachOper* testN_mem_reg0Node::memory_operand() const { return _opnds[1]; }
const MachOper* compL_rReg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* testL_reg_memNode::memory_operand() const { return _opnds[2]; }
const MachOper* testL_reg_mem_0Node::memory_operand() const { return _opnds[1]; }


const bool Matcher::has_match_rule(int opcode) {
  assert(_last_machine_leaf < opcode && opcode < _last_opcode, "opcode in range");
  return _hasMatchRule[opcode];
}

const bool Matcher::_hasMatchRule[_last_opcode] = {
    false,  // Node
    false,  // Set
    false,  // RegN
    false,  // RegI
    false,  // RegP
    false,  // RegF
    false,  // RegD
    false,  // RegL
    false,  // RegFlags
    false,  // _last_machine_leaf
    true ,  // AbsD
    true ,  // AbsF
    false,  // AbsI
    true ,  // AddD
    true ,  // AddF
    true ,  // AddI
    true ,  // AddL
    true ,  // AddP
    false,  // Allocate
    false,  // AllocateArray
    true ,  // AndI
    true ,  // AndL
    true ,  // AryEq
    false,  // AtanD
    true ,  // Binary
    true ,  // Bool
    false,  // BoxLock
    true ,  // ReverseBytesI
    true ,  // ReverseBytesL
    true ,  // ReverseBytesUS
    true ,  // ReverseBytesS
    false,  // CProj
    true ,  // CallDynamicJava
    false,  // CallJava
    true ,  // CallLeaf
    true ,  // CallLeafNoFP
    true ,  // CallRuntime
    true ,  // CallStaticJava
    true ,  // CastII
    true ,  // CastX2P
    true ,  // CastP2X
    true ,  // CastPP
    false,  // Catch
    false,  // CatchProj
    true ,  // CheckCastPP
    true ,  // ClearArray
    false,  // ConstraintCast
    true ,  // CMoveD
    true ,  // CMoveF
    true ,  // CMoveI
    true ,  // CMoveL
    true ,  // CMoveP
    true ,  // CMoveN
    true ,  // CmpN
    true ,  // CmpD
    true ,  // CmpD3
    true ,  // CmpF
    true ,  // CmpF3
    true ,  // CmpI
    true ,  // CmpL
    true ,  // CmpL3
    true ,  // CmpLTMask
    true ,  // CmpP
    true ,  // CmpU
    true ,  // CompareAndSwapI
    true ,  // CompareAndSwapL
    true ,  // CompareAndSwapP
    true ,  // CompareAndSwapN
    false,  // Con
    true ,  // ConN
    true ,  // ConD
    true ,  // ConF
    true ,  // ConI
    true ,  // ConL
    true ,  // ConP
    true ,  // Conv2B
    true ,  // ConvD2F
    true ,  // ConvD2I
    true ,  // ConvD2L
    true ,  // ConvF2D
    true ,  // ConvF2I
    true ,  // ConvF2L
    true ,  // ConvI2D
    true ,  // ConvI2F
    true ,  // ConvI2L
    true ,  // ConvL2D
    true ,  // ConvL2F
    true ,  // ConvL2I
    true ,  // CosD
    false,  // CountedLoop
    true ,  // CountedLoopEnd
    true ,  // CountLeadingZerosI
    true ,  // CountLeadingZerosL
    true ,  // CountTrailingZerosI
    true ,  // CountTrailingZerosL
    true ,  // CreateEx
    true ,  // DecodeN
    true ,  // DivD
    true ,  // DivF
    true ,  // DivI
    true ,  // DivL
    false,  // DivMod
    true ,  // DivModI
    true ,  // DivModL
    true ,  // EncodeP
    false,  // ExpD
    true ,  // FastLock
    true ,  // FastUnlock
    true ,  // Goto
    true ,  // Halt
    true ,  // If
    false,  // IfFalse
    false,  // IfTrue
    false,  // Initialize
    false,  // JProj
    true ,  // Jump
    false,  // JumpProj
    true ,  // LShiftI
    true ,  // LShiftL
    true ,  // LoadB
    true ,  // LoadUB
    true ,  // LoadUS
    true ,  // LoadD
    false,  // LoadD_unaligned
    true ,  // LoadF
    true ,  // LoadI
    true ,  // LoadUI2L
    true ,  // LoadKlass
    true ,  // LoadNKlass
    true ,  // LoadL
    false,  // LoadL_unaligned
    true ,  // LoadPLocked
    true ,  // LoadLLocked
    true ,  // LoadP
    true ,  // LoadN
    true ,  // LoadRange
    true ,  // LoadS
    false,  // Lock
    true ,  // LogD
    true ,  // Log10D
    false,  // Loop
    false,  // LoopLimit
    false,  // Mach
    false,  // MachProj
    true ,  // MaxI
    true ,  // MemBarAcquire
    false,  // MemBarCPUOrder
    true ,  // MemBarRelease
    true ,  // MemBarVolatile
    false,  // MergeMem
    true ,  // MinI
    false,  // ModD
    false,  // ModF
    true ,  // ModI
    true ,  // ModL
    true ,  // MoveI2F
    true ,  // MoveF2I
    true ,  // MoveL2D
    true ,  // MoveD2L
    true ,  // MulD
    true ,  // MulF
    true ,  // MulHiL
    true ,  // MulI
    true ,  // MulL
    false,  // Multi
    true ,  // NegD
    true ,  // NegF
    false,  // NeverBranch
    false,  // Opaque1
    false,  // Opaque2
    true ,  // OrI
    true ,  // OrL
    false,  // PCTable
    false,  // Parm
    true ,  // PartialSubtypeCheck
    false,  // Phi
    true ,  // PopCountI
    true ,  // PopCountL
    false,  // PowD
    true ,  // PrefetchRead
    true ,  // PrefetchWrite
    false,  // Proj
    true ,  // RShiftI
    true ,  // RShiftL
    false,  // Region
    true ,  // Rethrow
    true ,  // Return
    false,  // Root
    true ,  // RoundDouble
    true ,  // RoundFloat
    true ,  // SafePoint
    false,  // SafePointScalarObject
    false,  // SCMemProj
    true ,  // SinD
    true ,  // SqrtD
    false,  // Start
    false,  // StartOSR
    true ,  // StoreB
    true ,  // StoreC
    true ,  // StoreCM
    true ,  // StorePConditional
    true ,  // StoreIConditional
    true ,  // StoreLConditional
    true ,  // StoreD
    true ,  // StoreF
    true ,  // StoreI
    true ,  // StoreL
    true ,  // StoreP
    true ,  // StoreN
    true ,  // StrComp
    true ,  // StrEquals
    true ,  // StrIndexOf
    true ,  // SubD
    true ,  // SubF
    true ,  // SubI
    true ,  // SubL
    true ,  // TailCall
    true ,  // TailJump
    true ,  // TanD
    true ,  // ThreadLocal
    false,  // Unlock
    true ,  // URShiftI
    true ,  // URShiftL
    true ,  // XorI
    true ,  // XorL
    false,  // Vector
    false,  // AddVB
    false,  // AddVC
    false,  // AddVS
    false,  // AddVI
    false,  // AddVL
    false,  // AddVF
    false,  // AddVD
    false,  // SubVB
    false,  // SubVC
    false,  // SubVS
    false,  // SubVI
    false,  // SubVL
    false,  // SubVF
    false,  // SubVD
    false,  // MulVF
    false,  // MulVD
    false,  // DivVF
    false,  // DivVD
    false,  // LShiftVB
    false,  // LShiftVC
    false,  // LShiftVS
    false,  // LShiftVI
    false,  // URShiftVB
    false,  // URShiftVC
    false,  // URShiftVS
    false,  // URShiftVI
    false,  // AndV
    false,  // OrV
    false,  // XorV
    false,  // VectorLoad
    false,  // Load16B
    true ,  // Load8B
    false,  // Load4B
    false,  // Load8C
    true ,  // Load4C
    false,  // Load2C
    false,  // Load8S
    true ,  // Load4S
    false,  // Load2S
    false,  // Load4I
    true ,  // Load2I
    false,  // Load2L
    false,  // Load4F
    true ,  // Load2F
    false,  // Load2D
    false,  // VectorStore
    false,  // Store16B
    true ,  // Store8B
    false,  // Store4B
    false,  // Store8C
    true ,  // Store4C
    false,  // Store2C
    false,  // Store4I
    true ,  // Store2I
    false,  // Store2L
    false,  // Store4F
    true ,  // Store2F
    false,  // Store2D
    false,  // Pack
    false,  // PackB
    false,  // PackS
    false,  // PackC
    false,  // PackI
    false,  // PackL
    false,  // PackF
    false,  // PackD
    false,  // Pack2x1B
    false,  // Pack2x2B
    false,  // Replicate16B
    true ,  // Replicate8B
    false,  // Replicate4B
    false,  // Replicate8S
    true ,  // Replicate4S
    false,  // Replicate2S
    false,  // Replicate8C
    true ,  // Replicate4C
    false,  // Replicate2C
    false,  // Replicate4I
    true ,  // Replicate2I
    false,  // Replicate2L
    false,  // Replicate4F
    true ,  // Replicate2F
    false,  // Replicate2D
    false,  // Extract
    false,  // ExtractB
    false,  // ExtractS
    false,  // ExtractC
    false,  // ExtractI
    false,  // ExtractL
    false,  // ExtractF
    false   // ExtractD
};


bool Matcher::stack_direction() const { return false; }

int Compile::sync_stack_slots() const { return 2; }

uint Matcher::stack_alignment_in_bytes() { return StackAlignmentInBytes; }

OptoReg::Name Matcher::return_addr() const { return OptoReg::stack2reg(- 2 +
              round_to(2 + 2 * VerifyStackAtCalls +
                       Compile::current()->fixed_slots(),
                       WordsPerLong * 2)); }

uint Compile::in_preserve_stack_slots() { return 4 + 2 * VerifyStackAtCalls; }

uint Compile::out_preserve_stack_slots() { return SharedRuntime::out_preserve_stack_slots(); }

uint Compile::varargs_C_out_slots_killed() const { return frame::arg_reg_save_area_bytes/BytesPerInt; }

void Matcher::calling_convention(BasicType *sig_bt, VMRegPair *regs, uint length, bool is_outgoing) {

#line 3967 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // No difference between ingoing/outgoing just pass false
    SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
  
#line 34902 "../generated/adfiles/ad_x86_64.cpp"

}

void Matcher::c_calling_convention(BasicType *sig_bt, VMRegPair *regs, uint length) {

#line 3973 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    // This is obviously always outgoing
    (void) SharedRuntime::c_calling_convention(sig_bt, regs, length);
  
#line 34913 "../generated/adfiles/ad_x86_64.cpp"

}

OptoRegPair Matcher::return_value(int ideal_reg, bool is_outgoing) {

#line 3980 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    assert(ideal_reg >= Op_RegI && ideal_reg <= Op_RegL,
           "only return normal values");

    static const int lo[Op_RegL + 1] = {
      0,
      0,
      RAX_num,  // Op_RegN
      RAX_num,  // Op_RegI
      RAX_num,  // Op_RegP
      XMM0_num, // Op_RegF
      XMM0_num, // Op_RegD
      RAX_num   // Op_RegL
    };
    static const int hi[Op_RegL + 1] = {
      0,
      0,
      OptoReg::Bad, // Op_RegN
      OptoReg::Bad, // Op_RegI
      RAX_H_num,    // Op_RegP
      OptoReg::Bad, // Op_RegF
      XMM0_H_num,   // Op_RegD
      RAX_H_num     // Op_RegL
    };
    assert(ARRAY_SIZE(hi) == _last_machine_leaf - 1, "missing type");
    return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
  
#line 34947 "../generated/adfiles/ad_x86_64.cpp"

}

OptoRegPair Matcher::c_return_value(int ideal_reg, bool is_outgoing) {

#line 3980 "/home/top/workspace/openjdk7/hotspot/src/cpu/x86/vm/x86_64.ad"

    assert(ideal_reg >= Op_RegI && ideal_reg <= Op_RegL,
           "only return normal values");

    static const int lo[Op_RegL + 1] = {
      0,
      0,
      RAX_num,  // Op_RegN
      RAX_num,  // Op_RegI
      RAX_num,  // Op_RegP
      XMM0_num, // Op_RegF
      XMM0_num, // Op_RegD
      RAX_num   // Op_RegL
    };
    static const int hi[Op_RegL + 1] = {
      0,
      0,
      OptoReg::Bad, // Op_RegN
      OptoReg::Bad, // Op_RegI
      RAX_H_num,    // Op_RegP
      OptoReg::Bad, // Op_RegF
      XMM0_H_num,   // Op_RegD
      RAX_H_num     // Op_RegL
    };
    assert(ARRAY_SIZE(hi) == _last_machine_leaf - 1, "missing type");
    return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
  
#line 34981 "../generated/adfiles/ad_x86_64.cpp"

}

OptoReg::Name Matcher::inline_cache_reg() { return OptoReg::Name(RAX_num); }

const RegMask &Matcher::inline_cache_reg_mask() { return INLINE_CACHE_REG_mask; }

int Matcher::inline_cache_reg_encode() { return _regEncode[inline_cache_reg()]; }

OptoReg::Name Matcher::interpreter_method_oop_reg() { return OptoReg::Name(RBX_num); }

const RegMask &Matcher::interpreter_method_oop_reg_mask() { return INTERPRETER_METHOD_OOP_REG_mask; }

int Matcher::interpreter_method_oop_reg_encode() { return _regEncode[interpreter_method_oop_reg()]; }

OptoReg::Name Matcher::interpreter_frame_pointer_reg() { return OptoReg::Name(RBP_num); }

const RegMask &Matcher::interpreter_frame_pointer_reg_mask() { return INTERPRETER_FRAME_POINTER_REG_mask; }

OptoReg::Name Matcher::c_frame_pointer() const { return OptoReg::Name(RSP_num); }

// Number of callee-save + always-save registers
int  Matcher::number_of_saved_registers() {
  return 0;
};

// Check consistency of C++ compilation with ADLC options:
// Check adlc -DLINUX=1
#ifndef LINUX
#  error "LINUX must be defined"
#endif // LINUX
// Check adlc -D_GNU_SOURCE=1
#ifndef _GNU_SOURCE
#  error "_GNU_SOURCE must be defined"
#endif // _GNU_SOURCE
// Check adlc -DAMD64=1
#ifndef AMD64
#  error "AMD64 must be defined"
#endif // AMD64
// Check adlc -D_LP64=1
#ifndef _LP64
#  error "_LP64 must be defined"
#endif // _LP64
